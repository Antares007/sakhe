"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SR$$$undefinedNameNamespace$$Z721C83C5 = SR$$$undefinedNameNamespace$$Z721C83C5;
exports.SR$$$undefinedNameNamespaceOrModule$$Z721C83C5 = SR$$$undefinedNameNamespaceOrModule$$Z721C83C5;
exports.SR$$$undefinedNameFieldConstructorOrMember$$Z721C83C5 = SR$$$undefinedNameFieldConstructorOrMember$$Z721C83C5;
exports.SR$$$undefinedNameValueConstructorNamespaceOrType$$Z721C83C5 = SR$$$undefinedNameValueConstructorNamespaceOrType$$Z721C83C5;
exports.SR$$$undefinedNameValueOfConstructor$$Z721C83C5 = SR$$$undefinedNameValueOfConstructor$$Z721C83C5;
exports.SR$$$undefinedNameValueNamespaceTypeOrModule$$Z721C83C5 = SR$$$undefinedNameValueNamespaceTypeOrModule$$Z721C83C5;
exports.SR$$$undefinedNameConstructorModuleOrNamespace$$Z721C83C5 = SR$$$undefinedNameConstructorModuleOrNamespace$$Z721C83C5;
exports.SR$$$undefinedNameType$$Z721C83C5 = SR$$$undefinedNameType$$Z721C83C5;
exports.SR$$$undefinedNameTypeIn$$Z384F8060 = SR$$$undefinedNameTypeIn$$Z384F8060;
exports.SR$$$undefinedNameRecordLabelOrNamespace$$Z721C83C5 = SR$$$undefinedNameRecordLabelOrNamespace$$Z721C83C5;
exports.SR$$$undefinedNameRecordLabel$$Z721C83C5 = SR$$$undefinedNameRecordLabel$$Z721C83C5;
exports.SR$$$undefinedNameSuggestionsIntro = SR$$$undefinedNameSuggestionsIntro;
exports.SR$$$undefinedNameTypeParameter$$Z721C83C5 = SR$$$undefinedNameTypeParameter$$Z721C83C5;
exports.SR$$$undefinedNamePatternDiscriminator$$Z721C83C5 = SR$$$undefinedNamePatternDiscriminator$$Z721C83C5;
exports.SR$$$replaceWithSuggestion$$Z721C83C5 = SR$$$replaceWithSuggestion$$Z721C83C5;
exports.SR$$$addIndexerDot = SR$$$addIndexerDot;
exports.SR$$$listElementHasWrongType$$Z384F8060 = SR$$$listElementHasWrongType$$Z384F8060;
exports.SR$$$arrayElementHasWrongType$$Z384F8060 = SR$$$arrayElementHasWrongType$$Z384F8060;
exports.SR$$$missingElseBranch$$Z721C83C5 = SR$$$missingElseBranch$$Z721C83C5;
exports.SR$$$ifExpression$$Z384F8060 = SR$$$ifExpression$$Z384F8060;
exports.SR$$$elseBranchHasWrongType$$Z384F8060 = SR$$$elseBranchHasWrongType$$Z384F8060;
exports.SR$$$followingPatternMatchClauseHasWrongType$$Z384F8060 = SR$$$followingPatternMatchClauseHasWrongType$$Z384F8060;
exports.SR$$$patternMatchGuardIsNotBool$$Z721C83C5 = SR$$$patternMatchGuardIsNotBool$$Z721C83C5;
exports.SR$$$commaInsteadOfSemicolonInRecord = SR$$$commaInsteadOfSemicolonInRecord;
exports.SR$$$derefInsteadOfNot = SR$$$derefInsteadOfNot;
exports.SR$$$buildUnexpectedTypeArgs$$Z18115A39 = SR$$$buildUnexpectedTypeArgs$$Z18115A39;
exports.SR$$$returnUsedInsteadOfReturnBang = SR$$$returnUsedInsteadOfReturnBang;
exports.SR$$$yieldUsedInsteadOfYieldBang = SR$$$yieldUsedInsteadOfYieldBang;
exports.SR$$$tupleRequiredInAbstractMethod = SR$$$tupleRequiredInAbstractMethod;
exports.SR$$$buildInvalidWarningNumber$$Z721C83C5 = SR$$$buildInvalidWarningNumber$$Z721C83C5;
exports.SR$$$buildInvalidVersionString$$Z721C83C5 = SR$$$buildInvalidVersionString$$Z721C83C5;
exports.SR$$$buildInvalidVersionFile$$Z721C83C5 = SR$$$buildInvalidVersionFile$$Z721C83C5;
exports.SR$$$buildProductName$$Z721C83C5 = SR$$$buildProductName$$Z721C83C5;
exports.SR$$$buildProductNameCommunity$$Z721C83C5 = SR$$$buildProductNameCommunity$$Z721C83C5;
exports.SR$$$buildProblemWithFilename$$Z384F8060 = SR$$$buildProblemWithFilename$$Z384F8060;
exports.SR$$$buildNoInputsSpecified = SR$$$buildNoInputsSpecified;
exports.SR$$$buildPdbRequiresDebug = SR$$$buildPdbRequiresDebug;
exports.SR$$$buildInvalidSearchDirectory$$Z721C83C5 = SR$$$buildInvalidSearchDirectory$$Z721C83C5;
exports.SR$$$buildSearchDirectoryNotFound$$Z721C83C5 = SR$$$buildSearchDirectoryNotFound$$Z721C83C5;
exports.SR$$$buildInvalidFilename$$Z721C83C5 = SR$$$buildInvalidFilename$$Z721C83C5;
exports.SR$$$buildInvalidAssemblyName$$Z721C83C5 = SR$$$buildInvalidAssemblyName$$Z721C83C5;
exports.SR$$$buildInvalidPrivacy$$Z721C83C5 = SR$$$buildInvalidPrivacy$$Z721C83C5;
exports.SR$$$buildMultipleReferencesNotAllowed$$Z721C83C5 = SR$$$buildMultipleReferencesNotAllowed$$Z721C83C5;
exports.SR$$$buildCouldNotReadVersionInfoFromMscorlib = SR$$$buildCouldNotReadVersionInfoFromMscorlib;
exports.SR$$$buildCannotReadAssembly$$Z721C83C5 = SR$$$buildCannotReadAssembly$$Z721C83C5;
exports.SR$$$buildAssemblyResolutionFailed = SR$$$buildAssemblyResolutionFailed;
exports.SR$$$buildImplicitModuleIsNotLegalIdentifier$$Z384F8060 = SR$$$buildImplicitModuleIsNotLegalIdentifier$$Z384F8060;
exports.SR$$$buildMultiFileRequiresNamespaceOrModule = SR$$$buildMultiFileRequiresNamespaceOrModule;
exports.SR$$$noEqualSignAfterModule = SR$$$noEqualSignAfterModule;
exports.SR$$$buildMultipleToplevelModules = SR$$$buildMultipleToplevelModules;
exports.SR$$$buildOptionRequiresParameter$$Z721C83C5 = SR$$$buildOptionRequiresParameter$$Z721C83C5;
exports.SR$$$buildCouldNotFindSourceFile$$Z721C83C5 = SR$$$buildCouldNotFindSourceFile$$Z721C83C5;
exports.SR$$$buildInvalidSourceFileExtension$$Z721C83C5 = SR$$$buildInvalidSourceFileExtension$$Z721C83C5;
exports.SR$$$buildCouldNotResolveAssembly$$Z721C83C5 = SR$$$buildCouldNotResolveAssembly$$Z721C83C5;
exports.SR$$$buildCouldNotResolveAssemblyRequiredByFile$$Z384F8060 = SR$$$buildCouldNotResolveAssemblyRequiredByFile$$Z384F8060;
exports.SR$$$buildErrorOpeningBinaryFile$$Z384F8060 = SR$$$buildErrorOpeningBinaryFile$$Z384F8060;
exports.SR$$$buildDifferentVersionMustRecompile$$Z721C83C5 = SR$$$buildDifferentVersionMustRecompile$$Z721C83C5;
exports.SR$$$buildInvalidHashIDirective = SR$$$buildInvalidHashIDirective;
exports.SR$$$buildInvalidHashrDirective = SR$$$buildInvalidHashrDirective;
exports.SR$$$buildInvalidHashloadDirective = SR$$$buildInvalidHashloadDirective;
exports.SR$$$buildInvalidHashtimeDirective = SR$$$buildInvalidHashtimeDirective;
exports.SR$$$buildDirectivesInModulesAreIgnored = SR$$$buildDirectivesInModulesAreIgnored;
exports.SR$$$buildSignatureAlreadySpecified$$Z721C83C5 = SR$$$buildSignatureAlreadySpecified$$Z721C83C5;
exports.SR$$$buildImplementationAlreadyGivenDetail$$Z721C83C5 = SR$$$buildImplementationAlreadyGivenDetail$$Z721C83C5;
exports.SR$$$buildImplementationAlreadyGiven$$Z721C83C5 = SR$$$buildImplementationAlreadyGiven$$Z721C83C5;
exports.SR$$$buildSignatureWithoutImplementation$$Z721C83C5 = SR$$$buildSignatureWithoutImplementation$$Z721C83C5;
exports.SR$$$buildArgInvalidInt$$Z721C83C5 = SR$$$buildArgInvalidInt$$Z721C83C5;
exports.SR$$$buildArgInvalidFloat$$Z721C83C5 = SR$$$buildArgInvalidFloat$$Z721C83C5;
exports.SR$$$buildUnrecognizedOption$$Z721C83C5 = SR$$$buildUnrecognizedOption$$Z721C83C5;
exports.SR$$$buildInvalidModuleOrNamespaceName = SR$$$buildInvalidModuleOrNamespaceName;
exports.SR$$$pickleErrorReadingWritingMetadata$$Z384F8060 = SR$$$pickleErrorReadingWritingMetadata$$Z384F8060;
exports.SR$$$tastTypeOrModuleNotConcrete$$Z721C83C5 = SR$$$tastTypeOrModuleNotConcrete$$Z721C83C5;
exports.SR$$$tastTypeHasAssemblyCodeRepresentation$$Z721C83C5 = SR$$$tastTypeHasAssemblyCodeRepresentation$$Z721C83C5;
exports.SR$$$tastNamespaceAndModuleWithSameNameInAssembly$$Z721C83C5 = SR$$$tastNamespaceAndModuleWithSameNameInAssembly$$Z721C83C5;
exports.SR$$$tastTwoModulesWithSameNameInAssembly$$Z721C83C5 = SR$$$tastTwoModulesWithSameNameInAssembly$$Z721C83C5;
exports.SR$$$tastDuplicateTypeDefinitionInAssembly$$Z384F8060 = SR$$$tastDuplicateTypeDefinitionInAssembly$$Z384F8060;
exports.SR$$$tastConflictingModuleAndTypeDefinitionInAssembly$$Z384F8060 = SR$$$tastConflictingModuleAndTypeDefinitionInAssembly$$Z384F8060;
exports.SR$$$tastInvalidMemberSignature = SR$$$tastInvalidMemberSignature;
exports.SR$$$tastValueDoesNotHaveSetterType = SR$$$tastValueDoesNotHaveSetterType;
exports.SR$$$tastInvalidFormForPropertyGetter = SR$$$tastInvalidFormForPropertyGetter;
exports.SR$$$tastInvalidFormForPropertySetter = SR$$$tastInvalidFormForPropertySetter;
exports.SR$$$tastUnexpectedByRef = SR$$$tastUnexpectedByRef;
exports.SR$$$tastValueMustBeMutable = SR$$$tastValueMustBeMutable;
exports.SR$$$tastInvalidMutationOfConstant = SR$$$tastInvalidMutationOfConstant;
exports.SR$$$tastValueHasBeenCopied = SR$$$tastValueHasBeenCopied;
exports.SR$$$tastRecursiveValuesMayNotBeInConstructionOfTuple = SR$$$tastRecursiveValuesMayNotBeInConstructionOfTuple;
exports.SR$$$tastRecursiveValuesMayNotAppearInConstructionOfType$$Z721C83C5 = SR$$$tastRecursiveValuesMayNotAppearInConstructionOfType$$Z721C83C5;
exports.SR$$$tastRecursiveValuesMayNotBeAssignedToNonMutableField$$Z384F8060 = SR$$$tastRecursiveValuesMayNotBeAssignedToNonMutableField$$Z384F8060;
exports.SR$$$tastUnexpectedDecodeOfAutoOpenAttribute = SR$$$tastUnexpectedDecodeOfAutoOpenAttribute;
exports.SR$$$tastUnexpectedDecodeOfInternalsVisibleToAttribute = SR$$$tastUnexpectedDecodeOfInternalsVisibleToAttribute;
exports.SR$$$tastUnexpectedDecodeOfInterfaceDataVersionAttribute = SR$$$tastUnexpectedDecodeOfInterfaceDataVersionAttribute;
exports.SR$$$tastActivePatternsLimitedToSeven = SR$$$tastActivePatternsLimitedToSeven;
exports.SR$$$tastNotAConstantExpression = SR$$$tastNotAConstantExpression;
exports.SR$$$ValueNotContainedMutabilityAttributesDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityAttributesDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityNamesDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityNamesDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityCompiledNamesDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityCompiledNamesDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityDisplayNamesDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityDisplayNamesDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityAccessibilityMore$$30230F9B = SR$$$ValueNotContainedMutabilityAccessibilityMore$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityInlineFlagsDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityInlineFlagsDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityLiteralConstantValuesDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityLiteralConstantValuesDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityOneIsTypeFunction$$30230F9B = SR$$$ValueNotContainedMutabilityOneIsTypeFunction$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityParameterCountsDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityParameterCountsDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityTypesDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityTypesDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityExtensionsDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityExtensionsDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityArityNotInferred$$30230F9B = SR$$$ValueNotContainedMutabilityArityNotInferred$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityGenericParametersDiffer$$6BD52AFB = SR$$$ValueNotContainedMutabilityGenericParametersDiffer$$6BD52AFB;
exports.SR$$$ValueNotContainedMutabilityGenericParametersAreDifferentKinds$$30230F9B = SR$$$ValueNotContainedMutabilityGenericParametersAreDifferentKinds$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityAritiesDiffer$$533BBE5B = SR$$$ValueNotContainedMutabilityAritiesDiffer$$533BBE5B;
exports.SR$$$ValueNotContainedMutabilityDotNetNamesDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityDotNetNamesDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityStaticsDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityStaticsDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityVirtualsDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityVirtualsDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityAbstractsDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityAbstractsDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityFinalsDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityFinalsDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityOverridesDiffer$$30230F9B = SR$$$ValueNotContainedMutabilityOverridesDiffer$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityOneIsConstructor$$30230F9B = SR$$$ValueNotContainedMutabilityOneIsConstructor$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityStaticButInstance$$30230F9B = SR$$$ValueNotContainedMutabilityStaticButInstance$$30230F9B;
exports.SR$$$ValueNotContainedMutabilityInstanceButStatic$$30230F9B = SR$$$ValueNotContainedMutabilityInstanceButStatic$$30230F9B;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleNamesDiffer$$30230F9B = SR$$$DefinitionsInSigAndImplNotCompatibleNamesDiffer$$30230F9B;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleMissingInterface$$30230F9B = SR$$$DefinitionsInSigAndImplNotCompatibleMissingInterface$$30230F9B;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleImplementationSaysNull$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleImplementationSaysNull$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleSignatureSaysNull$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleSignatureSaysNull$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleImplementationSealed$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleImplementationSealed$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleNumbersDiffer$$30230F9B = SR$$$DefinitionsInSigAndImplNotCompatibleNumbersDiffer$$30230F9B;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot$$Z46998140 = SR$$$DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot$$Z46998140;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot$$Z46998140 = SR$$$DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot$$Z46998140;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleImplDefinesStruct$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleImplDefinesStruct$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleTypeIsHidden$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleTypeIsHidden$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleILDiffer$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleILDiffer$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleFieldWasPresent$$30230F9B = SR$$$DefinitionsInSigAndImplNotCompatibleFieldWasPresent$$30230F9B;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified$$30230F9B = SR$$$DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified$$30230F9B;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig$$30230F9B = SR$$$DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig$$30230F9B;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl$$30230F9B = SR$$$DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl$$30230F9B;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig$$30230F9B = SR$$$DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig$$30230F9B;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer$$Z46998140 = SR$$$DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer$$Z46998140;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer$$Z46998140 = SR$$$DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer$$Z46998140;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig$$Z384F8060;
exports.SR$$$DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation$$Z384F8060 = SR$$$DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation$$Z384F8060;
exports.SR$$$ModuleContainsConstructorButNamesDiffer$$Z384F8060 = SR$$$ModuleContainsConstructorButNamesDiffer$$Z384F8060;
exports.SR$$$ModuleContainsConstructorButDataFieldsDiffer$$Z384F8060 = SR$$$ModuleContainsConstructorButDataFieldsDiffer$$Z384F8060;
exports.SR$$$ModuleContainsConstructorButTypesOfFieldsDiffer$$Z384F8060 = SR$$$ModuleContainsConstructorButTypesOfFieldsDiffer$$Z384F8060;
exports.SR$$$ModuleContainsConstructorButAccessibilityDiffers$$Z384F8060 = SR$$$ModuleContainsConstructorButAccessibilityDiffers$$Z384F8060;
exports.SR$$$FieldNotContainedNamesDiffer$$Z384F8060 = SR$$$FieldNotContainedNamesDiffer$$Z384F8060;
exports.SR$$$FieldNotContainedAccessibilitiesDiffer$$Z384F8060 = SR$$$FieldNotContainedAccessibilitiesDiffer$$Z384F8060;
exports.SR$$$FieldNotContainedStaticsDiffer$$Z384F8060 = SR$$$FieldNotContainedStaticsDiffer$$Z384F8060;
exports.SR$$$FieldNotContainedMutablesDiffer$$Z384F8060 = SR$$$FieldNotContainedMutablesDiffer$$Z384F8060;
exports.SR$$$FieldNotContainedLiteralsDiffer$$Z384F8060 = SR$$$FieldNotContainedLiteralsDiffer$$Z384F8060;
exports.SR$$$FieldNotContainedTypesDiffer$$Z384F8060 = SR$$$FieldNotContainedTypesDiffer$$Z384F8060;
exports.SR$$$typrelCannotResolveImplicitGenericInstantiation$$Z384F8060 = SR$$$typrelCannotResolveImplicitGenericInstantiation$$Z384F8060;
exports.SR$$$typrelCannotResolveAmbiguityInPrintf = SR$$$typrelCannotResolveAmbiguityInPrintf;
exports.SR$$$typrelCannotResolveAmbiguityInEnum = SR$$$typrelCannotResolveAmbiguityInEnum;
exports.SR$$$typrelCannotResolveAmbiguityInDelegate = SR$$$typrelCannotResolveAmbiguityInDelegate;
exports.SR$$$typrelInvalidValue = SR$$$typrelInvalidValue;
exports.SR$$$typrelSigImplNotCompatibleParamCountsDiffer = SR$$$typrelSigImplNotCompatibleParamCountsDiffer;
exports.SR$$$typrelSigImplNotCompatibleCompileTimeRequirementsDiffer = SR$$$typrelSigImplNotCompatibleCompileTimeRequirementsDiffer;
exports.SR$$$typrelSigImplNotCompatibleConstraintsDiffer$$Z384F8060 = SR$$$typrelSigImplNotCompatibleConstraintsDiffer$$Z384F8060;
exports.SR$$$typrelSigImplNotCompatibleConstraintsDifferRemove$$Z384F8060 = SR$$$typrelSigImplNotCompatibleConstraintsDifferRemove$$Z384F8060;
exports.SR$$$typrelTypeImplementsIComparableShouldOverrideObjectEquals$$Z721C83C5 = SR$$$typrelTypeImplementsIComparableShouldOverrideObjectEquals$$Z721C83C5;
exports.SR$$$typrelTypeImplementsIComparableDefaultObjectEqualsProvided$$Z721C83C5 = SR$$$typrelTypeImplementsIComparableDefaultObjectEqualsProvided$$Z721C83C5;
exports.SR$$$typrelExplicitImplementationOfGetHashCodeOrEquals$$Z721C83C5 = SR$$$typrelExplicitImplementationOfGetHashCodeOrEquals$$Z721C83C5;
exports.SR$$$typrelExplicitImplementationOfGetHashCode$$Z721C83C5 = SR$$$typrelExplicitImplementationOfGetHashCode$$Z721C83C5;
exports.SR$$$typrelExplicitImplementationOfEquals$$Z721C83C5 = SR$$$typrelExplicitImplementationOfEquals$$Z721C83C5;
exports.SR$$$ExceptionDefsNotCompatibleHiddenBySignature$$Z384F8060 = SR$$$ExceptionDefsNotCompatibleHiddenBySignature$$Z384F8060;
exports.SR$$$ExceptionDefsNotCompatibleDotNetRepresentationsDiffer$$Z384F8060 = SR$$$ExceptionDefsNotCompatibleDotNetRepresentationsDiffer$$Z384F8060;
exports.SR$$$ExceptionDefsNotCompatibleAbbreviationHiddenBySignature$$Z384F8060 = SR$$$ExceptionDefsNotCompatibleAbbreviationHiddenBySignature$$Z384F8060;
exports.SR$$$ExceptionDefsNotCompatibleSignaturesDiffer$$Z384F8060 = SR$$$ExceptionDefsNotCompatibleSignaturesDiffer$$Z384F8060;
exports.SR$$$ExceptionDefsNotCompatibleExceptionDeclarationsDiffer$$Z384F8060 = SR$$$ExceptionDefsNotCompatibleExceptionDeclarationsDiffer$$Z384F8060;
exports.SR$$$ExceptionDefsNotCompatibleFieldInSigButNotImpl$$30230F9B = SR$$$ExceptionDefsNotCompatibleFieldInSigButNotImpl$$30230F9B;
exports.SR$$$ExceptionDefsNotCompatibleFieldInImplButNotSig$$30230F9B = SR$$$ExceptionDefsNotCompatibleFieldInImplButNotSig$$30230F9B;
exports.SR$$$ExceptionDefsNotCompatibleFieldOrderDiffers$$Z384F8060 = SR$$$ExceptionDefsNotCompatibleFieldOrderDiffers$$Z384F8060;
exports.SR$$$typrelModuleNamespaceAttributesDifferInSigAndImpl = SR$$$typrelModuleNamespaceAttributesDifferInSigAndImpl;
exports.SR$$$typrelMethodIsOverconstrained = SR$$$typrelMethodIsOverconstrained;
exports.SR$$$typrelOverloadNotFound$$Z384F8060 = SR$$$typrelOverloadNotFound$$Z384F8060;
exports.SR$$$typrelOverrideWasAmbiguous$$Z721C83C5 = SR$$$typrelOverrideWasAmbiguous$$Z721C83C5;
exports.SR$$$typrelMoreThenOneOverride$$Z721C83C5 = SR$$$typrelMoreThenOneOverride$$Z721C83C5;
exports.SR$$$typrelMethodIsSealed$$Z721C83C5 = SR$$$typrelMethodIsSealed$$Z721C83C5;
exports.SR$$$typrelOverrideImplementsMoreThenOneSlot$$30230F9B = SR$$$typrelOverrideImplementsMoreThenOneSlot$$30230F9B;
exports.SR$$$typrelDuplicateInterface = SR$$$typrelDuplicateInterface;
exports.SR$$$typrelNeedExplicitImplementation$$Z721C83C5 = SR$$$typrelNeedExplicitImplementation$$Z721C83C5;
exports.SR$$$typrelNamedArgumentHasBeenAssignedMoreThenOnce = SR$$$typrelNamedArgumentHasBeenAssignedMoreThenOnce;
exports.SR$$$typrelNoImplementationGiven$$Z721C83C5 = SR$$$typrelNoImplementationGiven$$Z721C83C5;
exports.SR$$$typrelNoImplementationGivenWithSuggestion$$Z721C83C5 = SR$$$typrelNoImplementationGivenWithSuggestion$$Z721C83C5;
exports.SR$$$typrelMemberDoesNotHaveCorrectNumberOfArguments$$Z384F8060 = SR$$$typrelMemberDoesNotHaveCorrectNumberOfArguments$$Z384F8060;
exports.SR$$$typrelMemberDoesNotHaveCorrectNumberOfTypeParameters$$Z384F8060 = SR$$$typrelMemberDoesNotHaveCorrectNumberOfTypeParameters$$Z384F8060;
exports.SR$$$typrelMemberDoesNotHaveCorrectKindsOfGenericParameters$$Z384F8060 = SR$$$typrelMemberDoesNotHaveCorrectKindsOfGenericParameters$$Z384F8060;
exports.SR$$$typrelMemberCannotImplement$$30230F9B = SR$$$typrelMemberCannotImplement$$30230F9B;
exports.SR$$$astParseEmbeddedILError = SR$$$astParseEmbeddedILError;
exports.SR$$$astParseEmbeddedILTypeError = SR$$$astParseEmbeddedILTypeError;
exports.SR$$$astDeprecatedIndexerNotation = SR$$$astDeprecatedIndexerNotation;
exports.SR$$$astInvalidExprLeftHandOfAssignment = SR$$$astInvalidExprLeftHandOfAssignment;
exports.SR$$$augNoRefEqualsOnStruct = SR$$$augNoRefEqualsOnStruct;
exports.SR$$$augInvalidAttrs = SR$$$augInvalidAttrs;
exports.SR$$$augNoEqualityNeedsNoComparison = SR$$$augNoEqualityNeedsNoComparison;
exports.SR$$$augStructCompNeedsStructEquality = SR$$$augStructCompNeedsStructEquality;
exports.SR$$$augStructEqNeedsNoCompOrStructComp = SR$$$augStructEqNeedsNoCompOrStructComp;
exports.SR$$$augTypeCantHaveRefEqAndStructAttrs = SR$$$augTypeCantHaveRefEqAndStructAttrs;
exports.SR$$$augOnlyCertainTypesCanHaveAttrs = SR$$$augOnlyCertainTypesCanHaveAttrs;
exports.SR$$$augRefEqCantHaveObjEquals = SR$$$augRefEqCantHaveObjEquals;
exports.SR$$$augCustomEqNeedsObjEquals = SR$$$augCustomEqNeedsObjEquals;
exports.SR$$$augCustomCompareNeedsIComp = SR$$$augCustomCompareNeedsIComp;
exports.SR$$$augNoEqNeedsNoObjEquals = SR$$$augNoEqNeedsNoObjEquals;
exports.SR$$$augNoCompCantImpIComp = SR$$$augNoCompCantImpIComp;
exports.SR$$$augCustomEqNeedsNoCompOrCustomComp = SR$$$augCustomEqNeedsNoCompOrCustomComp;
exports.SR$$$forPositionalSpecifiersNotPermitted = SR$$$forPositionalSpecifiersNotPermitted;
exports.SR$$$forMissingFormatSpecifier = SR$$$forMissingFormatSpecifier;
exports.SR$$$forFlagSetTwice$$Z721C83C5 = SR$$$forFlagSetTwice$$Z721C83C5;
exports.SR$$$forPrefixFlagSpacePlusSetTwice = SR$$$forPrefixFlagSpacePlusSetTwice;
exports.SR$$$forHashSpecifierIsInvalid = SR$$$forHashSpecifierIsInvalid;
exports.SR$$$forBadPrecision = SR$$$forBadPrecision;
exports.SR$$$forBadWidth = SR$$$forBadWidth;
exports.SR$$$forDoesNotSupportZeroFlag$$Z721C83C5 = SR$$$forDoesNotSupportZeroFlag$$Z721C83C5;
exports.SR$$$forPrecisionMissingAfterDot = SR$$$forPrecisionMissingAfterDot;
exports.SR$$$forFormatDoesntSupportPrecision$$Z721C83C5 = SR$$$forFormatDoesntSupportPrecision$$Z721C83C5;
exports.SR$$$forBadFormatSpecifier = SR$$$forBadFormatSpecifier;
exports.SR$$$forLIsUnnecessary = SR$$$forLIsUnnecessary;
exports.SR$$$forHIsUnnecessary = SR$$$forHIsUnnecessary;
exports.SR$$$forDoesNotSupportPrefixFlag$$Z384F8060 = SR$$$forDoesNotSupportPrefixFlag$$Z384F8060;
exports.SR$$$forBadFormatSpecifierGeneral$$Z721C83C5 = SR$$$forBadFormatSpecifierGeneral$$Z721C83C5;
exports.SR$$$elSysEnvExitDidntExit = SR$$$elSysEnvExitDidntExit;
exports.SR$$$elDeprecatedOperator = SR$$$elDeprecatedOperator;
exports.SR$$$chkProtectedOrBaseCalled = SR$$$chkProtectedOrBaseCalled;
exports.SR$$$chkByrefUsedInInvalidWay$$Z721C83C5 = SR$$$chkByrefUsedInInvalidWay$$Z721C83C5;
exports.SR$$$chkBaseUsedInInvalidWay = SR$$$chkBaseUsedInInvalidWay;
exports.SR$$$chkVariableUsedInInvalidWay$$Z721C83C5 = SR$$$chkVariableUsedInInvalidWay$$Z721C83C5;
exports.SR$$$chkTypeLessAccessibleThanType$$Z384F8060 = SR$$$chkTypeLessAccessibleThanType$$Z384F8060;
exports.SR$$$chkSystemVoidOnlyInTypeof = SR$$$chkSystemVoidOnlyInTypeof;
exports.SR$$$chkErrorUseOfByref = SR$$$chkErrorUseOfByref;
exports.SR$$$chkErrorContainsCallToRethrow = SR$$$chkErrorContainsCallToRethrow;
exports.SR$$$chkSplicingOnlyInQuotations = SR$$$chkSplicingOnlyInQuotations;
exports.SR$$$chkNoFirstClassSplicing = SR$$$chkNoFirstClassSplicing;
exports.SR$$$chkNoFirstClassAddressOf = SR$$$chkNoFirstClassAddressOf;
exports.SR$$$chkNoFirstClassRethrow = SR$$$chkNoFirstClassRethrow;
exports.SR$$$chkNoByrefAtThisPoint$$Z721C83C5 = SR$$$chkNoByrefAtThisPoint$$Z721C83C5;
exports.SR$$$chkLimitationsOfBaseKeyword = SR$$$chkLimitationsOfBaseKeyword;
exports.SR$$$chkObjCtorsCantUseExceptionHandling = SR$$$chkObjCtorsCantUseExceptionHandling;
exports.SR$$$chkNoAddressOfAtThisPoint$$Z721C83C5 = SR$$$chkNoAddressOfAtThisPoint$$Z721C83C5;
exports.SR$$$chkNoAddressStaticFieldAtThisPoint$$Z721C83C5 = SR$$$chkNoAddressStaticFieldAtThisPoint$$Z721C83C5;
exports.SR$$$chkNoAddressFieldAtThisPoint$$Z721C83C5 = SR$$$chkNoAddressFieldAtThisPoint$$Z721C83C5;
exports.SR$$$chkNoAddressOfArrayElementAtThisPoint = SR$$$chkNoAddressOfArrayElementAtThisPoint;
exports.SR$$$chkFirstClassFuncNoByref = SR$$$chkFirstClassFuncNoByref;
exports.SR$$$chkReturnTypeNoByref = SR$$$chkReturnTypeNoByref;
exports.SR$$$chkInvalidCustAttrVal = SR$$$chkInvalidCustAttrVal;
exports.SR$$$chkAttrHasAllowMultiFalse$$Z721C83C5 = SR$$$chkAttrHasAllowMultiFalse$$Z721C83C5;
exports.SR$$$chkMemberUsedInInvalidWay$$30230F9B = SR$$$chkMemberUsedInInvalidWay$$30230F9B;
exports.SR$$$chkNoByrefAsTopValue = SR$$$chkNoByrefAsTopValue;
exports.SR$$$chkReflectedDefCantSplice = SR$$$chkReflectedDefCantSplice;
exports.SR$$$chkEntryPointUsage = SR$$$chkEntryPointUsage;
exports.SR$$$chkUnionCaseCompiledForm = SR$$$chkUnionCaseCompiledForm;
exports.SR$$$chkUnionCaseDefaultAugmentation = SR$$$chkUnionCaseDefaultAugmentation;
exports.SR$$$chkPropertySameNameMethod$$Z384F8060 = SR$$$chkPropertySameNameMethod$$Z384F8060;
exports.SR$$$chkGetterSetterDoNotMatchAbstract$$Z384F8060 = SR$$$chkGetterSetterDoNotMatchAbstract$$Z384F8060;
exports.SR$$$chkPropertySameNameIndexer$$Z384F8060 = SR$$$chkPropertySameNameIndexer$$Z384F8060;
exports.SR$$$chkCantStoreByrefValue = SR$$$chkCantStoreByrefValue;
exports.SR$$$chkDuplicateMethod$$Z384F8060 = SR$$$chkDuplicateMethod$$Z384F8060;
exports.SR$$$chkDuplicateMethodWithSuffix$$Z384F8060 = SR$$$chkDuplicateMethodWithSuffix$$Z384F8060;
exports.SR$$$chkDuplicateMethodCurried$$Z384F8060 = SR$$$chkDuplicateMethodCurried$$Z384F8060;
exports.SR$$$chkCurriedMethodsCantHaveOutParams = SR$$$chkCurriedMethodsCantHaveOutParams;
exports.SR$$$chkDuplicateProperty$$Z384F8060 = SR$$$chkDuplicateProperty$$Z384F8060;
exports.SR$$$chkDuplicatePropertyWithSuffix$$Z384F8060 = SR$$$chkDuplicatePropertyWithSuffix$$Z384F8060;
exports.SR$$$chkDuplicateMethodInheritedType$$Z721C83C5 = SR$$$chkDuplicateMethodInheritedType$$Z721C83C5;
exports.SR$$$chkDuplicateMethodInheritedTypeWithSuffix$$Z721C83C5 = SR$$$chkDuplicateMethodInheritedTypeWithSuffix$$Z721C83C5;
exports.SR$$$chkMultipleGenericInterfaceInstantiations$$Z384F8060 = SR$$$chkMultipleGenericInterfaceInstantiations$$Z384F8060;
exports.SR$$$chkValueWithDefaultValueMustHaveDefaultValue = SR$$$chkValueWithDefaultValueMustHaveDefaultValue;
exports.SR$$$chkNoByrefInTypeAbbrev = SR$$$chkNoByrefInTypeAbbrev;
exports.SR$$$crefBoundVarUsedInSplice$$Z721C83C5 = SR$$$crefBoundVarUsedInSplice$$Z721C83C5;
exports.SR$$$crefQuotationsCantContainGenericExprs = SR$$$crefQuotationsCantContainGenericExprs;
exports.SR$$$crefQuotationsCantContainGenericFunctions = SR$$$crefQuotationsCantContainGenericFunctions;
exports.SR$$$crefQuotationsCantContainObjExprs = SR$$$crefQuotationsCantContainObjExprs;
exports.SR$$$crefQuotationsCantContainAddressOf = SR$$$crefQuotationsCantContainAddressOf;
exports.SR$$$crefQuotationsCantContainStaticFieldRef = SR$$$crefQuotationsCantContainStaticFieldRef;
exports.SR$$$crefQuotationsCantContainInlineIL = SR$$$crefQuotationsCantContainInlineIL;
exports.SR$$$crefQuotationsCantContainDescendingForLoops = SR$$$crefQuotationsCantContainDescendingForLoops;
exports.SR$$$crefQuotationsCantFetchUnionIndexes = SR$$$crefQuotationsCantFetchUnionIndexes;
exports.SR$$$crefQuotationsCantSetUnionFields = SR$$$crefQuotationsCantSetUnionFields;
exports.SR$$$crefQuotationsCantSetExceptionFields = SR$$$crefQuotationsCantSetExceptionFields;
exports.SR$$$crefQuotationsCantRequireByref = SR$$$crefQuotationsCantRequireByref;
exports.SR$$$crefQuotationsCantCallTraitMembers = SR$$$crefQuotationsCantCallTraitMembers;
exports.SR$$$crefQuotationsCantContainThisConstant = SR$$$crefQuotationsCantContainThisConstant;
exports.SR$$$crefQuotationsCantContainThisPatternMatch = SR$$$crefQuotationsCantContainThisPatternMatch;
exports.SR$$$crefQuotationsCantContainArrayPatternMatching = SR$$$crefQuotationsCantContainArrayPatternMatching;
exports.SR$$$crefQuotationsCantContainThisType = SR$$$crefQuotationsCantContainThisType;
exports.SR$$$csTypeCannotBeResolvedAtCompileTime$$Z721C83C5 = SR$$$csTypeCannotBeResolvedAtCompileTime$$Z721C83C5;
exports.SR$$$csCodeLessGeneric = SR$$$csCodeLessGeneric;
exports.SR$$$csTypeInferenceMaxDepth = SR$$$csTypeInferenceMaxDepth;
exports.SR$$$csExpectedArguments = SR$$$csExpectedArguments;
exports.SR$$$csIndexArgumentMismatch$$Z37302880 = SR$$$csIndexArgumentMismatch$$Z37302880;
exports.SR$$$csExpectTypeWithOperatorButGivenFunction$$Z721C83C5 = SR$$$csExpectTypeWithOperatorButGivenFunction$$Z721C83C5;
exports.SR$$$csExpectTypeWithOperatorButGivenTuple$$Z721C83C5 = SR$$$csExpectTypeWithOperatorButGivenTuple$$Z721C83C5;
exports.SR$$$csTypesDoNotSupportOperator$$Z384F8060 = SR$$$csTypesDoNotSupportOperator$$Z384F8060;
exports.SR$$$csTypeDoesNotSupportOperator$$Z384F8060 = SR$$$csTypeDoesNotSupportOperator$$Z384F8060;
exports.SR$$$csTypesDoNotSupportOperatorNullable$$Z384F8060 = SR$$$csTypesDoNotSupportOperatorNullable$$Z384F8060;
exports.SR$$$csTypeDoesNotSupportOperatorNullable$$Z384F8060 = SR$$$csTypeDoesNotSupportOperatorNullable$$Z384F8060;
exports.SR$$$csTypeDoesNotSupportConversion$$Z384F8060 = SR$$$csTypeDoesNotSupportConversion$$Z384F8060;
exports.SR$$$csMethodFoundButIsStatic$$30230F9B = SR$$$csMethodFoundButIsStatic$$30230F9B;
exports.SR$$$csMethodFoundButIsNotStatic$$30230F9B = SR$$$csMethodFoundButIsNotStatic$$30230F9B;
exports.SR$$$csStructConstraintInconsistent = SR$$$csStructConstraintInconsistent;
exports.SR$$$csTypeDoesNotHaveNull$$Z721C83C5 = SR$$$csTypeDoesNotHaveNull$$Z721C83C5;
exports.SR$$$csNullableTypeDoesNotHaveNull$$Z721C83C5 = SR$$$csNullableTypeDoesNotHaveNull$$Z721C83C5;
exports.SR$$$csTypeDoesNotSupportComparison1$$Z721C83C5 = SR$$$csTypeDoesNotSupportComparison1$$Z721C83C5;
exports.SR$$$csTypeDoesNotSupportComparison2$$Z721C83C5 = SR$$$csTypeDoesNotSupportComparison2$$Z721C83C5;
exports.SR$$$csTypeDoesNotSupportComparison3$$Z721C83C5 = SR$$$csTypeDoesNotSupportComparison3$$Z721C83C5;
exports.SR$$$csTypeDoesNotSupportEquality1$$Z721C83C5 = SR$$$csTypeDoesNotSupportEquality1$$Z721C83C5;
exports.SR$$$csTypeDoesNotSupportEquality2$$Z721C83C5 = SR$$$csTypeDoesNotSupportEquality2$$Z721C83C5;
exports.SR$$$csTypeDoesNotSupportEquality3$$Z721C83C5 = SR$$$csTypeDoesNotSupportEquality3$$Z721C83C5;
exports.SR$$$csTypeIsNotEnumType$$Z721C83C5 = SR$$$csTypeIsNotEnumType$$Z721C83C5;
exports.SR$$$csTypeHasNonStandardDelegateType$$Z721C83C5 = SR$$$csTypeHasNonStandardDelegateType$$Z721C83C5;
exports.SR$$$csTypeIsNotDelegateType$$Z721C83C5 = SR$$$csTypeIsNotDelegateType$$Z721C83C5;
exports.SR$$$csTypeParameterCannotBeNullable = SR$$$csTypeParameterCannotBeNullable;
exports.SR$$$csGenericConstructRequiresStructType$$Z721C83C5 = SR$$$csGenericConstructRequiresStructType$$Z721C83C5;
exports.SR$$$csGenericConstructRequiresUnmanagedType$$Z721C83C5 = SR$$$csGenericConstructRequiresUnmanagedType$$Z721C83C5;
exports.SR$$$csTypeNotCompatibleBecauseOfPrintf$$Z384F8060 = SR$$$csTypeNotCompatibleBecauseOfPrintf$$Z384F8060;
exports.SR$$$csGenericConstructRequiresReferenceSemantics$$Z721C83C5 = SR$$$csGenericConstructRequiresReferenceSemantics$$Z721C83C5;
exports.SR$$$csGenericConstructRequiresNonAbstract$$Z721C83C5 = SR$$$csGenericConstructRequiresNonAbstract$$Z721C83C5;
exports.SR$$$csGenericConstructRequiresPublicDefaultConstructor$$Z721C83C5 = SR$$$csGenericConstructRequiresPublicDefaultConstructor$$Z721C83C5;
exports.SR$$$csTypeInstantiationLengthMismatch = SR$$$csTypeInstantiationLengthMismatch;
exports.SR$$$csOptionalArgumentNotPermittedHere = SR$$$csOptionalArgumentNotPermittedHere;
exports.SR$$$csMemberIsNotStatic$$Z721C83C5 = SR$$$csMemberIsNotStatic$$Z721C83C5;
exports.SR$$$csMemberIsNotInstance$$Z721C83C5 = SR$$$csMemberIsNotInstance$$Z721C83C5;
exports.SR$$$csArgumentLengthMismatch = SR$$$csArgumentLengthMismatch;
exports.SR$$$csArgumentTypesDoNotMatch = SR$$$csArgumentTypesDoNotMatch;
exports.SR$$$csMethodExpectsParams = SR$$$csMethodExpectsParams;
exports.SR$$$csMemberIsNotAccessible$$Z384F8060 = SR$$$csMemberIsNotAccessible$$Z384F8060;
exports.SR$$$csMemberIsNotAccessible2$$Z384F8060 = SR$$$csMemberIsNotAccessible2$$Z384F8060;
exports.SR$$$csMethodIsNotAStaticMethod$$Z721C83C5 = SR$$$csMethodIsNotAStaticMethod$$Z721C83C5;
exports.SR$$$csMethodIsNotAnInstanceMethod$$Z721C83C5 = SR$$$csMethodIsNotAnInstanceMethod$$Z721C83C5;
exports.SR$$$csMemberHasNoArgumentOrReturnProperty$$30230F9B = SR$$$csMemberHasNoArgumentOrReturnProperty$$30230F9B;
exports.SR$$$csCtorHasNoArgumentOrReturnProperty$$30230F9B = SR$$$csCtorHasNoArgumentOrReturnProperty$$30230F9B;
exports.SR$$$csRequiredSignatureIs$$Z721C83C5 = SR$$$csRequiredSignatureIs$$Z721C83C5;
exports.SR$$$csMemberSignatureMismatch$$6820229C = SR$$$csMemberSignatureMismatch$$6820229C;
exports.SR$$$csMemberSignatureMismatch2$$6820229C = SR$$$csMemberSignatureMismatch2$$6820229C;
exports.SR$$$csMemberSignatureMismatch3$$Z1E38F5D9 = SR$$$csMemberSignatureMismatch3$$Z1E38F5D9;
exports.SR$$$csMemberSignatureMismatch4$$Z1E38F5D9 = SR$$$csMemberSignatureMismatch4$$Z1E38F5D9;
exports.SR$$$csMemberSignatureMismatchArityNamed$$3FB802DC = SR$$$csMemberSignatureMismatchArityNamed$$3FB802DC;
exports.SR$$$csMemberSignatureMismatchArity$$Z2A429BA0 = SR$$$csMemberSignatureMismatchArity$$Z2A429BA0;
exports.SR$$$csCtorSignatureMismatchArity$$Z2A429BA0 = SR$$$csCtorSignatureMismatchArity$$Z2A429BA0;
exports.SR$$$csCtorSignatureMismatchArityProp$$Z2A429BA0 = SR$$$csCtorSignatureMismatchArityProp$$Z2A429BA0;
exports.SR$$$csMemberSignatureMismatchArityType$$Z2A429BA0 = SR$$$csMemberSignatureMismatchArityType$$Z2A429BA0;
exports.SR$$$csMemberNotAccessible$$Z3E662FC0 = SR$$$csMemberNotAccessible$$Z3E662FC0;
exports.SR$$$csIncorrectGenericInstantiation$$107DD5FC = SR$$$csIncorrectGenericInstantiation$$107DD5FC;
exports.SR$$$csMemberOverloadArityMismatch$$487EF8FB = SR$$$csMemberOverloadArityMismatch$$487EF8FB;
exports.SR$$$csNoMemberTakesTheseArguments$$107DD5FC = SR$$$csNoMemberTakesTheseArguments$$107DD5FC;
exports.SR$$$csNoMemberTakesTheseArguments2$$Z727ACCE0 = SR$$$csNoMemberTakesTheseArguments2$$Z727ACCE0;
exports.SR$$$csNoMemberTakesTheseArguments3$$Z522416B9 = SR$$$csNoMemberTakesTheseArguments3$$Z522416B9;
exports.SR$$$csMethodNotFound$$Z721C83C5 = SR$$$csMethodNotFound$$Z721C83C5;
exports.SR$$$csNoOverloadsFound$$Z721C83C5 = SR$$$csNoOverloadsFound$$Z721C83C5;
exports.SR$$$csMethodIsOverloaded$$Z721C83C5 = SR$$$csMethodIsOverloaded$$Z721C83C5;
exports.SR$$$csCandidates$$Z721C83C5 = SR$$$csCandidates$$Z721C83C5;
exports.SR$$$csSeeAvailableOverloads = SR$$$csSeeAvailableOverloads;
exports.SR$$$parsDoCannotHaveVisibilityDeclarations$$Z721C83C5 = SR$$$parsDoCannotHaveVisibilityDeclarations$$Z721C83C5;
exports.SR$$$parsEofInHashIf = SR$$$parsEofInHashIf;
exports.SR$$$parsEofInString = SR$$$parsEofInString;
exports.SR$$$parsEofInVerbatimString = SR$$$parsEofInVerbatimString;
exports.SR$$$parsEofInComment = SR$$$parsEofInComment;
exports.SR$$$parsEofInStringInComment = SR$$$parsEofInStringInComment;
exports.SR$$$parsEofInVerbatimStringInComment = SR$$$parsEofInVerbatimStringInComment;
exports.SR$$$parsEofInIfOcaml = SR$$$parsEofInIfOcaml;
exports.SR$$$parsEofInDirective = SR$$$parsEofInDirective;
exports.SR$$$parsNoHashEndIfFound = SR$$$parsNoHashEndIfFound;
exports.SR$$$parsAttributesIgnored = SR$$$parsAttributesIgnored;
exports.SR$$$parsUseBindingsIllegalInImplicitClassConstructors = SR$$$parsUseBindingsIllegalInImplicitClassConstructors;
exports.SR$$$parsUseBindingsIllegalInModules = SR$$$parsUseBindingsIllegalInModules;
exports.SR$$$parsIntegerForLoopRequiresSimpleIdentifier = SR$$$parsIntegerForLoopRequiresSimpleIdentifier;
exports.SR$$$parsOnlyOneWithAugmentationAllowed = SR$$$parsOnlyOneWithAugmentationAllowed;
exports.SR$$$parsUnexpectedSemicolon = SR$$$parsUnexpectedSemicolon;
exports.SR$$$parsUnexpectedEndOfFile = SR$$$parsUnexpectedEndOfFile;
exports.SR$$$parsUnexpectedVisibilityDeclaration$$Z721C83C5 = SR$$$parsUnexpectedVisibilityDeclaration$$Z721C83C5;
exports.SR$$$parsOnlyHashDirectivesAllowed = SR$$$parsOnlyHashDirectivesAllowed;
exports.SR$$$parsVisibilityDeclarationsShouldComePriorToIdentifier = SR$$$parsVisibilityDeclarationsShouldComePriorToIdentifier;
exports.SR$$$parsNamespaceOrModuleNotBoth = SR$$$parsNamespaceOrModuleNotBoth;
exports.SR$$$parsModuleAbbreviationMustBeSimpleName = SR$$$parsModuleAbbreviationMustBeSimpleName;
exports.SR$$$parsIgnoreAttributesOnModuleAbbreviation = SR$$$parsIgnoreAttributesOnModuleAbbreviation;
exports.SR$$$parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate$$Z721C83C5 = SR$$$parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate$$Z721C83C5;
exports.SR$$$parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate$$Z721C83C5 = SR$$$parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate$$Z721C83C5;
exports.SR$$$parsUnClosedBlockInHashLight = SR$$$parsUnClosedBlockInHashLight;
exports.SR$$$parsUnmatchedBeginOrStruct = SR$$$parsUnmatchedBeginOrStruct;
exports.SR$$$parsModuleDefnMustBeSimpleName = SR$$$parsModuleDefnMustBeSimpleName;
exports.SR$$$parsUnexpectedEmptyModuleDefn = SR$$$parsUnexpectedEmptyModuleDefn;
exports.SR$$$parsAttributesMustComeBeforeVal = SR$$$parsAttributesMustComeBeforeVal;
exports.SR$$$parsAttributesAreNotPermittedOnInterfaceImplementations = SR$$$parsAttributesAreNotPermittedOnInterfaceImplementations;
exports.SR$$$parsSyntaxError = SR$$$parsSyntaxError;
exports.SR$$$parsAugmentationsIllegalOnDelegateType = SR$$$parsAugmentationsIllegalOnDelegateType;
exports.SR$$$parsUnmatchedClassInterfaceOrStruct = SR$$$parsUnmatchedClassInterfaceOrStruct;
exports.SR$$$parsEmptyTypeDefinition = SR$$$parsEmptyTypeDefinition;
exports.SR$$$parsUnmatchedWith = SR$$$parsUnmatchedWith;
exports.SR$$$parsGetOrSetRequired = SR$$$parsGetOrSetRequired;
exports.SR$$$parsOnlyClassCanTakeValueArguments = SR$$$parsOnlyClassCanTakeValueArguments;
exports.SR$$$parsUnmatchedBegin = SR$$$parsUnmatchedBegin;
exports.SR$$$parsInvalidDeclarationSyntax = SR$$$parsInvalidDeclarationSyntax;
exports.SR$$$parsGetAndOrSetRequired = SR$$$parsGetAndOrSetRequired;
exports.SR$$$parsTypeAnnotationsOnGetSet = SR$$$parsTypeAnnotationsOnGetSet;
exports.SR$$$parsGetterMustHaveAtLeastOneArgument = SR$$$parsGetterMustHaveAtLeastOneArgument;
exports.SR$$$parsMultipleAccessibilitiesForGetSet = SR$$$parsMultipleAccessibilitiesForGetSet;
exports.SR$$$parsSetSyntax = SR$$$parsSetSyntax;
exports.SR$$$parsInterfacesHaveSameVisibilityAsEnclosingType = SR$$$parsInterfacesHaveSameVisibilityAsEnclosingType;
exports.SR$$$parsAccessibilityModsIllegalForAbstract = SR$$$parsAccessibilityModsIllegalForAbstract;
exports.SR$$$parsAttributesIllegalOnInherit = SR$$$parsAttributesIllegalOnInherit;
exports.SR$$$parsVisibilityIllegalOnInherit = SR$$$parsVisibilityIllegalOnInherit;
exports.SR$$$parsInheritDeclarationsCannotHaveAsBindings = SR$$$parsInheritDeclarationsCannotHaveAsBindings;
exports.SR$$$parsAttributesIllegalHere = SR$$$parsAttributesIllegalHere;
exports.SR$$$parsTypeAbbreviationsCannotHaveVisibilityDeclarations = SR$$$parsTypeAbbreviationsCannotHaveVisibilityDeclarations;
exports.SR$$$parsEnumTypesCannotHaveVisibilityDeclarations = SR$$$parsEnumTypesCannotHaveVisibilityDeclarations;
exports.SR$$$parsAllEnumFieldsRequireValues = SR$$$parsAllEnumFieldsRequireValues;
exports.SR$$$parsInlineAssemblyCannotHaveVisibilityDeclarations = SR$$$parsInlineAssemblyCannotHaveVisibilityDeclarations;
exports.SR$$$parsUnexpectedIdentifier$$Z721C83C5 = SR$$$parsUnexpectedIdentifier$$Z721C83C5;
exports.SR$$$parsUnionCasesCannotHaveVisibilityDeclarations = SR$$$parsUnionCasesCannotHaveVisibilityDeclarations;
exports.SR$$$parsEnumFieldsCannotHaveVisibilityDeclarations = SR$$$parsEnumFieldsCannotHaveVisibilityDeclarations;
exports.SR$$$parsConsiderUsingSeparateRecordType = SR$$$parsConsiderUsingSeparateRecordType;
exports.SR$$$parsRecordFieldsCannotHaveVisibilityDeclarations = SR$$$parsRecordFieldsCannotHaveVisibilityDeclarations;
exports.SR$$$parsLetAndForNonRecBindings = SR$$$parsLetAndForNonRecBindings;
exports.SR$$$parsUnmatchedParen = SR$$$parsUnmatchedParen;
exports.SR$$$parsSuccessivePatternsShouldBeSpacedOrTupled = SR$$$parsSuccessivePatternsShouldBeSpacedOrTupled;
exports.SR$$$parsNoMatchingInForLet = SR$$$parsNoMatchingInForLet;
exports.SR$$$parsErrorInReturnForLetIncorrectIndentation = SR$$$parsErrorInReturnForLetIncorrectIndentation;
exports.SR$$$parsExpectedExpressionAfterLet$$Z384F8060 = SR$$$parsExpectedExpressionAfterLet$$Z384F8060;
exports.SR$$$parsIncompleteIf = SR$$$parsIncompleteIf;
exports.SR$$$parsAssertIsNotFirstClassValue = SR$$$parsAssertIsNotFirstClassValue;
exports.SR$$$parsIdentifierExpected = SR$$$parsIdentifierExpected;
exports.SR$$$parsInOrEqualExpected = SR$$$parsInOrEqualExpected;
exports.SR$$$parsArrowUseIsLimited = SR$$$parsArrowUseIsLimited;
exports.SR$$$parsSuccessiveArgsShouldBeSpacedOrTupled = SR$$$parsSuccessiveArgsShouldBeSpacedOrTupled;
exports.SR$$$parsUnmatchedBracket = SR$$$parsUnmatchedBracket;
exports.SR$$$parsMissingQualificationAfterDot = SR$$$parsMissingQualificationAfterDot;
exports.SR$$$parsParenFormIsForML = SR$$$parsParenFormIsForML;
exports.SR$$$parsMismatchedQuote$$Z721C83C5 = SR$$$parsMismatchedQuote$$Z721C83C5;
exports.SR$$$parsUnmatched$$Z721C83C5 = SR$$$parsUnmatched$$Z721C83C5;
exports.SR$$$parsUnmatchedBracketBar = SR$$$parsUnmatchedBracketBar;
exports.SR$$$parsUnmatchedBrace = SR$$$parsUnmatchedBrace;
exports.SR$$$parsFieldBinding = SR$$$parsFieldBinding;
exports.SR$$$parsMemberIllegalInObjectImplementation = SR$$$parsMemberIllegalInObjectImplementation;
exports.SR$$$parsMissingFunctionBody = SR$$$parsMissingFunctionBody;
exports.SR$$$parsSyntaxErrorInLabeledType = SR$$$parsSyntaxErrorInLabeledType;
exports.SR$$$parsUnexpectedInfixOperator = SR$$$parsUnexpectedInfixOperator;
exports.SR$$$parsMultiArgumentGenericTypeFormDeprecated = SR$$$parsMultiArgumentGenericTypeFormDeprecated;
exports.SR$$$parsInvalidLiteralInType = SR$$$parsInvalidLiteralInType;
exports.SR$$$parsUnexpectedOperatorForUnitOfMeasure = SR$$$parsUnexpectedOperatorForUnitOfMeasure;
exports.SR$$$parsUnexpectedIntegerLiteralForUnitOfMeasure = SR$$$parsUnexpectedIntegerLiteralForUnitOfMeasure;
exports.SR$$$parsUnexpectedTypeParameter = SR$$$parsUnexpectedTypeParameter;
exports.SR$$$parsMismatchedQuotationName$$Z721C83C5 = SR$$$parsMismatchedQuotationName$$Z721C83C5;
exports.SR$$$parsActivePatternCaseMustBeginWithUpperCase = SR$$$parsActivePatternCaseMustBeginWithUpperCase;
exports.SR$$$parsActivePatternCaseContainsPipe = SR$$$parsActivePatternCaseContainsPipe;
exports.SR$$$parsIllegalDenominatorForMeasureExponent = SR$$$parsIllegalDenominatorForMeasureExponent;
exports.SR$$$parsNoEqualShouldFollowNamespace = SR$$$parsNoEqualShouldFollowNamespace;
exports.SR$$$parsSyntaxModuleStructEndDeprecated = SR$$$parsSyntaxModuleStructEndDeprecated;
exports.SR$$$parsSyntaxModuleSigEndDeprecated = SR$$$parsSyntaxModuleSigEndDeprecated;
exports.SR$$$tcStaticFieldUsedWhenInstanceFieldExpected = SR$$$tcStaticFieldUsedWhenInstanceFieldExpected;
exports.SR$$$tcMethodNotAccessible$$Z721C83C5 = SR$$$tcMethodNotAccessible$$Z721C83C5;
exports.SR$$$tcImplicitMeasureFollowingSlash = SR$$$tcImplicitMeasureFollowingSlash;
exports.SR$$$tcUnexpectedMeasureAnon = SR$$$tcUnexpectedMeasureAnon;
exports.SR$$$tcNonZeroConstantCannotHaveGenericUnit = SR$$$tcNonZeroConstantCannotHaveGenericUnit;
exports.SR$$$tcSeqResultsUseYield = SR$$$tcSeqResultsUseYield;
exports.SR$$$tcUnexpectedBigRationalConstant = SR$$$tcUnexpectedBigRationalConstant;
exports.SR$$$tcInvalidTypeForUnitsOfMeasure = SR$$$tcInvalidTypeForUnitsOfMeasure;
exports.SR$$$tcUnexpectedConstUint16Array = SR$$$tcUnexpectedConstUint16Array;
exports.SR$$$tcUnexpectedConstByteArray = SR$$$tcUnexpectedConstByteArray;
exports.SR$$$tcParameterRequiresName = SR$$$tcParameterRequiresName;
exports.SR$$$tcReturnValuesCannotHaveNames = SR$$$tcReturnValuesCannotHaveNames;
exports.SR$$$tcMemberKindPropertyGetSetNotExpected = SR$$$tcMemberKindPropertyGetSetNotExpected;
exports.SR$$$tcNamespaceCannotContainValues = SR$$$tcNamespaceCannotContainValues;
exports.SR$$$tcNamespaceCannotContainExtensionMembers = SR$$$tcNamespaceCannotContainExtensionMembers;
exports.SR$$$tcMultipleVisibilityAttributes = SR$$$tcMultipleVisibilityAttributes;
exports.SR$$$tcMultipleVisibilityAttributesWithLet = SR$$$tcMultipleVisibilityAttributesWithLet;
exports.SR$$$tcInvalidMethodNameForRelationalOperator$$Z384F8060 = SR$$$tcInvalidMethodNameForRelationalOperator$$Z384F8060;
exports.SR$$$tcInvalidMethodNameForEquality$$Z384F8060 = SR$$$tcInvalidMethodNameForEquality$$Z384F8060;
exports.SR$$$tcInvalidMemberName$$Z384F8060 = SR$$$tcInvalidMemberName$$Z384F8060;
exports.SR$$$tcInvalidMemberNameFixedTypes$$Z721C83C5 = SR$$$tcInvalidMemberNameFixedTypes$$Z721C83C5;
exports.SR$$$tcInvalidOperatorDefinitionRelational$$Z721C83C5 = SR$$$tcInvalidOperatorDefinitionRelational$$Z721C83C5;
exports.SR$$$tcInvalidOperatorDefinitionEquality$$Z721C83C5 = SR$$$tcInvalidOperatorDefinitionEquality$$Z721C83C5;
exports.SR$$$tcInvalidOperatorDefinition$$Z721C83C5 = SR$$$tcInvalidOperatorDefinition$$Z721C83C5;
exports.SR$$$tcInvalidIndexOperatorDefinition$$Z721C83C5 = SR$$$tcInvalidIndexOperatorDefinition$$Z721C83C5;
exports.SR$$$tcExpectModuleOrNamespaceParent$$Z721C83C5 = SR$$$tcExpectModuleOrNamespaceParent$$Z721C83C5;
exports.SR$$$tcImplementsIComparableExplicitly$$Z721C83C5 = SR$$$tcImplementsIComparableExplicitly$$Z721C83C5;
exports.SR$$$tcImplementsGenericIComparableExplicitly$$Z721C83C5 = SR$$$tcImplementsGenericIComparableExplicitly$$Z721C83C5;
exports.SR$$$tcImplementsIStructuralComparableExplicitly$$Z721C83C5 = SR$$$tcImplementsIStructuralComparableExplicitly$$Z721C83C5;
exports.SR$$$tcRecordFieldInconsistentTypes = SR$$$tcRecordFieldInconsistentTypes;
exports.SR$$$tcDllImportStubsCannotBeInlined = SR$$$tcDllImportStubsCannotBeInlined;
exports.SR$$$tcStructsCanOnlyBindThisAtMemberDeclaration = SR$$$tcStructsCanOnlyBindThisAtMemberDeclaration;
exports.SR$$$tcUnexpectedExprAtRecInfPoint = SR$$$tcUnexpectedExprAtRecInfPoint;
exports.SR$$$tcLessGenericBecauseOfAnnotation$$Z384F8060 = SR$$$tcLessGenericBecauseOfAnnotation$$Z384F8060;
exports.SR$$$tcConstrainedTypeVariableCannotBeGeneralized = SR$$$tcConstrainedTypeVariableCannotBeGeneralized;
exports.SR$$$tcGenericParameterHasBeenConstrained$$Z721C83C5 = SR$$$tcGenericParameterHasBeenConstrained$$Z721C83C5;
exports.SR$$$tcTypeParameterHasBeenConstrained$$Z721C83C5 = SR$$$tcTypeParameterHasBeenConstrained$$Z721C83C5;
exports.SR$$$tcTypeParametersInferredAreNotStable = SR$$$tcTypeParametersInferredAreNotStable;
exports.SR$$$tcExplicitTypeParameterInvalid = SR$$$tcExplicitTypeParameterInvalid;
exports.SR$$$tcOverridingMethodRequiresAllOrNoTypeParameters = SR$$$tcOverridingMethodRequiresAllOrNoTypeParameters;
exports.SR$$$tcFieldsDoNotDetermineUniqueRecordType = SR$$$tcFieldsDoNotDetermineUniqueRecordType;
exports.SR$$$tcFieldAppearsTwiceInRecord$$Z721C83C5 = SR$$$tcFieldAppearsTwiceInRecord$$Z721C83C5;
exports.SR$$$tcUnknownUnion = SR$$$tcUnknownUnion;
exports.SR$$$tcNotSufficientlyGenericBecauseOfScope$$Z721C83C5 = SR$$$tcNotSufficientlyGenericBecauseOfScope$$Z721C83C5;
exports.SR$$$tcPropertyRequiresExplicitTypeParameters = SR$$$tcPropertyRequiresExplicitTypeParameters;
exports.SR$$$tcConstructorCannotHaveTypeParameters = SR$$$tcConstructorCannotHaveTypeParameters;
exports.SR$$$tcInstanceMemberRequiresTarget = SR$$$tcInstanceMemberRequiresTarget;
exports.SR$$$tcUnexpectedPropertyInSyntaxTree = SR$$$tcUnexpectedPropertyInSyntaxTree;
exports.SR$$$tcStaticInitializerRequiresArgument = SR$$$tcStaticInitializerRequiresArgument;
exports.SR$$$tcObjectConstructorRequiresArgument = SR$$$tcObjectConstructorRequiresArgument;
exports.SR$$$tcStaticMemberShouldNotHaveThis = SR$$$tcStaticMemberShouldNotHaveThis;
exports.SR$$$tcExplicitStaticInitializerSyntax = SR$$$tcExplicitStaticInitializerSyntax;
exports.SR$$$tcExplicitObjectConstructorSyntax = SR$$$tcExplicitObjectConstructorSyntax;
exports.SR$$$tcUnexpectedPropertySpec = SR$$$tcUnexpectedPropertySpec;
exports.SR$$$tcObjectExpressionFormDeprecated = SR$$$tcObjectExpressionFormDeprecated;
exports.SR$$$tcInvalidDeclaration = SR$$$tcInvalidDeclaration;
exports.SR$$$tcAttributesInvalidInPatterns = SR$$$tcAttributesInvalidInPatterns;
exports.SR$$$tcFunctionRequiresExplicitTypeArguments$$Z721C83C5 = SR$$$tcFunctionRequiresExplicitTypeArguments$$Z721C83C5;
exports.SR$$$tcDoesNotAllowExplicitTypeArguments$$Z721C83C5 = SR$$$tcDoesNotAllowExplicitTypeArguments$$Z721C83C5;
exports.SR$$$tcTypeParameterArityMismatch$$Z37302880 = SR$$$tcTypeParameterArityMismatch$$Z37302880;
exports.SR$$$tcDefaultStructConstructorCall = SR$$$tcDefaultStructConstructorCall;
exports.SR$$$tcCouldNotFindIDisposable = SR$$$tcCouldNotFindIDisposable;
exports.SR$$$tcNonLiteralCannotBeUsedInPattern = SR$$$tcNonLiteralCannotBeUsedInPattern;
exports.SR$$$tcFieldIsReadonly = SR$$$tcFieldIsReadonly;
exports.SR$$$tcNameArgumentsMustAppearLast = SR$$$tcNameArgumentsMustAppearLast;
exports.SR$$$tcFunctionRequiresExplicitLambda$$Z524259A4 = SR$$$tcFunctionRequiresExplicitLambda$$Z524259A4;
exports.SR$$$tcTypeCannotBeEnumerated$$Z721C83C5 = SR$$$tcTypeCannotBeEnumerated$$Z721C83C5;
exports.SR$$$tcInvalidMixtureOfRecursiveForms = SR$$$tcInvalidMixtureOfRecursiveForms;
exports.SR$$$tcInvalidObjectConstructionExpression = SR$$$tcInvalidObjectConstructionExpression;
exports.SR$$$tcInvalidConstraint = SR$$$tcInvalidConstraint;
exports.SR$$$tcInvalidConstraintTypeSealed = SR$$$tcInvalidConstraintTypeSealed;
exports.SR$$$tcInvalidEnumConstraint = SR$$$tcInvalidEnumConstraint;
exports.SR$$$tcInvalidNewConstraint = SR$$$tcInvalidNewConstraint;
exports.SR$$$tcInvalidPropertyType = SR$$$tcInvalidPropertyType;
exports.SR$$$tcExpectedUnitOfMeasureMarkWithAttribute = SR$$$tcExpectedUnitOfMeasureMarkWithAttribute;
exports.SR$$$tcExpectedTypeParameter = SR$$$tcExpectedTypeParameter;
exports.SR$$$tcExpectedTypeNotUnitOfMeasure = SR$$$tcExpectedTypeNotUnitOfMeasure;
exports.SR$$$tcExpectedUnitOfMeasureNotType = SR$$$tcExpectedUnitOfMeasureNotType;
exports.SR$$$tcInvalidUnitsOfMeasurePrefix = SR$$$tcInvalidUnitsOfMeasurePrefix;
exports.SR$$$tcUnitsOfMeasureInvalidInTypeConstructor = SR$$$tcUnitsOfMeasureInvalidInTypeConstructor;
exports.SR$$$tcRequireBuilderMethod$$Z721C83C5 = SR$$$tcRequireBuilderMethod$$Z721C83C5;
exports.SR$$$tcTypeHasNoNestedTypes = SR$$$tcTypeHasNoNestedTypes;
exports.SR$$$tcUnexpectedSymbolInTypeExpression$$Z721C83C5 = SR$$$tcUnexpectedSymbolInTypeExpression$$Z721C83C5;
exports.SR$$$tcTypeParameterInvalidAsTypeConstructor = SR$$$tcTypeParameterInvalidAsTypeConstructor;
exports.SR$$$tcIllegalSyntaxInTypeExpression = SR$$$tcIllegalSyntaxInTypeExpression;
exports.SR$$$tcAnonymousUnitsOfMeasureCannotBeNested = SR$$$tcAnonymousUnitsOfMeasureCannotBeNested;
exports.SR$$$tcAnonymousTypeInvalidInDeclaration = SR$$$tcAnonymousTypeInvalidInDeclaration;
exports.SR$$$tcUnexpectedSlashInType = SR$$$tcUnexpectedSlashInType;
exports.SR$$$tcUnexpectedTypeArguments = SR$$$tcUnexpectedTypeArguments;
exports.SR$$$tcOptionalArgsOnlyOnMembers = SR$$$tcOptionalArgsOnlyOnMembers;
exports.SR$$$tcNameNotBoundInPattern$$Z721C83C5 = SR$$$tcNameNotBoundInPattern$$Z721C83C5;
exports.SR$$$tcInvalidNonPrimitiveLiteralInPatternMatch = SR$$$tcInvalidNonPrimitiveLiteralInPatternMatch;
exports.SR$$$tcInvalidTypeArgumentUsage = SR$$$tcInvalidTypeArgumentUsage;
exports.SR$$$tcRequireActivePatternWithOneResult = SR$$$tcRequireActivePatternWithOneResult;
exports.SR$$$tcInvalidArgForParameterizedPattern = SR$$$tcInvalidArgForParameterizedPattern;
exports.SR$$$tcInvalidIndexIntoActivePatternArray = SR$$$tcInvalidIndexIntoActivePatternArray;
exports.SR$$$tcUnionCaseDoesNotTakeArguments = SR$$$tcUnionCaseDoesNotTakeArguments;
exports.SR$$$tcUnionCaseRequiresOneArgument = SR$$$tcUnionCaseRequiresOneArgument;
exports.SR$$$tcUnionCaseExpectsTupledArguments$$Z524259A4 = SR$$$tcUnionCaseExpectsTupledArguments$$Z524259A4;
exports.SR$$$tcFieldIsNotStatic$$Z721C83C5 = SR$$$tcFieldIsNotStatic$$Z721C83C5;
exports.SR$$$tcFieldNotLiteralCannotBeUsedInPattern = SR$$$tcFieldNotLiteralCannotBeUsedInPattern;
exports.SR$$$tcRequireVarConstRecogOrLiteral = SR$$$tcRequireVarConstRecogOrLiteral;
exports.SR$$$tcInvalidPattern = SR$$$tcInvalidPattern;
exports.SR$$$tcUseWhenPatternGuard = SR$$$tcUseWhenPatternGuard;
exports.SR$$$tcIllegalPattern = SR$$$tcIllegalPattern;
exports.SR$$$tcSyntaxErrorUnexpectedQMark = SR$$$tcSyntaxErrorUnexpectedQMark;
exports.SR$$$tcExpressionCountMisMatch$$Z37302880 = SR$$$tcExpressionCountMisMatch$$Z37302880;
exports.SR$$$tcExprUndelayed = SR$$$tcExprUndelayed;
exports.SR$$$tcExpressionRequiresSequence = SR$$$tcExpressionRequiresSequence;
exports.SR$$$tcInvalidObjectExpressionSyntaxForm = SR$$$tcInvalidObjectExpressionSyntaxForm;
exports.SR$$$tcInvalidObjectSequenceOrRecordExpression = SR$$$tcInvalidObjectSequenceOrRecordExpression;
exports.SR$$$tcInvalidSequenceExpressionSyntaxForm = SR$$$tcInvalidSequenceExpressionSyntaxForm;
exports.SR$$$tcExpressionWithIfRequiresParenthesis = SR$$$tcExpressionWithIfRequiresParenthesis;
exports.SR$$$tcUnableToParseFormatString$$Z721C83C5 = SR$$$tcUnableToParseFormatString$$Z721C83C5;
exports.SR$$$tcListLiteralMaxSize = SR$$$tcListLiteralMaxSize;
exports.SR$$$tcExpressionFormRequiresObjectConstructor = SR$$$tcExpressionFormRequiresObjectConstructor;
exports.SR$$$tcNamedArgumentsCannotBeUsedInMemberTraits = SR$$$tcNamedArgumentsCannotBeUsedInMemberTraits;
exports.SR$$$tcNotValidEnumCaseName = SR$$$tcNotValidEnumCaseName;
exports.SR$$$tcFieldIsNotMutable = SR$$$tcFieldIsNotMutable;
exports.SR$$$tcConstructRequiresListArrayOrSequence = SR$$$tcConstructRequiresListArrayOrSequence;
exports.SR$$$tcConstructRequiresComputationExpressions = SR$$$tcConstructRequiresComputationExpressions;
exports.SR$$$tcConstructRequiresSequenceOrComputations = SR$$$tcConstructRequiresSequenceOrComputations;
exports.SR$$$tcConstructRequiresComputationExpression = SR$$$tcConstructRequiresComputationExpression;
exports.SR$$$tcInvalidIndexerExpression = SR$$$tcInvalidIndexerExpression;
exports.SR$$$tcObjectOfIndeterminateTypeUsedRequireTypeConstraint = SR$$$tcObjectOfIndeterminateTypeUsedRequireTypeConstraint;
exports.SR$$$tcCannotInheritFromVariableType = SR$$$tcCannotInheritFromVariableType;
exports.SR$$$tcObjectConstructorsOnTypeParametersCannotTakeArguments = SR$$$tcObjectConstructorsOnTypeParametersCannotTakeArguments;
exports.SR$$$tcCompiledNameAttributeMisused = SR$$$tcCompiledNameAttributeMisused;
exports.SR$$$tcNamedTypeRequired$$Z721C83C5 = SR$$$tcNamedTypeRequired$$Z721C83C5;
exports.SR$$$tcInheritCannotBeUsedOnInterfaceType = SR$$$tcInheritCannotBeUsedOnInterfaceType;
exports.SR$$$tcNewCannotBeUsedOnInterfaceType = SR$$$tcNewCannotBeUsedOnInterfaceType;
exports.SR$$$tcAbstractTypeCannotBeInstantiated = SR$$$tcAbstractTypeCannotBeInstantiated;
exports.SR$$$tcIDisposableTypeShouldUseNew = SR$$$tcIDisposableTypeShouldUseNew;
exports.SR$$$tcSyntaxCanOnlyBeUsedToCreateObjectTypes$$Z721C83C5 = SR$$$tcSyntaxCanOnlyBeUsedToCreateObjectTypes$$Z721C83C5;
exports.SR$$$tcConstructorRequiresCall$$Z721C83C5 = SR$$$tcConstructorRequiresCall$$Z721C83C5;
exports.SR$$$tcUndefinedField$$Z384F8060 = SR$$$tcUndefinedField$$Z384F8060;
exports.SR$$$tcFieldRequiresAssignment$$Z384F8060 = SR$$$tcFieldRequiresAssignment$$Z384F8060;
exports.SR$$$tcExtraneousFieldsGivenValues = SR$$$tcExtraneousFieldsGivenValues;
exports.SR$$$tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual = SR$$$tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual;
exports.SR$$$tcNoAbstractOrVirtualMemberFound$$Z721C83C5 = SR$$$tcNoAbstractOrVirtualMemberFound$$Z721C83C5;
exports.SR$$$tcMemberFoundIsNotAbstractOrVirtual$$Z384F8060 = SR$$$tcMemberFoundIsNotAbstractOrVirtual$$Z384F8060;
exports.SR$$$tcArgumentArityMismatch$$8A8C5B = SR$$$tcArgumentArityMismatch$$8A8C5B;
exports.SR$$$tcArgumentArityMismatchOneOverload$$8A8C5B = SR$$$tcArgumentArityMismatchOneOverload$$8A8C5B;
exports.SR$$$tcSimpleMethodNameRequired = SR$$$tcSimpleMethodNameRequired;
exports.SR$$$tcPredefinedTypeCannotBeUsedAsSuperType = SR$$$tcPredefinedTypeCannotBeUsedAsSuperType;
exports.SR$$$tcNewMustBeUsedWithNamedType = SR$$$tcNewMustBeUsedWithNamedType;
exports.SR$$$tcCannotCreateExtensionOfSealedType = SR$$$tcCannotCreateExtensionOfSealedType;
exports.SR$$$tcNoArgumentsForRecordValue = SR$$$tcNoArgumentsForRecordValue;
exports.SR$$$tcNoInterfaceImplementationForConstructionExpression = SR$$$tcNoInterfaceImplementationForConstructionExpression;
exports.SR$$$tcObjectConstructionCanOnlyBeUsedInClassTypes = SR$$$tcObjectConstructionCanOnlyBeUsedInClassTypes;
exports.SR$$$tcOnlySimpleBindingsCanBeUsedInConstructionExpressions = SR$$$tcOnlySimpleBindingsCanBeUsedInConstructionExpressions;
exports.SR$$$tcObjectsMustBeInitializedWithObjectExpression = SR$$$tcObjectsMustBeInitializedWithObjectExpression;
exports.SR$$$tcExpectedInterfaceType = SR$$$tcExpectedInterfaceType;
exports.SR$$$tcConstructorForInterfacesDoNotTakeArguments = SR$$$tcConstructorForInterfacesDoNotTakeArguments;
exports.SR$$$tcConstructorRequiresArguments = SR$$$tcConstructorRequiresArguments;
exports.SR$$$tcNewRequiresObjectConstructor = SR$$$tcNewRequiresObjectConstructor;
exports.SR$$$tcAtLeastOneOverrideIsInvalid = SR$$$tcAtLeastOneOverrideIsInvalid;
exports.SR$$$tcNumericLiteralRequiresModule$$Z721C83C5 = SR$$$tcNumericLiteralRequiresModule$$Z721C83C5;
exports.SR$$$tcInvalidRecordConstruction = SR$$$tcInvalidRecordConstruction;
exports.SR$$$tcExpressionFormRequiresRecordTypes = SR$$$tcExpressionFormRequiresRecordTypes;
exports.SR$$$tcInheritedTypeIsNotObjectModelType = SR$$$tcInheritedTypeIsNotObjectModelType;
exports.SR$$$tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes = SR$$$tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes;
exports.SR$$$tcEmptyRecordInvalid = SR$$$tcEmptyRecordInvalid;
exports.SR$$$tcTypeIsNotARecordTypeNeedConstructor = SR$$$tcTypeIsNotARecordTypeNeedConstructor;
exports.SR$$$tcTypeIsNotARecordType = SR$$$tcTypeIsNotARecordType;
exports.SR$$$tcConstructIsAmbiguousInComputationExpression = SR$$$tcConstructIsAmbiguousInComputationExpression;
exports.SR$$$tcConstructIsAmbiguousInSequenceExpression = SR$$$tcConstructIsAmbiguousInSequenceExpression;
exports.SR$$$tcDoBangIllegalInSequenceExpression = SR$$$tcDoBangIllegalInSequenceExpression;
exports.SR$$$tcUseForInSequenceExpression = SR$$$tcUseForInSequenceExpression;
exports.SR$$$tcTryIllegalInSequenceExpression = SR$$$tcTryIllegalInSequenceExpression;
exports.SR$$$tcUseYieldBangForMultipleResults = SR$$$tcUseYieldBangForMultipleResults;
exports.SR$$$tcInvalidAssignment = SR$$$tcInvalidAssignment;
exports.SR$$$tcInvalidUseOfTypeName = SR$$$tcInvalidUseOfTypeName;
exports.SR$$$tcTypeHasNoAccessibleConstructor = SR$$$tcTypeHasNoAccessibleConstructor;
exports.SR$$$tcInvalidUseOfInterfaceType = SR$$$tcInvalidUseOfInterfaceType;
exports.SR$$$tcInvalidUseOfDelegate = SR$$$tcInvalidUseOfDelegate;
exports.SR$$$tcPropertyIsNotStatic$$Z721C83C5 = SR$$$tcPropertyIsNotStatic$$Z721C83C5;
exports.SR$$$tcPropertyIsNotReadable$$Z721C83C5 = SR$$$tcPropertyIsNotReadable$$Z721C83C5;
exports.SR$$$tcLookupMayNotBeUsedHere = SR$$$tcLookupMayNotBeUsedHere;
exports.SR$$$tcPropertyIsStatic$$Z721C83C5 = SR$$$tcPropertyIsStatic$$Z721C83C5;
exports.SR$$$tcPropertyCannotBeSet1$$Z721C83C5 = SR$$$tcPropertyCannotBeSet1$$Z721C83C5;
exports.SR$$$tcConstructorsCannotBeFirstClassValues = SR$$$tcConstructorsCannotBeFirstClassValues;
exports.SR$$$tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields = SR$$$tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields;
exports.SR$$$tcEventIsStatic$$Z721C83C5 = SR$$$tcEventIsStatic$$Z721C83C5;
exports.SR$$$tcEventIsNotStatic$$Z721C83C5 = SR$$$tcEventIsNotStatic$$Z721C83C5;
exports.SR$$$tcNamedArgumentDidNotMatch$$Z721C83C5 = SR$$$tcNamedArgumentDidNotMatch$$Z721C83C5;
exports.SR$$$tcOverloadsCannotHaveCurriedArguments = SR$$$tcOverloadsCannotHaveCurriedArguments;
exports.SR$$$tcUnnamedArgumentsDoNotFormPrefix = SR$$$tcUnnamedArgumentsDoNotFormPrefix;
exports.SR$$$tcStaticOptimizationConditionalsOnlyForFSharpLibrary = SR$$$tcStaticOptimizationConditionalsOnlyForFSharpLibrary;
exports.SR$$$tcFormalArgumentIsNotOptional = SR$$$tcFormalArgumentIsNotOptional;
exports.SR$$$tcInvalidOptionalAssignmentToPropertyOrField = SR$$$tcInvalidOptionalAssignmentToPropertyOrField;
exports.SR$$$tcDelegateConstructorMustBePassed = SR$$$tcDelegateConstructorMustBePassed;
exports.SR$$$tcBindingCannotBeUseAndRec = SR$$$tcBindingCannotBeUseAndRec;
exports.SR$$$tcVolatileOnlyOnClassLetBindings = SR$$$tcVolatileOnlyOnClassLetBindings;
exports.SR$$$tcAttributesAreNotPermittedOnLetBindings = SR$$$tcAttributesAreNotPermittedOnLetBindings;
exports.SR$$$tcDefaultValueAttributeRequiresVal = SR$$$tcDefaultValueAttributeRequiresVal;
exports.SR$$$tcConditionalAttributeRequiresMembers = SR$$$tcConditionalAttributeRequiresMembers;
exports.SR$$$tcInvalidActivePatternName = SR$$$tcInvalidActivePatternName;
exports.SR$$$tcEntryPointAttributeRequiresFunctionInModule = SR$$$tcEntryPointAttributeRequiresFunctionInModule;
exports.SR$$$tcMutableValuesCannotBeInline = SR$$$tcMutableValuesCannotBeInline;
exports.SR$$$tcMutableValuesMayNotHaveGenericParameters = SR$$$tcMutableValuesMayNotHaveGenericParameters;
exports.SR$$$tcMutableValuesSyntax = SR$$$tcMutableValuesSyntax;
exports.SR$$$tcOnlyFunctionsCanBeInline = SR$$$tcOnlyFunctionsCanBeInline;
exports.SR$$$tcIllegalAttributesForLiteral = SR$$$tcIllegalAttributesForLiteral;
exports.SR$$$tcLiteralCannotBeMutable = SR$$$tcLiteralCannotBeMutable;
exports.SR$$$tcLiteralCannotBeInline = SR$$$tcLiteralCannotBeInline;
exports.SR$$$tcLiteralCannotHaveGenericParameters = SR$$$tcLiteralCannotHaveGenericParameters;
exports.SR$$$tcInvalidConstantExpression = SR$$$tcInvalidConstantExpression;
exports.SR$$$tcTypeIsInaccessible = SR$$$tcTypeIsInaccessible;
exports.SR$$$tcUnexpectedConditionInImportedAssembly = SR$$$tcUnexpectedConditionInImportedAssembly;
exports.SR$$$tcUnrecognizedAttributeTarget = SR$$$tcUnrecognizedAttributeTarget;
exports.SR$$$tcAttributeIsNotValidForLanguageElementUseDo = SR$$$tcAttributeIsNotValidForLanguageElementUseDo;
exports.SR$$$tcAttributeIsNotValidForLanguageElement = SR$$$tcAttributeIsNotValidForLanguageElement;
exports.SR$$$tcOptionalArgumentsCannotBeUsedInCustomAttribute = SR$$$tcOptionalArgumentsCannotBeUsedInCustomAttribute;
exports.SR$$$tcPropertyCannotBeSet0 = SR$$$tcPropertyCannotBeSet0;
exports.SR$$$tcPropertyOrFieldNotFoundInAttribute = SR$$$tcPropertyOrFieldNotFoundInAttribute;
exports.SR$$$tcCustomAttributeMustBeReferenceType = SR$$$tcCustomAttributeMustBeReferenceType;
exports.SR$$$tcCustomAttributeArgumentMismatch = SR$$$tcCustomAttributeArgumentMismatch;
exports.SR$$$tcCustomAttributeMustInvokeConstructor = SR$$$tcCustomAttributeMustInvokeConstructor;
exports.SR$$$tcAttributeExpressionsMustBeConstructorCalls = SR$$$tcAttributeExpressionsMustBeConstructorCalls;
exports.SR$$$tcUnsupportedAttribute = SR$$$tcUnsupportedAttribute;
exports.SR$$$tcInvalidInlineSpecification = SR$$$tcInvalidInlineSpecification;
exports.SR$$$tcInvalidUseBinding = SR$$$tcInvalidUseBinding;
exports.SR$$$tcAbstractMembersIllegalInAugmentation = SR$$$tcAbstractMembersIllegalInAugmentation;
exports.SR$$$tcMethodOverridesIllegalHere = SR$$$tcMethodOverridesIllegalHere;
exports.SR$$$tcNoMemberFoundForOverride = SR$$$tcNoMemberFoundForOverride;
exports.SR$$$tcOverrideArityMismatch$$Z721C83C5 = SR$$$tcOverrideArityMismatch$$Z721C83C5;
exports.SR$$$tcDefaultImplementationAlreadyExists = SR$$$tcDefaultImplementationAlreadyExists;
exports.SR$$$tcDefaultAmbiguous = SR$$$tcDefaultAmbiguous;
exports.SR$$$tcNoPropertyFoundForOverride = SR$$$tcNoPropertyFoundForOverride;
exports.SR$$$tcAbstractPropertyMissingGetOrSet$$Z721C83C5 = SR$$$tcAbstractPropertyMissingGetOrSet$$Z721C83C5;
exports.SR$$$tcInvalidSignatureForSet = SR$$$tcInvalidSignatureForSet;
exports.SR$$$tcNewMemberHidesAbstractMember$$Z721C83C5 = SR$$$tcNewMemberHidesAbstractMember$$Z721C83C5;
exports.SR$$$tcNewMemberHidesAbstractMemberWithSuffix$$Z721C83C5 = SR$$$tcNewMemberHidesAbstractMemberWithSuffix$$Z721C83C5;
exports.SR$$$tcStaticInitializersIllegalInInterface = SR$$$tcStaticInitializersIllegalInInterface;
exports.SR$$$tcObjectConstructorsIllegalInInterface = SR$$$tcObjectConstructorsIllegalInInterface;
exports.SR$$$tcMemberOverridesIllegalInInterface = SR$$$tcMemberOverridesIllegalInInterface;
exports.SR$$$tcConcreteMembersIllegalInInterface = SR$$$tcConcreteMembersIllegalInInterface;
exports.SR$$$tcConstructorsDisallowedInExceptionAugmentation = SR$$$tcConstructorsDisallowedInExceptionAugmentation;
exports.SR$$$tcStructsCannotHaveConstructorWithNoArguments = SR$$$tcStructsCannotHaveConstructorWithNoArguments;
exports.SR$$$tcConstructorsIllegalForThisType = SR$$$tcConstructorsIllegalForThisType;
exports.SR$$$tcRecursiveBindingsWithMembersMustBeDirectAugmentation = SR$$$tcRecursiveBindingsWithMembersMustBeDirectAugmentation;
exports.SR$$$tcOnlySimplePatternsInLetRec = SR$$$tcOnlySimplePatternsInLetRec;
exports.SR$$$tcOnlyRecordFieldsAndSimpleLetCanBeMutable = SR$$$tcOnlyRecordFieldsAndSimpleLetCanBeMutable;
exports.SR$$$tcMemberIsNotSufficientlyGeneric = SR$$$tcMemberIsNotSufficientlyGeneric;
exports.SR$$$tcLiteralAttributeRequiresConstantValue = SR$$$tcLiteralAttributeRequiresConstantValue;
exports.SR$$$tcValueInSignatureRequiresLiteralAttribute = SR$$$tcValueInSignatureRequiresLiteralAttribute;
exports.SR$$$tcThreadStaticAndContextStaticMustBeStatic = SR$$$tcThreadStaticAndContextStaticMustBeStatic;
exports.SR$$$tcVolatileFieldsMustBeMutable = SR$$$tcVolatileFieldsMustBeMutable;
exports.SR$$$tcUninitializedValFieldsMustBeMutable = SR$$$tcUninitializedValFieldsMustBeMutable;
exports.SR$$$tcStaticValFieldsMustBeMutableAndPrivate = SR$$$tcStaticValFieldsMustBeMutableAndPrivate;
exports.SR$$$tcFieldRequiresName = SR$$$tcFieldRequiresName;
exports.SR$$$tcInvalidNamespaceModuleTypeUnionName = SR$$$tcInvalidNamespaceModuleTypeUnionName;
exports.SR$$$tcIllegalFormForExplicitTypeDeclaration = SR$$$tcIllegalFormForExplicitTypeDeclaration;
exports.SR$$$tcReturnTypesForUnionMustBeSameAsType = SR$$$tcReturnTypesForUnionMustBeSameAsType;
exports.SR$$$tcInvalidEnumerationLiteral = SR$$$tcInvalidEnumerationLiteral;
exports.SR$$$tcTypeIsNotInterfaceType1$$Z721C83C5 = SR$$$tcTypeIsNotInterfaceType1$$Z721C83C5;
exports.SR$$$tcDuplicateSpecOfInterface = SR$$$tcDuplicateSpecOfInterface;
exports.SR$$$tcFieldValIllegalHere = SR$$$tcFieldValIllegalHere;
exports.SR$$$tcInheritIllegalHere = SR$$$tcInheritIllegalHere;
exports.SR$$$tcModuleRequiresQualifiedAccess$$Z721C83C5 = SR$$$tcModuleRequiresQualifiedAccess$$Z721C83C5;
exports.SR$$$tcOpenUsedWithPartiallyQualifiedPath$$Z721C83C5 = SR$$$tcOpenUsedWithPartiallyQualifiedPath$$Z721C83C5;
exports.SR$$$tcLocalClassBindingsCannotBeInline = SR$$$tcLocalClassBindingsCannotBeInline;
exports.SR$$$tcTypeAbbreviationsMayNotHaveMembers = SR$$$tcTypeAbbreviationsMayNotHaveMembers;
exports.SR$$$tcTypeAbbreviationsCheckedAtCompileTime = SR$$$tcTypeAbbreviationsCheckedAtCompileTime;
exports.SR$$$tcEnumerationsMayNotHaveMembers = SR$$$tcEnumerationsMayNotHaveMembers;
exports.SR$$$tcMeasureDeclarationsRequireStaticMembers = SR$$$tcMeasureDeclarationsRequireStaticMembers;
exports.SR$$$tcStructsMayNotContainDoBindings = SR$$$tcStructsMayNotContainDoBindings;
exports.SR$$$tcStructsMayNotContainLetBindings = SR$$$tcStructsMayNotContainLetBindings;
exports.SR$$$tcStaticLetBindingsRequireClassesWithImplicitConstructors = SR$$$tcStaticLetBindingsRequireClassesWithImplicitConstructors;
exports.SR$$$tcMeasureDeclarationsRequireStaticMembersNotConstructors = SR$$$tcMeasureDeclarationsRequireStaticMembersNotConstructors;
exports.SR$$$tcMemberAndLocalClassBindingHaveSameName$$Z721C83C5 = SR$$$tcMemberAndLocalClassBindingHaveSameName$$Z721C83C5;
exports.SR$$$tcTypeAbbreviationsCannotHaveInterfaceDeclaration = SR$$$tcTypeAbbreviationsCannotHaveInterfaceDeclaration;
exports.SR$$$tcEnumerationsCannotHaveInterfaceDeclaration = SR$$$tcEnumerationsCannotHaveInterfaceDeclaration;
exports.SR$$$tcTypeIsNotInterfaceType0 = SR$$$tcTypeIsNotInterfaceType0;
exports.SR$$$tcAllImplementedInterfacesShouldBeDeclared = SR$$$tcAllImplementedInterfacesShouldBeDeclared;
exports.SR$$$tcDefaultImplementationForInterfaceHasAlreadyBeenAdded = SR$$$tcDefaultImplementationForInterfaceHasAlreadyBeenAdded;
exports.SR$$$tcMemberNotPermittedInInterfaceImplementation = SR$$$tcMemberNotPermittedInInterfaceImplementation;
exports.SR$$$tcDeclarationElementNotPermittedInAugmentation = SR$$$tcDeclarationElementNotPermittedInAugmentation;
exports.SR$$$tcTypesCannotContainNestedTypes = SR$$$tcTypesCannotContainNestedTypes;
exports.SR$$$tcTypeExceptionOrModule = SR$$$tcTypeExceptionOrModule;
exports.SR$$$tcTypeOrModule = SR$$$tcTypeOrModule;
exports.SR$$$tcImplementsIStructuralEquatableExplicitly$$Z721C83C5 = SR$$$tcImplementsIStructuralEquatableExplicitly$$Z721C83C5;
exports.SR$$$tcImplementsIEquatableExplicitly$$Z721C83C5 = SR$$$tcImplementsIEquatableExplicitly$$Z721C83C5;
exports.SR$$$tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors = SR$$$tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors;
exports.SR$$$tcExceptionAbbreviationsShouldNotHaveArgumentList = SR$$$tcExceptionAbbreviationsShouldNotHaveArgumentList;
exports.SR$$$tcAbbreviationsFordotNetExceptionsCannotTakeArguments = SR$$$tcAbbreviationsFordotNetExceptionsCannotTakeArguments;
exports.SR$$$tcExceptionAbbreviationsMustReferToValidExceptions = SR$$$tcExceptionAbbreviationsMustReferToValidExceptions;
exports.SR$$$tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor = SR$$$tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor;
exports.SR$$$tcNotAnException = SR$$$tcNotAnException;
exports.SR$$$tcInvalidModuleName = SR$$$tcInvalidModuleName;
exports.SR$$$tcInvalidTypeExtension = SR$$$tcInvalidTypeExtension;
exports.SR$$$tcAttributesOfTypeSpecifyMultipleKindsForType = SR$$$tcAttributesOfTypeSpecifyMultipleKindsForType;
exports.SR$$$tcKindOfTypeSpecifiedDoesNotMatchDefinition = SR$$$tcKindOfTypeSpecifiedDoesNotMatchDefinition;
exports.SR$$$tcMeasureDefinitionsCannotHaveTypeParameters = SR$$$tcMeasureDefinitionsCannotHaveTypeParameters;
exports.SR$$$tcTypeRequiresDefinition = SR$$$tcTypeRequiresDefinition;
exports.SR$$$tcTypeAbbreviationHasTypeParametersMissingOnType = SR$$$tcTypeAbbreviationHasTypeParametersMissingOnType;
exports.SR$$$tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes = SR$$$tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes;
exports.SR$$$tcTypesCannotInheritFromMultipleConcreteTypes = SR$$$tcTypesCannotInheritFromMultipleConcreteTypes;
exports.SR$$$tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute = SR$$$tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute;
exports.SR$$$tcAllowNullTypesMayOnlyInheritFromAllowNullTypes = SR$$$tcAllowNullTypesMayOnlyInheritFromAllowNullTypes;
exports.SR$$$tcGenericTypesCannotHaveStructLayout = SR$$$tcGenericTypesCannotHaveStructLayout;
exports.SR$$$tcOnlyStructsCanHaveStructLayout = SR$$$tcOnlyStructsCanHaveStructLayout;
exports.SR$$$tcRepresentationOfTypeHiddenBySignature = SR$$$tcRepresentationOfTypeHiddenBySignature;
exports.SR$$$tcOnlyClassesCanHaveAbstract = SR$$$tcOnlyClassesCanHaveAbstract;
exports.SR$$$tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure = SR$$$tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure;
exports.SR$$$tcOverridesCannotHaveVisibilityDeclarations = SR$$$tcOverridesCannotHaveVisibilityDeclarations;
exports.SR$$$tcTypesAreAlwaysSealedDU = SR$$$tcTypesAreAlwaysSealedDU;
exports.SR$$$tcTypesAreAlwaysSealedRecord = SR$$$tcTypesAreAlwaysSealedRecord;
exports.SR$$$tcTypesAreAlwaysSealedAssemblyCode = SR$$$tcTypesAreAlwaysSealedAssemblyCode;
exports.SR$$$tcTypesAreAlwaysSealedStruct = SR$$$tcTypesAreAlwaysSealedStruct;
exports.SR$$$tcTypesAreAlwaysSealedDelegate = SR$$$tcTypesAreAlwaysSealedDelegate;
exports.SR$$$tcTypesAreAlwaysSealedEnum = SR$$$tcTypesAreAlwaysSealedEnum;
exports.SR$$$tcInterfaceTypesAndDelegatesCannotContainFields = SR$$$tcInterfaceTypesAndDelegatesCannotContainFields;
exports.SR$$$tcAbbreviatedTypesCannotBeSealed = SR$$$tcAbbreviatedTypesCannotBeSealed;
exports.SR$$$tcCannotInheritFromSealedType = SR$$$tcCannotInheritFromSealedType;
exports.SR$$$tcCannotInheritFromInterfaceType = SR$$$tcCannotInheritFromInterfaceType;
exports.SR$$$tcStructTypesCannotContainAbstractMembers = SR$$$tcStructTypesCannotContainAbstractMembers;
exports.SR$$$tcInterfaceTypesCannotBeSealed = SR$$$tcInterfaceTypesCannotBeSealed;
exports.SR$$$tcInvalidDelegateSpecification = SR$$$tcInvalidDelegateSpecification;
exports.SR$$$tcDelegatesCannotBeCurried = SR$$$tcDelegatesCannotBeCurried;
exports.SR$$$tcInvalidTypeForLiteralEnumeration = SR$$$tcInvalidTypeForLiteralEnumeration;
exports.SR$$$tcTypeDefinitionIsCyclic = SR$$$tcTypeDefinitionIsCyclic;
exports.SR$$$tcTypeDefinitionIsCyclicThroughInheritance = SR$$$tcTypeDefinitionIsCyclicThroughInheritance;
exports.SR$$$tcReservedSyntaxForAugmentation = SR$$$tcReservedSyntaxForAugmentation;
exports.SR$$$tcMembersThatExtendInterfaceMustBePlacedInSeparateModule = SR$$$tcMembersThatExtendInterfaceMustBePlacedInSeparateModule;
exports.SR$$$tcDeclaredTypeParametersForExtensionDoNotMatchOriginal$$Z721C83C5 = SR$$$tcDeclaredTypeParametersForExtensionDoNotMatchOriginal$$Z721C83C5;
exports.SR$$$tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit = SR$$$tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit;
exports.SR$$$tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers = SR$$$tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers;
exports.SR$$$tcInheritDeclarationMissingArguments = SR$$$tcInheritDeclarationMissingArguments;
exports.SR$$$tcInheritConstructionCallNotPartOfImplicitSequence = SR$$$tcInheritConstructionCallNotPartOfImplicitSequence;
exports.SR$$$tcLetAndDoRequiresImplicitConstructionSequence = SR$$$tcLetAndDoRequiresImplicitConstructionSequence;
exports.SR$$$tcTypeAbbreviationsCannotHaveAugmentations = SR$$$tcTypeAbbreviationsCannotHaveAugmentations;
exports.SR$$$tcModuleAbbreviationForNamespace$$Z721C83C5 = SR$$$tcModuleAbbreviationForNamespace$$Z721C83C5;
exports.SR$$$tcTypeUsedInInvalidWay$$30230F9B = SR$$$tcTypeUsedInInvalidWay$$30230F9B;
exports.SR$$$tcMemberUsedInInvalidWay$$30230F9B = SR$$$tcMemberUsedInInvalidWay$$30230F9B;
exports.SR$$$tcAttributeAutoOpenWasIgnored$$Z384F8060 = SR$$$tcAttributeAutoOpenWasIgnored$$Z384F8060;
exports.SR$$$ilUndefinedValue$$Z721C83C5 = SR$$$ilUndefinedValue$$Z721C83C5;
exports.SR$$$ilLabelNotFound$$Z721C83C5 = SR$$$ilLabelNotFound$$Z721C83C5;
exports.SR$$$ilIncorrectNumberOfTypeArguments = SR$$$ilIncorrectNumberOfTypeArguments;
exports.SR$$$ilDynamicInvocationNotSupported$$Z721C83C5 = SR$$$ilDynamicInvocationNotSupported$$Z721C83C5;
exports.SR$$$ilAddressOfLiteralFieldIsInvalid = SR$$$ilAddressOfLiteralFieldIsInvalid;
exports.SR$$$ilAddressOfValueHereIsInvalid$$Z721C83C5 = SR$$$ilAddressOfValueHereIsInvalid$$Z721C83C5;
exports.SR$$$ilCustomMarshallersCannotBeUsedInFSharp = SR$$$ilCustomMarshallersCannotBeUsedInFSharp;
exports.SR$$$ilMarshalAsAttributeCannotBeDecoded = SR$$$ilMarshalAsAttributeCannotBeDecoded;
exports.SR$$$ilSignatureForExternalFunctionContainsTypeParameters = SR$$$ilSignatureForExternalFunctionContainsTypeParameters;
exports.SR$$$ilDllImportAttributeCouldNotBeDecoded = SR$$$ilDllImportAttributeCouldNotBeDecoded;
exports.SR$$$ilLiteralFieldsCannotBeSet = SR$$$ilLiteralFieldsCannotBeSet;
exports.SR$$$ilStaticMethodIsNotLambda$$Z721C83C5 = SR$$$ilStaticMethodIsNotLambda$$Z721C83C5;
exports.SR$$$ilMutableVariablesCannotEscapeMethod = SR$$$ilMutableVariablesCannotEscapeMethod;
exports.SR$$$ilUnexpectedUnrealizedValue = SR$$$ilUnexpectedUnrealizedValue;
exports.SR$$$ilMainModuleEmpty = SR$$$ilMainModuleEmpty;
exports.SR$$$ilTypeCannotBeUsedForLiteralField = SR$$$ilTypeCannotBeUsedForLiteralField;
exports.SR$$$ilUnexpectedGetSetAnnotation = SR$$$ilUnexpectedGetSetAnnotation;
exports.SR$$$ilFieldOffsetAttributeCouldNotBeDecoded = SR$$$ilFieldOffsetAttributeCouldNotBeDecoded;
exports.SR$$$ilStructLayoutAttributeCouldNotBeDecoded = SR$$$ilStructLayoutAttributeCouldNotBeDecoded;
exports.SR$$$ilDefaultAugmentationAttributeCouldNotBeDecoded = SR$$$ilDefaultAugmentationAttributeCouldNotBeDecoded;
exports.SR$$$ilReflectedDefinitionsCannotUseSliceOperator = SR$$$ilReflectedDefinitionsCannotUseSliceOperator;
exports.SR$$$optsProblemWithCodepage$$Z176EF219 = SR$$$optsProblemWithCodepage$$Z176EF219;
exports.SR$$$optsCopyright = SR$$$optsCopyright;
exports.SR$$$optsCopyrightCommunity = SR$$$optsCopyrightCommunity;
exports.SR$$$optsNameOfOutputFile = SR$$$optsNameOfOutputFile;
exports.SR$$$optsBuildConsole = SR$$$optsBuildConsole;
exports.SR$$$optsBuildWindows = SR$$$optsBuildWindows;
exports.SR$$$optsBuildLibrary = SR$$$optsBuildLibrary;
exports.SR$$$optsBuildModule = SR$$$optsBuildModule;
exports.SR$$$optsDelaySign = SR$$$optsDelaySign;
exports.SR$$$optsPublicSign = SR$$$optsPublicSign;
exports.SR$$$optsWriteXml = SR$$$optsWriteXml;
exports.SR$$$optsStrongKeyFile = SR$$$optsStrongKeyFile;
exports.SR$$$optsStrongKeyContainer = SR$$$optsStrongKeyContainer;
exports.SR$$$optsPlatform = SR$$$optsPlatform;
exports.SR$$$optsNoOpt = SR$$$optsNoOpt;
exports.SR$$$optsNoInterface = SR$$$optsNoInterface;
exports.SR$$$optsSig = SR$$$optsSig;
exports.SR$$$optsReference = SR$$$optsReference;
exports.SR$$$optsWin32res = SR$$$optsWin32res;
exports.SR$$$optsWin32manifest = SR$$$optsWin32manifest;
exports.SR$$$optsNowin32manifest = SR$$$optsNowin32manifest;
exports.SR$$$optsEmbedAllSource = SR$$$optsEmbedAllSource;
exports.SR$$$optsEmbedSource = SR$$$optsEmbedSource;
exports.SR$$$optsSourceLink = SR$$$optsSourceLink;
exports.SR$$$optsEmbeddedSourceRequirePortablePDBs = SR$$$optsEmbeddedSourceRequirePortablePDBs;
exports.SR$$$optsSourceLinkRequirePortablePDBs = SR$$$optsSourceLinkRequirePortablePDBs;
exports.SR$$$srcFileTooLarge = SR$$$srcFileTooLarge;
exports.SR$$$optsResource = SR$$$optsResource;
exports.SR$$$optsLinkresource = SR$$$optsLinkresource;
exports.SR$$$optsDebugPM = SR$$$optsDebugPM;
exports.SR$$$optsDebug$$Z721C83C5 = SR$$$optsDebug$$Z721C83C5;
exports.SR$$$optsOptimize = SR$$$optsOptimize;
exports.SR$$$optsTailcalls = SR$$$optsTailcalls;
exports.SR$$$optsDeterministic = SR$$$optsDeterministic;
exports.SR$$$optsCrossoptimize = SR$$$optsCrossoptimize;
exports.SR$$$optsWarnaserrorPM = SR$$$optsWarnaserrorPM;
exports.SR$$$optsWarnaserror = SR$$$optsWarnaserror;
exports.SR$$$optsWarn = SR$$$optsWarn;
exports.SR$$$optsNowarn = SR$$$optsNowarn;
exports.SR$$$optsWarnOn = SR$$$optsWarnOn;
exports.SR$$$optsChecked = SR$$$optsChecked;
exports.SR$$$optsDefine = SR$$$optsDefine;
exports.SR$$$optsMlcompatibility = SR$$$optsMlcompatibility;
exports.SR$$$optsNologo = SR$$$optsNologo;
exports.SR$$$optsHelp = SR$$$optsHelp;
exports.SR$$$optsResponseFile = SR$$$optsResponseFile;
exports.SR$$$optsCodepage = SR$$$optsCodepage;
exports.SR$$$optsUtf8output = SR$$$optsUtf8output;
exports.SR$$$optsFullpaths = SR$$$optsFullpaths;
exports.SR$$$optsLib = SR$$$optsLib;
exports.SR$$$optsBaseaddress = SR$$$optsBaseaddress;
exports.SR$$$optsNoframework = SR$$$optsNoframework;
exports.SR$$$optsStandalone = SR$$$optsStandalone;
exports.SR$$$optsStaticlink = SR$$$optsStaticlink;
exports.SR$$$optsResident = SR$$$optsResident;
exports.SR$$$optsPdb = SR$$$optsPdb;
exports.SR$$$optsSimpleresolution = SR$$$optsSimpleresolution;
exports.SR$$$optsUnrecognizedTarget$$Z721C83C5 = SR$$$optsUnrecognizedTarget$$Z721C83C5;
exports.SR$$$optsUnrecognizedDebugType$$Z721C83C5 = SR$$$optsUnrecognizedDebugType$$Z721C83C5;
exports.SR$$$optsInvalidWarningLevel$$Z524259A4 = SR$$$optsInvalidWarningLevel$$Z524259A4;
exports.SR$$$optsShortFormOf$$Z721C83C5 = SR$$$optsShortFormOf$$Z721C83C5;
exports.SR$$$optsClirootDeprecatedMsg = SR$$$optsClirootDeprecatedMsg;
exports.SR$$$optsClirootDescription = SR$$$optsClirootDescription;
exports.SR$$$optsHelpBannerOutputFiles = SR$$$optsHelpBannerOutputFiles;
exports.SR$$$optsHelpBannerInputFiles = SR$$$optsHelpBannerInputFiles;
exports.SR$$$optsHelpBannerResources = SR$$$optsHelpBannerResources;
exports.SR$$$optsHelpBannerCodeGen = SR$$$optsHelpBannerCodeGen;
exports.SR$$$optsHelpBannerAdvanced = SR$$$optsHelpBannerAdvanced;
exports.SR$$$optsHelpBannerMisc = SR$$$optsHelpBannerMisc;
exports.SR$$$optsHelpBannerLanguage = SR$$$optsHelpBannerLanguage;
exports.SR$$$optsHelpBannerErrsAndWarns = SR$$$optsHelpBannerErrsAndWarns;
exports.SR$$$optsUnknownArgumentToTheTestSwitch$$Z721C83C5 = SR$$$optsUnknownArgumentToTheTestSwitch$$Z721C83C5;
exports.SR$$$optsUnknownPlatform$$Z721C83C5 = SR$$$optsUnknownPlatform$$Z721C83C5;
exports.SR$$$optsInternalNoDescription$$Z721C83C5 = SR$$$optsInternalNoDescription$$Z721C83C5;
exports.SR$$$optsDCLONoDescription$$Z721C83C5 = SR$$$optsDCLONoDescription$$Z721C83C5;
exports.SR$$$optsDCLODeprecatedSuggestAlternative$$Z384F8060 = SR$$$optsDCLODeprecatedSuggestAlternative$$Z384F8060;
exports.SR$$$optsDCLOHtmlDoc$$Z721C83C5 = SR$$$optsDCLOHtmlDoc$$Z721C83C5;
exports.SR$$$optsConsoleColors = SR$$$optsConsoleColors;
exports.SR$$$optsUseHighEntropyVA = SR$$$optsUseHighEntropyVA;
exports.SR$$$optsSubSystemVersion = SR$$$optsSubSystemVersion;
exports.SR$$$optsTargetProfile = SR$$$optsTargetProfile;
exports.SR$$$optsEmitDebugInfoInQuotations = SR$$$optsEmitDebugInfoInQuotations;
exports.SR$$$optsPreferredUiLang = SR$$$optsPreferredUiLang;
exports.SR$$$optsNoCopyFsharpCore = SR$$$optsNoCopyFsharpCore;
exports.SR$$$optsInvalidSubSystemVersion$$Z721C83C5 = SR$$$optsInvalidSubSystemVersion$$Z721C83C5;
exports.SR$$$optsInvalidTargetProfile$$Z721C83C5 = SR$$$optsInvalidTargetProfile$$Z721C83C5;
exports.SR$$$typeInfoFullName = SR$$$typeInfoFullName;
exports.SR$$$typeInfoOtherOverloads$$Z524259A4 = SR$$$typeInfoOtherOverloads$$Z524259A4;
exports.SR$$$typeInfoUnionCase = SR$$$typeInfoUnionCase;
exports.SR$$$typeInfoActivePatternResult = SR$$$typeInfoActivePatternResult;
exports.SR$$$typeInfoActiveRecognizer = SR$$$typeInfoActiveRecognizer;
exports.SR$$$typeInfoField = SR$$$typeInfoField;
exports.SR$$$typeInfoEvent = SR$$$typeInfoEvent;
exports.SR$$$typeInfoProperty = SR$$$typeInfoProperty;
exports.SR$$$typeInfoExtension = SR$$$typeInfoExtension;
exports.SR$$$typeInfoCustomOperation = SR$$$typeInfoCustomOperation;
exports.SR$$$typeInfoArgument = SR$$$typeInfoArgument;
exports.SR$$$typeInfoPatternVariable = SR$$$typeInfoPatternVariable;
exports.SR$$$typeInfoNamespace = SR$$$typeInfoNamespace;
exports.SR$$$typeInfoModule = SR$$$typeInfoModule;
exports.SR$$$typeInfoNamespaceOrModule = SR$$$typeInfoNamespaceOrModule;
exports.SR$$$typeInfoFromFirst$$Z721C83C5 = SR$$$typeInfoFromFirst$$Z721C83C5;
exports.SR$$$typeInfoFromNext$$Z721C83C5 = SR$$$typeInfoFromNext$$Z721C83C5;
exports.SR$$$typeInfoGeneratedProperty = SR$$$typeInfoGeneratedProperty;
exports.SR$$$typeInfoGeneratedType = SR$$$typeInfoGeneratedType;
exports.SR$$$assemblyResolutionFoundByAssemblyFoldersKey = SR$$$assemblyResolutionFoundByAssemblyFoldersKey;
exports.SR$$$assemblyResolutionFoundByAssemblyFoldersExKey = SR$$$assemblyResolutionFoundByAssemblyFoldersExKey;
exports.SR$$$assemblyResolutionNetFramework = SR$$$assemblyResolutionNetFramework;
exports.SR$$$assemblyResolutionGAC = SR$$$assemblyResolutionGAC;
exports.SR$$$recursiveClassHierarchy$$Z721C83C5 = SR$$$recursiveClassHierarchy$$Z721C83C5;
exports.SR$$$InvalidRecursiveReferenceToAbstractSlot = SR$$$InvalidRecursiveReferenceToAbstractSlot;
exports.SR$$$eventHasNonStandardType$$30230F9B = SR$$$eventHasNonStandardType$$30230F9B;
exports.SR$$$typeIsNotAccessible$$Z721C83C5 = SR$$$typeIsNotAccessible$$Z721C83C5;
exports.SR$$$unionCasesAreNotAccessible$$Z721C83C5 = SR$$$unionCasesAreNotAccessible$$Z721C83C5;
exports.SR$$$valueIsNotAccessible$$Z721C83C5 = SR$$$valueIsNotAccessible$$Z721C83C5;
exports.SR$$$unionCaseIsNotAccessible$$Z721C83C5 = SR$$$unionCaseIsNotAccessible$$Z721C83C5;
exports.SR$$$fieldIsNotAccessible$$Z721C83C5 = SR$$$fieldIsNotAccessible$$Z721C83C5;
exports.SR$$$structOrClassFieldIsNotAccessible$$Z721C83C5 = SR$$$structOrClassFieldIsNotAccessible$$Z721C83C5;
exports.SR$$$experimentalConstruct = SR$$$experimentalConstruct;
exports.SR$$$noInvokeMethodsFound = SR$$$noInvokeMethodsFound;
exports.SR$$$moreThanOneInvokeMethodFound = SR$$$moreThanOneInvokeMethodFound;
exports.SR$$$delegatesNotAllowedToHaveCurriedSignatures = SR$$$delegatesNotAllowedToHaveCurriedSignatures;
exports.SR$$$tlrUnexpectedTExpr = SR$$$tlrUnexpectedTExpr;
exports.SR$$$tlrLambdaLiftingOptimizationsNotApplied = SR$$$tlrLambdaLiftingOptimizationsNotApplied;
exports.SR$$$lexhlpIdentifiersContainingAtSymbolReserved = SR$$$lexhlpIdentifiersContainingAtSymbolReserved;
exports.SR$$$lexhlpIdentifierReserved$$Z721C83C5 = SR$$$lexhlpIdentifierReserved$$Z721C83C5;
exports.SR$$$patcMissingVariable$$Z721C83C5 = SR$$$patcMissingVariable$$Z721C83C5;
exports.SR$$$patcPartialActivePatternsGenerateOneResult = SR$$$patcPartialActivePatternsGenerateOneResult;
exports.SR$$$impTypeRequiredUnavailable$$Z384F8060 = SR$$$impTypeRequiredUnavailable$$Z384F8060;
exports.SR$$$impReferencedTypeCouldNotBeFoundInAssembly$$Z384F8060 = SR$$$impReferencedTypeCouldNotBeFoundInAssembly$$Z384F8060;
exports.SR$$$impNotEnoughTypeParamsInScopeWhileImporting = SR$$$impNotEnoughTypeParamsInScopeWhileImporting;
exports.SR$$$impReferenceToDllRequiredByAssembly$$30230F9B = SR$$$impReferenceToDllRequiredByAssembly$$30230F9B;
exports.SR$$$impImportedAssemblyUsesNotPublicType$$Z721C83C5 = SR$$$impImportedAssemblyUsesNotPublicType$$Z721C83C5;
exports.SR$$$optValueMarkedInlineButIncomplete$$Z721C83C5 = SR$$$optValueMarkedInlineButIncomplete$$Z721C83C5;
exports.SR$$$optValueMarkedInlineButWasNotBoundInTheOptEnv$$Z721C83C5 = SR$$$optValueMarkedInlineButWasNotBoundInTheOptEnv$$Z721C83C5;
exports.SR$$$optLocalValueNotFoundDuringOptimization$$Z721C83C5 = SR$$$optLocalValueNotFoundDuringOptimization$$Z721C83C5;
exports.SR$$$optValueMarkedInlineHasUnexpectedValue = SR$$$optValueMarkedInlineHasUnexpectedValue;
exports.SR$$$optValueMarkedInlineCouldNotBeInlined = SR$$$optValueMarkedInlineCouldNotBeInlined;
exports.SR$$$optFailedToInlineValue$$Z721C83C5 = SR$$$optFailedToInlineValue$$Z721C83C5;
exports.SR$$$optRecursiveValValue$$Z721C83C5 = SR$$$optRecursiveValValue$$Z721C83C5;
exports.SR$$$lexfltIncorrentIndentationOfIn = SR$$$lexfltIncorrentIndentationOfIn;
exports.SR$$$lexfltTokenIsOffsideOfContextStartedEarlier$$Z721C83C5 = SR$$$lexfltTokenIsOffsideOfContextStartedEarlier$$Z721C83C5;
exports.SR$$$lexfltSeparatorTokensOfPatternMatchMisaligned = SR$$$lexfltSeparatorTokensOfPatternMatchMisaligned;
exports.SR$$$nrInvalidModuleExprType = SR$$$nrInvalidModuleExprType;
exports.SR$$$nrTypeInstantiationNeededToDisambiguateTypesWithSameName$$Z384F8060 = SR$$$nrTypeInstantiationNeededToDisambiguateTypesWithSameName$$Z384F8060;
exports.SR$$$nrTypeInstantiationIsMissingAndCouldNotBeInferred$$Z384F8060 = SR$$$nrTypeInstantiationIsMissingAndCouldNotBeInferred$$Z384F8060;
exports.SR$$$nrGlobalUsedOnlyAsFirstName = SR$$$nrGlobalUsedOnlyAsFirstName;
exports.SR$$$nrIsNotConstructorOrLiteral = SR$$$nrIsNotConstructorOrLiteral;
exports.SR$$$nrUnexpectedEmptyLongId = SR$$$nrUnexpectedEmptyLongId;
exports.SR$$$nrRecordDoesNotContainSuchLabel$$Z384F8060 = SR$$$nrRecordDoesNotContainSuchLabel$$Z384F8060;
exports.SR$$$nrInvalidFieldLabel = SR$$$nrInvalidFieldLabel;
exports.SR$$$nrInvalidExpression$$Z721C83C5 = SR$$$nrInvalidExpression$$Z721C83C5;
exports.SR$$$nrNoConstructorsAvailableForType$$Z721C83C5 = SR$$$nrNoConstructorsAvailableForType$$Z721C83C5;
exports.SR$$$nrUnionTypeNeedsQualifiedAccess$$Z384F8060 = SR$$$nrUnionTypeNeedsQualifiedAccess$$Z384F8060;
exports.SR$$$nrRecordTypeNeedsQualifiedAccess$$Z384F8060 = SR$$$nrRecordTypeNeedsQualifiedAccess$$Z384F8060;
exports.SR$$$ilwriteErrorCreatingPdb$$Z721C83C5 = SR$$$ilwriteErrorCreatingPdb$$Z721C83C5;
exports.SR$$$lexOutsideIntegerRange = SR$$$lexOutsideIntegerRange;
exports.SR$$$lexCharNotAllowedInOperatorNames$$Z721C83C5 = SR$$$lexCharNotAllowedInOperatorNames$$Z721C83C5;
exports.SR$$$lexUnexpectedChar$$Z721C83C5 = SR$$$lexUnexpectedChar$$Z721C83C5;
exports.SR$$$lexByteArrayCannotEncode = SR$$$lexByteArrayCannotEncode;
exports.SR$$$lexIdentEndInMarkReserved$$Z721C83C5 = SR$$$lexIdentEndInMarkReserved$$Z721C83C5;
exports.SR$$$lexOutsideEightBitSigned = SR$$$lexOutsideEightBitSigned;
exports.SR$$$lexOutsideEightBitSignedHex = SR$$$lexOutsideEightBitSignedHex;
exports.SR$$$lexOutsideEightBitUnsigned = SR$$$lexOutsideEightBitUnsigned;
exports.SR$$$lexOutsideSixteenBitSigned = SR$$$lexOutsideSixteenBitSigned;
exports.SR$$$lexOutsideSixteenBitUnsigned = SR$$$lexOutsideSixteenBitUnsigned;
exports.SR$$$lexOutsideThirtyTwoBitSigned = SR$$$lexOutsideThirtyTwoBitSigned;
exports.SR$$$lexOutsideThirtyTwoBitUnsigned = SR$$$lexOutsideThirtyTwoBitUnsigned;
exports.SR$$$lexOutsideSixtyFourBitSigned = SR$$$lexOutsideSixtyFourBitSigned;
exports.SR$$$lexOutsideSixtyFourBitUnsigned = SR$$$lexOutsideSixtyFourBitUnsigned;
exports.SR$$$lexOutsideNativeSigned = SR$$$lexOutsideNativeSigned;
exports.SR$$$lexOutsideNativeUnsigned = SR$$$lexOutsideNativeUnsigned;
exports.SR$$$lexInvalidFloat = SR$$$lexInvalidFloat;
exports.SR$$$lexOusideDecimal = SR$$$lexOusideDecimal;
exports.SR$$$lexOusideThirtyTwoBitFloat = SR$$$lexOusideThirtyTwoBitFloat;
exports.SR$$$lexInvalidNumericLiteral = SR$$$lexInvalidNumericLiteral;
exports.SR$$$lexInvalidByteLiteral = SR$$$lexInvalidByteLiteral;
exports.SR$$$lexInvalidCharLiteral = SR$$$lexInvalidCharLiteral;
exports.SR$$$lexThisUnicodeOnlyInStringLiterals = SR$$$lexThisUnicodeOnlyInStringLiterals;
exports.SR$$$lexTokenReserved = SR$$$lexTokenReserved;
exports.SR$$$lexTabsNotAllowed = SR$$$lexTabsNotAllowed;
exports.SR$$$lexInvalidLineNumber$$Z721C83C5 = SR$$$lexInvalidLineNumber$$Z721C83C5;
exports.SR$$$lexHashIfMustBeFirst = SR$$$lexHashIfMustBeFirst;
exports.SR$$$lexHashElseNoMatchingIf = SR$$$lexHashElseNoMatchingIf;
exports.SR$$$lexHashEndifRequiredForElse = SR$$$lexHashEndifRequiredForElse;
exports.SR$$$lexHashElseMustBeFirst = SR$$$lexHashElseMustBeFirst;
exports.SR$$$lexHashEndingNoMatchingIf = SR$$$lexHashEndingNoMatchingIf;
exports.SR$$$lexHashEndifMustBeFirst = SR$$$lexHashEndifMustBeFirst;
exports.SR$$$lexHashIfMustHaveIdent = SR$$$lexHashIfMustHaveIdent;
exports.SR$$$lexWrongNestedHashEndif = SR$$$lexWrongNestedHashEndif;
exports.SR$$$lexHashBangMustBeFirstInFile = SR$$$lexHashBangMustBeFirstInFile;
exports.SR$$$pplexExpectedSingleLineComment = SR$$$pplexExpectedSingleLineComment;
exports.SR$$$memberOperatorDefinitionWithNoArguments$$Z721C83C5 = SR$$$memberOperatorDefinitionWithNoArguments$$Z721C83C5;
exports.SR$$$memberOperatorDefinitionWithNonPairArgument$$Z18115A39 = SR$$$memberOperatorDefinitionWithNonPairArgument$$Z18115A39;
exports.SR$$$memberOperatorDefinitionWithCurriedArguments$$Z721C83C5 = SR$$$memberOperatorDefinitionWithCurriedArguments$$Z721C83C5;
exports.SR$$$tcFSharpCoreRequiresExplicit = SR$$$tcFSharpCoreRequiresExplicit;
exports.SR$$$tcStructuralComparisonNotSatisfied1$$Z384F8060 = SR$$$tcStructuralComparisonNotSatisfied1$$Z384F8060;
exports.SR$$$tcStructuralComparisonNotSatisfied2$$Z384F8060 = SR$$$tcStructuralComparisonNotSatisfied2$$Z384F8060;
exports.SR$$$tcNoComparisonNeeded1$$30230F9B = SR$$$tcNoComparisonNeeded1$$30230F9B;
exports.SR$$$tcNoComparisonNeeded2$$30230F9B = SR$$$tcNoComparisonNeeded2$$30230F9B;
exports.SR$$$tcNoEqualityNeeded1$$30230F9B = SR$$$tcNoEqualityNeeded1$$30230F9B;
exports.SR$$$tcNoEqualityNeeded2$$30230F9B = SR$$$tcNoEqualityNeeded2$$30230F9B;
exports.SR$$$tcStructuralEqualityNotSatisfied1$$Z384F8060 = SR$$$tcStructuralEqualityNotSatisfied1$$Z384F8060;
exports.SR$$$tcStructuralEqualityNotSatisfied2$$Z384F8060 = SR$$$tcStructuralEqualityNotSatisfied2$$Z384F8060;
exports.SR$$$tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly = SR$$$tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly;
exports.SR$$$chkUnusedValue$$Z721C83C5 = SR$$$chkUnusedValue$$Z721C83C5;
exports.SR$$$chkUnusedThisVariable$$Z721C83C5 = SR$$$chkUnusedThisVariable$$Z721C83C5;
exports.SR$$$parsGetterAtMostOneArgument = SR$$$parsGetterAtMostOneArgument;
exports.SR$$$parsSetterAtMostTwoArguments = SR$$$parsSetterAtMostTwoArguments;
exports.SR$$$parsInvalidProperty = SR$$$parsInvalidProperty;
exports.SR$$$parsIndexerPropertyRequiresAtLeastOneArgument = SR$$$parsIndexerPropertyRequiresAtLeastOneArgument;
exports.SR$$$tastInvalidAddressOfMutableAcrossAssemblyBoundary = SR$$$tastInvalidAddressOfMutableAcrossAssemblyBoundary;
exports.SR$$$parsNonAdjacentTypars = SR$$$parsNonAdjacentTypars;
exports.SR$$$parsNonAdjacentTyargs = SR$$$parsNonAdjacentTyargs;
exports.SR$$$parsNonAtomicType = SR$$$parsNonAtomicType;
exports.SR$$$tastUndefinedItemRefModuleNamespace$$30230F9B = SR$$$tastUndefinedItemRefModuleNamespace$$30230F9B;
exports.SR$$$tastUndefinedItemRefVal$$30230F9B = SR$$$tastUndefinedItemRefVal$$30230F9B;
exports.SR$$$tastUndefinedItemRefModuleNamespaceType$$30230F9B = SR$$$tastUndefinedItemRefModuleNamespaceType$$30230F9B;
exports.SR$$$tcInvalidUseNullAsTrueValue = SR$$$tcInvalidUseNullAsTrueValue;
exports.SR$$$tcParameterInferredByref$$Z721C83C5 = SR$$$tcParameterInferredByref$$Z721C83C5;
exports.SR$$$tcNonUniformMemberUse$$Z721C83C5 = SR$$$tcNonUniformMemberUse$$Z721C83C5;
exports.SR$$$tcAttribArgsDiffer$$Z721C83C5 = SR$$$tcAttribArgsDiffer$$Z721C83C5;
exports.SR$$$tcCannotCallAbstractBaseMember$$Z721C83C5 = SR$$$tcCannotCallAbstractBaseMember$$Z721C83C5;
exports.SR$$$typrelCannotResolveAmbiguityInUnmanaged = SR$$$typrelCannotResolveAmbiguityInUnmanaged;
exports.SR$$$mlCompatMessage$$Z721C83C5 = SR$$$mlCompatMessage$$Z721C83C5;
exports.SR$$$ilFieldDoesNotHaveValidOffsetForStructureLayout$$Z384F8060 = SR$$$ilFieldDoesNotHaveValidOffsetForStructureLayout$$Z384F8060;
exports.SR$$$tcInterfacesShouldUseInheritNotInterface = SR$$$tcInterfacesShouldUseInheritNotInterface;
exports.SR$$$parsInvalidPrefixOperator = SR$$$parsInvalidPrefixOperator;
exports.SR$$$parsInvalidPrefixOperatorDefinition = SR$$$parsInvalidPrefixOperatorDefinition;
exports.SR$$$buildCompilingExtensionIsForML = SR$$$buildCompilingExtensionIsForML;
exports.SR$$$lexIndentOffForML = SR$$$lexIndentOffForML;
exports.SR$$$activePatternIdentIsNotFunctionTyped$$Z721C83C5 = SR$$$activePatternIdentIsNotFunctionTyped$$Z721C83C5;
exports.SR$$$activePatternChoiceHasFreeTypars$$Z721C83C5 = SR$$$activePatternChoiceHasFreeTypars$$Z721C83C5;
exports.SR$$$ilFieldHasOffsetForSequentialLayout = SR$$$ilFieldHasOffsetForSequentialLayout;
exports.SR$$$tcOptionalArgsMustComeAfterNonOptionalArgs = SR$$$tcOptionalArgsMustComeAfterNonOptionalArgs;
exports.SR$$$tcConditionalAttributeUsage = SR$$$tcConditionalAttributeUsage;
exports.SR$$$tcMemberOperatorDefinitionInExtrinsic = SR$$$tcMemberOperatorDefinitionInExtrinsic;
exports.SR$$$ilwriteMDBFileNameCannotBeChangedWarning = SR$$$ilwriteMDBFileNameCannotBeChangedWarning;
exports.SR$$$ilwriteMDBMemberMissing$$Z721C83C5 = SR$$$ilwriteMDBMemberMissing$$Z721C83C5;
exports.SR$$$ilwriteErrorCreatingMdb = SR$$$ilwriteErrorCreatingMdb;
exports.SR$$$tcUnionCaseNameConflictsWithGeneratedType$$Z384F8060 = SR$$$tcUnionCaseNameConflictsWithGeneratedType$$Z384F8060;
exports.SR$$$chkNoReflectedDefinitionOnStructMember = SR$$$chkNoReflectedDefinitionOnStructMember;
exports.SR$$$tcDllImportNotAllowed = SR$$$tcDllImportNotAllowed;
exports.SR$$$buildExplicitCoreLibRequiresNoFramework$$Z721C83C5 = SR$$$buildExplicitCoreLibRequiresNoFramework$$Z721C83C5;
exports.SR$$$buildExpectedSigdataFile$$Z721C83C5 = SR$$$buildExpectedSigdataFile$$Z721C83C5;
exports.SR$$$buildExpectedFileAlongSideFSharpCore$$Z384F8060 = SR$$$buildExpectedFileAlongSideFSharpCore$$Z384F8060;
exports.SR$$$buildUnexpectedFileNameCharacter$$Z384F8060 = SR$$$buildUnexpectedFileNameCharacter$$Z384F8060;
exports.SR$$$tcInvalidUseBangBinding = SR$$$tcInvalidUseBangBinding;
exports.SR$$$crefNoInnerGenericsInQuotations = SR$$$crefNoInnerGenericsInQuotations;
exports.SR$$$tcEnumTypeCannotBeEnumerated$$Z721C83C5 = SR$$$tcEnumTypeCannotBeEnumerated$$Z721C83C5;
exports.SR$$$parsEofInTripleQuoteString = SR$$$parsEofInTripleQuoteString;
exports.SR$$$parsEofInTripleQuoteStringInComment = SR$$$parsEofInTripleQuoteStringInComment;
exports.SR$$$tcTypeTestLosesMeasures$$Z721C83C5 = SR$$$tcTypeTestLosesMeasures$$Z721C83C5;
exports.SR$$$parsMissingTypeArgs = SR$$$parsMissingTypeArgs;
exports.SR$$$parsMissingGreaterThan = SR$$$parsMissingGreaterThan;
exports.SR$$$parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString = SR$$$parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString;
exports.SR$$$parsErrorParsingAsOperatorName = SR$$$parsErrorParsingAsOperatorName;
exports.SR$$$lexInvalidUnicodeLiteral$$Z721C83C5 = SR$$$lexInvalidUnicodeLiteral$$Z721C83C5;
exports.SR$$$tcCallerInfoWrongType$$30230F9B = SR$$$tcCallerInfoWrongType$$30230F9B;
exports.SR$$$tcCallerInfoNotOptional$$Z721C83C5 = SR$$$tcCallerInfoNotOptional$$Z721C83C5;
exports.SR$$$toolLocationHelperUnsupportedFrameworkVersion$$Z721C83C5 = SR$$$toolLocationHelperUnsupportedFrameworkVersion$$Z721C83C5;
exports.SR$$$ilSignInvalidMagicValue = SR$$$ilSignInvalidMagicValue;
exports.SR$$$ilSignBadImageFormat = SR$$$ilSignBadImageFormat;
exports.SR$$$ilSignPrivateKeyExpected = SR$$$ilSignPrivateKeyExpected;
exports.SR$$$ilSignRsaKeyExpected = SR$$$ilSignRsaKeyExpected;
exports.SR$$$ilSignInvalidBitLen = SR$$$ilSignInvalidBitLen;
exports.SR$$$ilSignInvalidRSAParams = SR$$$ilSignInvalidRSAParams;
exports.SR$$$ilSignInvalidAlgId = SR$$$ilSignInvalidAlgId;
exports.SR$$$ilSignInvalidSignatureSize = SR$$$ilSignInvalidSignatureSize;
exports.SR$$$ilSignNoSignatureDirectory = SR$$$ilSignNoSignatureDirectory;
exports.SR$$$ilSignInvalidPKBlob = SR$$$ilSignInvalidPKBlob;
exports.SR$$$fscTooManyErrors = SR$$$fscTooManyErrors;
exports.SR$$$docfileNoXmlSuffix = SR$$$docfileNoXmlSuffix;
exports.SR$$$fscNoImplementationFiles = SR$$$fscNoImplementationFiles;
exports.SR$$$fscBadAssemblyVersion$$Z384F8060 = SR$$$fscBadAssemblyVersion$$Z384F8060;
exports.SR$$$fscTwoResourceManifests = SR$$$fscTwoResourceManifests;
exports.SR$$$fscQuotationLiteralsStaticLinking$$Z721C83C5 = SR$$$fscQuotationLiteralsStaticLinking$$Z721C83C5;
exports.SR$$$fscQuotationLiteralsStaticLinking0 = SR$$$fscQuotationLiteralsStaticLinking0;
exports.SR$$$fscStaticLinkingNoEXE = SR$$$fscStaticLinkingNoEXE;
exports.SR$$$fscStaticLinkingNoMixedDLL = SR$$$fscStaticLinkingNoMixedDLL;
exports.SR$$$fscIgnoringMixedWhenLinking$$Z721C83C5 = SR$$$fscIgnoringMixedWhenLinking$$Z721C83C5;
exports.SR$$$fscAssumeStaticLinkContainsNoDependencies$$Z721C83C5 = SR$$$fscAssumeStaticLinkContainsNoDependencies$$Z721C83C5;
exports.SR$$$fscAssemblyNotFoundInDependencySet$$Z721C83C5 = SR$$$fscAssemblyNotFoundInDependencySet$$Z721C83C5;
exports.SR$$$fscKeyFileCouldNotBeOpened$$Z721C83C5 = SR$$$fscKeyFileCouldNotBeOpened$$Z721C83C5;
exports.SR$$$fscProblemWritingBinary$$Z384F8060 = SR$$$fscProblemWritingBinary$$Z384F8060;
exports.SR$$$fscAssemblyVersionAttributeIgnored = SR$$$fscAssemblyVersionAttributeIgnored;
exports.SR$$$fscAssemblyCultureAttributeError = SR$$$fscAssemblyCultureAttributeError;
exports.SR$$$fscDelaySignWarning = SR$$$fscDelaySignWarning;
exports.SR$$$fscKeyFileWarning = SR$$$fscKeyFileWarning;
exports.SR$$$fscKeyNameWarning = SR$$$fscKeyNameWarning;
exports.SR$$$fscReferenceOnCommandLine$$Z721C83C5 = SR$$$fscReferenceOnCommandLine$$Z721C83C5;
exports.SR$$$fscRemotingError = SR$$$fscRemotingError;
exports.SR$$$pathIsInvalid$$Z721C83C5 = SR$$$pathIsInvalid$$Z721C83C5;
exports.SR$$$fscResxSourceFileDeprecated$$Z721C83C5 = SR$$$fscResxSourceFileDeprecated$$Z721C83C5;
exports.SR$$$fscStaticLinkingNoProfileMismatches = SR$$$fscStaticLinkingNoProfileMismatches;
exports.SR$$$fscAssemblyWildcardAndDeterminism$$Z384F8060 = SR$$$fscAssemblyWildcardAndDeterminism$$Z384F8060;
exports.SR$$$fscDeterministicDebugRequiresPortablePdb = SR$$$fscDeterministicDebugRequiresPortablePdb;
exports.SR$$$etIllegalCharactersInNamespaceName$$Z384F8060 = SR$$$etIllegalCharactersInNamespaceName$$Z384F8060;
exports.SR$$$etNullOrEmptyMemberName$$Z721C83C5 = SR$$$etNullOrEmptyMemberName$$Z721C83C5;
exports.SR$$$etNullMember$$Z721C83C5 = SR$$$etNullMember$$Z721C83C5;
exports.SR$$$etNullMemberDeclaringType$$Z384F8060 = SR$$$etNullMemberDeclaringType$$Z384F8060;
exports.SR$$$etNullMemberDeclaringTypeDifferentFromProvidedType$$30230F9B = SR$$$etNullMemberDeclaringTypeDifferentFromProvidedType$$30230F9B;
exports.SR$$$etHostingAssemblyFoundWithoutHosts$$Z384F8060 = SR$$$etHostingAssemblyFoundWithoutHosts$$Z384F8060;
exports.SR$$$etEmptyNamespaceOfTypeNotAllowed$$Z384F8060 = SR$$$etEmptyNamespaceOfTypeNotAllowed$$Z384F8060;
exports.SR$$$etEmptyNamespaceNotAllowed$$Z721C83C5 = SR$$$etEmptyNamespaceNotAllowed$$Z721C83C5;
exports.SR$$$etMustNotBeGeneric$$Z721C83C5 = SR$$$etMustNotBeGeneric$$Z721C83C5;
exports.SR$$$etMustNotBeAnArray$$Z721C83C5 = SR$$$etMustNotBeAnArray$$Z721C83C5;
exports.SR$$$etMethodHasRequirements$$Z384F8060 = SR$$$etMethodHasRequirements$$Z384F8060;
exports.SR$$$etUnsupportedMemberKind$$Z384F8060 = SR$$$etUnsupportedMemberKind$$Z384F8060;
exports.SR$$$etPropertyCanReadButHasNoGetter$$Z384F8060 = SR$$$etPropertyCanReadButHasNoGetter$$Z384F8060;
exports.SR$$$etPropertyHasGetterButNoCanRead$$Z384F8060 = SR$$$etPropertyHasGetterButNoCanRead$$Z384F8060;
exports.SR$$$etPropertyCanWriteButHasNoSetter$$Z384F8060 = SR$$$etPropertyCanWriteButHasNoSetter$$Z384F8060;
exports.SR$$$etPropertyHasSetterButNoCanWrite$$Z384F8060 = SR$$$etPropertyHasSetterButNoCanWrite$$Z384F8060;
exports.SR$$$etOneOrMoreErrorsSeenDuringExtensionTypeSetting = SR$$$etOneOrMoreErrorsSeenDuringExtensionTypeSetting;
exports.SR$$$etUnexpectedExceptionFromProvidedTypeMember$$30230F9B = SR$$$etUnexpectedExceptionFromProvidedTypeMember$$30230F9B;
exports.SR$$$etUnsupportedConstantType$$Z721C83C5 = SR$$$etUnsupportedConstantType$$Z721C83C5;
exports.SR$$$etUnsupportedProvidedExpression$$Z721C83C5 = SR$$$etUnsupportedProvidedExpression$$Z721C83C5;
exports.SR$$$etProvidedTypeHasUnexpectedName$$Z384F8060 = SR$$$etProvidedTypeHasUnexpectedName$$Z384F8060;
exports.SR$$$etEventNoAdd$$Z384F8060 = SR$$$etEventNoAdd$$Z384F8060;
exports.SR$$$etEventNoRemove$$Z384F8060 = SR$$$etEventNoRemove$$Z384F8060;
exports.SR$$$etProviderHasWrongDesignerAssembly$$30230F9B = SR$$$etProviderHasWrongDesignerAssembly$$30230F9B;
exports.SR$$$etProviderDoesNotHaveValidConstructor = SR$$$etProviderDoesNotHaveValidConstructor;
exports.SR$$$etProviderError$$Z384F8060 = SR$$$etProviderError$$Z384F8060;
exports.SR$$$etIncorrectParameterExpression$$Z384F8060 = SR$$$etIncorrectParameterExpression$$Z384F8060;
exports.SR$$$etIncorrectProvidedMethod$$Z522416B9 = SR$$$etIncorrectProvidedMethod$$Z522416B9;
exports.SR$$$etIncorrectProvidedConstructor$$Z384F8060 = SR$$$etIncorrectProvidedConstructor$$Z384F8060;
exports.SR$$$etDirectReferenceToGeneratedTypeNotAllowed$$Z721C83C5 = SR$$$etDirectReferenceToGeneratedTypeNotAllowed$$Z721C83C5;
exports.SR$$$etProvidedTypeHasUnexpectedPath$$Z384F8060 = SR$$$etProvidedTypeHasUnexpectedPath$$Z384F8060;
exports.SR$$$etUnexpectedNullFromProvidedTypeMember$$Z384F8060 = SR$$$etUnexpectedNullFromProvidedTypeMember$$Z384F8060;
exports.SR$$$etUnexpectedExceptionFromProvidedMemberMember$$Z46998140 = SR$$$etUnexpectedExceptionFromProvidedMemberMember$$Z46998140;
exports.SR$$$etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters = SR$$$etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters;
exports.SR$$$etInvalidStaticArgument$$Z721C83C5 = SR$$$etInvalidStaticArgument$$Z721C83C5;
exports.SR$$$etErrorApplyingStaticArgumentsToType = SR$$$etErrorApplyingStaticArgumentsToType;
exports.SR$$$etUnknownStaticArgumentKind$$Z384F8060 = SR$$$etUnknownStaticArgumentKind$$Z384F8060;
exports.SR$$$invalidNamespaceForProvidedType = SR$$$invalidNamespaceForProvidedType;
exports.SR$$$invalidFullNameForProvidedType = SR$$$invalidFullNameForProvidedType;
exports.SR$$$etProviderReturnedNull$$Z721C83C5 = SR$$$etProviderReturnedNull$$Z721C83C5;
exports.SR$$$etTypeProviderConstructorException$$Z721C83C5 = SR$$$etTypeProviderConstructorException$$Z721C83C5;
exports.SR$$$etNullProvidedExpression$$Z721C83C5 = SR$$$etNullProvidedExpression$$Z721C83C5;
exports.SR$$$etProvidedAppliedTypeHadWrongName$$30230F9B = SR$$$etProvidedAppliedTypeHadWrongName$$30230F9B;
exports.SR$$$etProvidedAppliedMethodHadWrongName$$30230F9B = SR$$$etProvidedAppliedMethodHadWrongName$$30230F9B;
exports.SR$$$tcTypeTestLossy$$Z384F8060 = SR$$$tcTypeTestLossy$$Z384F8060;
exports.SR$$$tcTypeCastErased$$Z384F8060 = SR$$$tcTypeCastErased$$Z384F8060;
exports.SR$$$tcTypeTestErased$$Z384F8060 = SR$$$tcTypeTestErased$$Z384F8060;
exports.SR$$$tcCannotInheritFromErasedType = SR$$$tcCannotInheritFromErasedType;
exports.SR$$$etInvalidTypeProviderAssemblyName$$Z384F8060 = SR$$$etInvalidTypeProviderAssemblyName$$Z384F8060;
exports.SR$$$tcInvalidMemberNameCtor = SR$$$tcInvalidMemberNameCtor;
exports.SR$$$tcInferredGenericTypeGivesRiseToInconsistency$$Z384F8060 = SR$$$tcInferredGenericTypeGivesRiseToInconsistency$$Z384F8060;
exports.SR$$$tcInvalidTypeArgumentCount$$Z37302880 = SR$$$tcInvalidTypeArgumentCount$$Z37302880;
exports.SR$$$tcCannotOverrideSealedMethod$$Z721C83C5 = SR$$$tcCannotOverrideSealedMethod$$Z721C83C5;
exports.SR$$$etProviderErrorWithContext$$Z46998140 = SR$$$etProviderErrorWithContext$$Z46998140;
exports.SR$$$etProvidedTypeWithNameException$$Z384F8060 = SR$$$etProvidedTypeWithNameException$$Z384F8060;
exports.SR$$$etProvidedTypeWithNullOrEmptyName$$Z721C83C5 = SR$$$etProvidedTypeWithNullOrEmptyName$$Z721C83C5;
exports.SR$$$etIllegalCharactersInTypeName$$Z384F8060 = SR$$$etIllegalCharactersInTypeName$$Z384F8060;
exports.SR$$$tcJoinMustUseSimplePattern$$Z721C83C5 = SR$$$tcJoinMustUseSimplePattern$$Z721C83C5;
exports.SR$$$tcMissingCustomOperation$$Z721C83C5 = SR$$$tcMissingCustomOperation$$Z721C83C5;
exports.SR$$$etBadUnnamedStaticArgs = SR$$$etBadUnnamedStaticArgs;
exports.SR$$$etStaticParameterRequiresAValue$$Z46998140 = SR$$$etStaticParameterRequiresAValue$$Z46998140;
exports.SR$$$etNoStaticParameterWithName$$Z721C83C5 = SR$$$etNoStaticParameterWithName$$Z721C83C5;
exports.SR$$$etStaticParameterAlreadyHasValue$$Z721C83C5 = SR$$$etStaticParameterAlreadyHasValue$$Z721C83C5;
exports.SR$$$etMultipleStaticParameterWithName$$Z721C83C5 = SR$$$etMultipleStaticParameterWithName$$Z721C83C5;
exports.SR$$$tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings = SR$$$tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings;
exports.SR$$$tcCustomOperationMayNotBeUsedHere = SR$$$tcCustomOperationMayNotBeUsedHere;
exports.SR$$$tcCustomOperationMayNotBeOverloaded$$Z721C83C5 = SR$$$tcCustomOperationMayNotBeOverloaded$$Z721C83C5;
exports.SR$$$tcIfThenElseMayNotBeUsedWithinQueries = SR$$$tcIfThenElseMayNotBeUsedWithinQueries;
exports.SR$$$ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen = SR$$$ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen;
exports.SR$$$etProvidedTypeReferenceMissingArgument$$Z721C83C5 = SR$$$etProvidedTypeReferenceMissingArgument$$Z721C83C5;
exports.SR$$$etProvidedTypeReferenceInvalidText$$Z721C83C5 = SR$$$etProvidedTypeReferenceInvalidText$$Z721C83C5;
exports.SR$$$tcCustomOperationNotUsedCorrectly$$Z721C83C5 = SR$$$tcCustomOperationNotUsedCorrectly$$Z721C83C5;
exports.SR$$$tcCustomOperationNotUsedCorrectly2$$Z384F8060 = SR$$$tcCustomOperationNotUsedCorrectly2$$Z384F8060;
exports.SR$$$customOperationTextLikeJoin$$30230F9B = SR$$$customOperationTextLikeJoin$$30230F9B;
exports.SR$$$customOperationTextLikeGroupJoin$$30230F9B = SR$$$customOperationTextLikeGroupJoin$$30230F9B;
exports.SR$$$customOperationTextLikeZip$$Z721C83C5 = SR$$$customOperationTextLikeZip$$Z721C83C5;
exports.SR$$$tcBinaryOperatorRequiresVariable$$Z384F8060 = SR$$$tcBinaryOperatorRequiresVariable$$Z384F8060;
exports.SR$$$tcOperatorIncorrectSyntax$$Z384F8060 = SR$$$tcOperatorIncorrectSyntax$$Z384F8060;
exports.SR$$$tcBinaryOperatorRequiresBody$$Z384F8060 = SR$$$tcBinaryOperatorRequiresBody$$Z384F8060;
exports.SR$$$tcCustomOperationHasIncorrectArgCount$$487EF8FB = SR$$$tcCustomOperationHasIncorrectArgCount$$487EF8FB;
exports.SR$$$parsExpectedExpressionAfterToken = SR$$$parsExpectedExpressionAfterToken;
exports.SR$$$parsExpectedTypeAfterToken = SR$$$parsExpectedTypeAfterToken;
exports.SR$$$parsUnmatchedLBrackLess = SR$$$parsUnmatchedLBrackLess;
exports.SR$$$parsUnexpectedEndOfFileMatch = SR$$$parsUnexpectedEndOfFileMatch;
exports.SR$$$parsUnexpectedEndOfFileTry = SR$$$parsUnexpectedEndOfFileTry;
exports.SR$$$parsUnexpectedEndOfFileWhile = SR$$$parsUnexpectedEndOfFileWhile;
exports.SR$$$parsUnexpectedEndOfFileFor = SR$$$parsUnexpectedEndOfFileFor;
exports.SR$$$parsUnexpectedEndOfFileWith = SR$$$parsUnexpectedEndOfFileWith;
exports.SR$$$parsUnexpectedEndOfFileThen = SR$$$parsUnexpectedEndOfFileThen;
exports.SR$$$parsUnexpectedEndOfFileElse = SR$$$parsUnexpectedEndOfFileElse;
exports.SR$$$parsUnexpectedEndOfFileFunBody = SR$$$parsUnexpectedEndOfFileFunBody;
exports.SR$$$parsUnexpectedEndOfFileTypeArgs = SR$$$parsUnexpectedEndOfFileTypeArgs;
exports.SR$$$parsUnexpectedEndOfFileTypeSignature = SR$$$parsUnexpectedEndOfFileTypeSignature;
exports.SR$$$parsUnexpectedEndOfFileTypeDefinition = SR$$$parsUnexpectedEndOfFileTypeDefinition;
exports.SR$$$parsUnexpectedEndOfFileObjectMembers = SR$$$parsUnexpectedEndOfFileObjectMembers;
exports.SR$$$parsUnexpectedEndOfFileDefinition = SR$$$parsUnexpectedEndOfFileDefinition;
exports.SR$$$parsUnexpectedEndOfFileExpression = SR$$$parsUnexpectedEndOfFileExpression;
exports.SR$$$parsExpectedNameAfterToken = SR$$$parsExpectedNameAfterToken;
exports.SR$$$parsUnmatchedLet = SR$$$parsUnmatchedLet;
exports.SR$$$parsUnmatchedLetBang = SR$$$parsUnmatchedLetBang;
exports.SR$$$parsUnmatchedUseBang = SR$$$parsUnmatchedUseBang;
exports.SR$$$parsUnmatchedUse = SR$$$parsUnmatchedUse;
exports.SR$$$parsWhileDoExpected = SR$$$parsWhileDoExpected;
exports.SR$$$parsForDoExpected = SR$$$parsForDoExpected;
exports.SR$$$tcInvalidRelationInJoin$$Z721C83C5 = SR$$$tcInvalidRelationInJoin$$Z721C83C5;
exports.SR$$$typeInfoCallsWord = SR$$$typeInfoCallsWord;
exports.SR$$$impInvalidNumberOfGenericArguments$$487EF8FB = SR$$$impInvalidNumberOfGenericArguments$$487EF8FB;
exports.SR$$$impInvalidMeasureArgument1$$Z384F8060 = SR$$$impInvalidMeasureArgument1$$Z384F8060;
exports.SR$$$impInvalidMeasureArgument2$$Z721C83C5 = SR$$$impInvalidMeasureArgument2$$Z721C83C5;
exports.SR$$$etPropertyNeedsCanWriteOrCanRead$$Z384F8060 = SR$$$etPropertyNeedsCanWriteOrCanRead$$Z384F8060;
exports.SR$$$tcIntoNeedsRestOfQuery = SR$$$tcIntoNeedsRestOfQuery;
exports.SR$$$tcOperatorDoesntAcceptInto$$Z721C83C5 = SR$$$tcOperatorDoesntAcceptInto$$Z721C83C5;
exports.SR$$$tcCustomOperationInvalid$$Z721C83C5 = SR$$$tcCustomOperationInvalid$$Z721C83C5;
exports.SR$$$tcThisTypeMayNotHaveACLIMutableAttribute = SR$$$tcThisTypeMayNotHaveACLIMutableAttribute;
exports.SR$$$tcAutoPropertyRequiresImplicitConstructionSequence = SR$$$tcAutoPropertyRequiresImplicitConstructionSequence;
exports.SR$$$parsMutableOnAutoPropertyShouldBeGetSet = SR$$$parsMutableOnAutoPropertyShouldBeGetSet;
exports.SR$$$parsMutableOnAutoPropertyShouldBeGetSetNotJustSet = SR$$$parsMutableOnAutoPropertyShouldBeGetSetNotJustSet;
exports.SR$$$chkNoByrefsOfByrefs$$Z721C83C5 = SR$$$chkNoByrefsOfByrefs$$Z721C83C5;
exports.SR$$$tastopsMaxArrayThirtyTwo$$Z524259A4 = SR$$$tastopsMaxArrayThirtyTwo$$Z524259A4;
exports.SR$$$tcNoIntegerForLoopInQuery = SR$$$tcNoIntegerForLoopInQuery;
exports.SR$$$tcNoWhileInQuery = SR$$$tcNoWhileInQuery;
exports.SR$$$tcNoTryFinallyInQuery = SR$$$tcNoTryFinallyInQuery;
exports.SR$$$tcUseMayNotBeUsedInQueries = SR$$$tcUseMayNotBeUsedInQueries;
exports.SR$$$tcBindMayNotBeUsedInQueries = SR$$$tcBindMayNotBeUsedInQueries;
exports.SR$$$tcReturnMayNotBeUsedInQueries = SR$$$tcReturnMayNotBeUsedInQueries;
exports.SR$$$tcUnrecognizedQueryOperator = SR$$$tcUnrecognizedQueryOperator;
exports.SR$$$tcTryWithMayNotBeUsedInQueries = SR$$$tcTryWithMayNotBeUsedInQueries;
exports.SR$$$tcNonSimpleLetBindingInQuery = SR$$$tcNonSimpleLetBindingInQuery;
exports.SR$$$etTooManyStaticParameters$$4F7761DC = SR$$$etTooManyStaticParameters$$4F7761DC;
exports.SR$$$infosInvalidProvidedLiteralValue$$Z721C83C5 = SR$$$infosInvalidProvidedLiteralValue$$Z721C83C5;
exports.SR$$$invalidPlatformTarget = SR$$$invalidPlatformTarget;
exports.SR$$$tcThisValueMayNotBeInlined = SR$$$tcThisValueMayNotBeInlined;
exports.SR$$$etErasedTypeUsedInGeneration$$Z384F8060 = SR$$$etErasedTypeUsedInGeneration$$Z384F8060;
exports.SR$$$tcUnrecognizedQueryBinaryOperator = SR$$$tcUnrecognizedQueryBinaryOperator;
exports.SR$$$crefNoSetOfHole = SR$$$crefNoSetOfHole;
exports.SR$$$nicePrintOtherOverloads1 = SR$$$nicePrintOtherOverloads1;
exports.SR$$$nicePrintOtherOverloadsN$$Z524259A4 = SR$$$nicePrintOtherOverloadsN$$Z524259A4;
exports.SR$$$erasedTo = SR$$$erasedTo;
exports.SR$$$parsUnfinishedExpression$$Z721C83C5 = SR$$$parsUnfinishedExpression$$Z721C83C5;
exports.SR$$$parsAttributeOnIncompleteCode = SR$$$parsAttributeOnIncompleteCode;
exports.SR$$$parsTypeNameCannotBeEmpty = SR$$$parsTypeNameCannotBeEmpty;
exports.SR$$$buildProblemReadingAssembly$$Z384F8060 = SR$$$buildProblemReadingAssembly$$Z384F8060;
exports.SR$$$tcTPFieldMustBeLiteral = SR$$$tcTPFieldMustBeLiteral;
exports.SR$$$loadingDescription = SR$$$loadingDescription;
exports.SR$$$descriptionUnavailable = SR$$$descriptionUnavailable;
exports.SR$$$chkTyparMultipleClassConstraints = SR$$$chkTyparMultipleClassConstraints;
exports.SR$$$tcMatchMayNotBeUsedWithQuery = SR$$$tcMatchMayNotBeUsedWithQuery;
exports.SR$$$memberOperatorDefinitionWithNonTripleArgument$$Z18115A39 = SR$$$memberOperatorDefinitionWithNonTripleArgument$$Z18115A39;
exports.SR$$$cannotResolveNullableOperators$$Z721C83C5 = SR$$$cannotResolveNullableOperators$$Z721C83C5;
exports.SR$$$tcOperatorRequiresIn$$Z384F8060 = SR$$$tcOperatorRequiresIn$$Z384F8060;
exports.SR$$$parsIllegalMemberVarInObjectImplementation = SR$$$parsIllegalMemberVarInObjectImplementation;
exports.SR$$$tcEmptyCopyAndUpdateRecordInvalid = SR$$$tcEmptyCopyAndUpdateRecordInvalid;
exports.SR$$$parsUnderscoreInvalidFieldName = SR$$$parsUnderscoreInvalidFieldName;
exports.SR$$$tcGeneratedTypesShouldBeInternalOrPrivate = SR$$$tcGeneratedTypesShouldBeInternalOrPrivate;
exports.SR$$$chkGetterAndSetterHaveSamePropertyType$$30230F9B = SR$$$chkGetterAndSetterHaveSamePropertyType$$30230F9B;
exports.SR$$$tcRuntimeSuppliedMethodCannotBeUsedInUserCode$$Z721C83C5 = SR$$$tcRuntimeSuppliedMethodCannotBeUsedInUserCode$$Z721C83C5;
exports.SR$$$tcUnionCaseConstructorDoesNotHaveFieldWithGivenName$$Z384F8060 = SR$$$tcUnionCaseConstructorDoesNotHaveFieldWithGivenName$$Z384F8060;
exports.SR$$$tcUnionCaseFieldCannotBeUsedMoreThanOnce$$Z721C83C5 = SR$$$tcUnionCaseFieldCannotBeUsedMoreThanOnce$$Z721C83C5;
exports.SR$$$tcFieldNameIsUsedModeThanOnce$$Z721C83C5 = SR$$$tcFieldNameIsUsedModeThanOnce$$Z721C83C5;
exports.SR$$$tcFieldNameConflictsWithGeneratedNameForAnonymousField$$Z721C83C5 = SR$$$tcFieldNameConflictsWithGeneratedNameForAnonymousField$$Z721C83C5;
exports.SR$$$tastConstantExpressionOverflow = SR$$$tastConstantExpressionOverflow;
exports.SR$$$tcIllegalStructTypeForConstantExpression = SR$$$tcIllegalStructTypeForConstantExpression;
exports.SR$$$fscSystemRuntimeInteropServicesIsRequired = SR$$$fscSystemRuntimeInteropServicesIsRequired;
exports.SR$$$abImplicitHeapAllocation$$Z721C83C5 = SR$$$abImplicitHeapAllocation$$Z721C83C5;
exports.SR$$$estApplyStaticArgumentsForMethodNotImplemented = SR$$$estApplyStaticArgumentsForMethodNotImplemented;
exports.SR$$$etErrorApplyingStaticArgumentsToMethod = SR$$$etErrorApplyingStaticArgumentsToMethod;
exports.SR$$$pplexUnexpectedChar$$Z721C83C5 = SR$$$pplexUnexpectedChar$$Z721C83C5;
exports.SR$$$ppparsUnexpectedToken$$Z721C83C5 = SR$$$ppparsUnexpectedToken$$Z721C83C5;
exports.SR$$$ppparsIncompleteExpression = SR$$$ppparsIncompleteExpression;
exports.SR$$$ppparsMissingToken$$Z721C83C5 = SR$$$ppparsMissingToken$$Z721C83C5;
exports.SR$$$pickleMissingDefinition$$7751B6FC = SR$$$pickleMissingDefinition$$7751B6FC;
exports.SR$$$checkNotSufficientlyGenericBecauseOfScope$$Z721C83C5 = SR$$$checkNotSufficientlyGenericBecauseOfScope$$Z721C83C5;
exports.SR$$$checkNotSufficientlyGenericBecauseOfScopeAnon = SR$$$checkNotSufficientlyGenericBecauseOfScopeAnon;
exports.SR$$$checkRaiseFamilyFunctionArgumentCount$$487EF8FB = SR$$$checkRaiseFamilyFunctionArgumentCount$$487EF8FB;
exports.SR$$$checkLowercaseLiteralBindingInPattern$$Z721C83C5 = SR$$$checkLowercaseLiteralBindingInPattern$$Z721C83C5;
exports.SR$$$tcLiteralDoesNotTakeArguments = SR$$$tcLiteralDoesNotTakeArguments;
exports.SR$$$tcConstructorsIllegalInAugmentation = SR$$$tcConstructorsIllegalInAugmentation;
exports.SR$$$optsInvalidResponseFile$$Z384F8060 = SR$$$optsInvalidResponseFile$$Z384F8060;
exports.SR$$$optsResponseFileNotFound$$Z384F8060 = SR$$$optsResponseFileNotFound$$Z384F8060;
exports.SR$$$optsResponseFileNameInvalid$$Z721C83C5 = SR$$$optsResponseFileNameInvalid$$Z721C83C5;
exports.SR$$$fsharpCoreNotFoundToBeCopied = SR$$$fsharpCoreNotFoundToBeCopied;
exports.SR$$$tcTupleStructMismatch = SR$$$tcTupleStructMismatch;
exports.SR$$$etMissingStaticArgumentsToMethod = SR$$$etMissingStaticArgumentsToMethod;
exports.SR$$$considerUpcast$$Z384F8060 = SR$$$considerUpcast$$Z384F8060;
exports.SR$$$considerUpcastOperator$$Z384F8060 = SR$$$considerUpcastOperator$$Z384F8060;
exports.SR$$$tcRecImplied = SR$$$tcRecImplied;
exports.SR$$$tcOpenFirstInMutRec = SR$$$tcOpenFirstInMutRec;
exports.SR$$$tcModuleAbbrevFirstInMutRec = SR$$$tcModuleAbbrevFirstInMutRec;
exports.SR$$$tcUnsupportedMutRecDecl = SR$$$tcUnsupportedMutRecDecl;
exports.SR$$$parsInvalidUseOfRec = SR$$$parsInvalidUseOfRec;
exports.SR$$$tcStructUnionMultiCaseDistinctFields = SR$$$tcStructUnionMultiCaseDistinctFields;
exports.SR$$$CallerMemberNameIsOverriden$$Z721C83C5 = SR$$$CallerMemberNameIsOverriden$$Z721C83C5;
exports.SR$$$tcFixedNotAllowed = SR$$$tcFixedNotAllowed;
exports.SR$$$tcCouldNotFindOffsetToStringData = SR$$$tcCouldNotFindOffsetToStringData;
exports.SR$$$chkNoByrefAddressOfLocal$$Z721C83C5 = SR$$$chkNoByrefAddressOfLocal$$Z721C83C5;
exports.SR$$$tcNamedActivePattern$$Z721C83C5 = SR$$$tcNamedActivePattern$$Z721C83C5;
exports.SR$$$DefaultParameterValueNotAppropriateForArgument = SR$$$DefaultParameterValueNotAppropriateForArgument;
exports.SR$$$tcGlobalsSystemTypeNotFound$$Z721C83C5 = SR$$$tcGlobalsSystemTypeNotFound$$Z721C83C5;
exports.SR$$$typrelMemberHasMultiplePossibleDispatchSlots$$Z384F8060 = SR$$$typrelMemberHasMultiplePossibleDispatchSlots$$Z384F8060;
exports.SR$$$methodIsNotStatic$$Z721C83C5 = SR$$$methodIsNotStatic$$Z721C83C5;
exports.SR$$$parsUnexpectedSymbolEqualsInsteadOfIn = SR$$$parsUnexpectedSymbolEqualsInsteadOfIn;
exports.SR$$$keywordDescriptionAbstract = SR$$$keywordDescriptionAbstract;
exports.SR$$$keyworkDescriptionAnd = SR$$$keyworkDescriptionAnd;
exports.SR$$$keywordDescriptionAs = SR$$$keywordDescriptionAs;
exports.SR$$$keywordDescriptionAssert = SR$$$keywordDescriptionAssert;
exports.SR$$$keywordDescriptionBase = SR$$$keywordDescriptionBase;
exports.SR$$$keywordDescriptionBegin = SR$$$keywordDescriptionBegin;
exports.SR$$$keywordDescriptionClass = SR$$$keywordDescriptionClass;
exports.SR$$$keywordDescriptionDefault = SR$$$keywordDescriptionDefault;
exports.SR$$$keywordDescriptionDelegate = SR$$$keywordDescriptionDelegate;
exports.SR$$$keywordDescriptionDo = SR$$$keywordDescriptionDo;
exports.SR$$$keywordDescriptionDone = SR$$$keywordDescriptionDone;
exports.SR$$$keywordDescriptionDowncast = SR$$$keywordDescriptionDowncast;
exports.SR$$$keywordDescriptionDownto = SR$$$keywordDescriptionDownto;
exports.SR$$$keywordDescriptionElif = SR$$$keywordDescriptionElif;
exports.SR$$$keywordDescriptionElse = SR$$$keywordDescriptionElse;
exports.SR$$$keywordDescriptionEnd = SR$$$keywordDescriptionEnd;
exports.SR$$$keywordDescriptionException = SR$$$keywordDescriptionException;
exports.SR$$$keywordDescriptionExtern = SR$$$keywordDescriptionExtern;
exports.SR$$$keywordDescriptionTrueFalse = SR$$$keywordDescriptionTrueFalse;
exports.SR$$$keywordDescriptionFinally = SR$$$keywordDescriptionFinally;
exports.SR$$$keywordDescriptionFor = SR$$$keywordDescriptionFor;
exports.SR$$$keywordDescriptionFun = SR$$$keywordDescriptionFun;
exports.SR$$$keywordDescriptionFunction = SR$$$keywordDescriptionFunction;
exports.SR$$$keywordDescriptionGlobal = SR$$$keywordDescriptionGlobal;
exports.SR$$$keywordDescriptionIf = SR$$$keywordDescriptionIf;
exports.SR$$$keywordDescriptionIn = SR$$$keywordDescriptionIn;
exports.SR$$$keywordDescriptionInherit = SR$$$keywordDescriptionInherit;
exports.SR$$$keywordDescriptionInline = SR$$$keywordDescriptionInline;
exports.SR$$$keywordDescriptionInterface = SR$$$keywordDescriptionInterface;
exports.SR$$$keywordDescriptionInternal = SR$$$keywordDescriptionInternal;
exports.SR$$$keywordDescriptionLazy = SR$$$keywordDescriptionLazy;
exports.SR$$$keywordDescriptionLet = SR$$$keywordDescriptionLet;
exports.SR$$$keywordDescriptionLetBang = SR$$$keywordDescriptionLetBang;
exports.SR$$$keywordDescriptionMatch = SR$$$keywordDescriptionMatch;
exports.SR$$$keywordDescriptionMatchBang = SR$$$keywordDescriptionMatchBang;
exports.SR$$$keywordDescriptionMember = SR$$$keywordDescriptionMember;
exports.SR$$$keywordDescriptionModule = SR$$$keywordDescriptionModule;
exports.SR$$$keywordDescriptionMutable = SR$$$keywordDescriptionMutable;
exports.SR$$$keywordDescriptionNamespace = SR$$$keywordDescriptionNamespace;
exports.SR$$$keywordDescriptionNew = SR$$$keywordDescriptionNew;
exports.SR$$$keywordDescriptionNot = SR$$$keywordDescriptionNot;
exports.SR$$$keywordDescriptionNull = SR$$$keywordDescriptionNull;
exports.SR$$$keywordDescriptionOf = SR$$$keywordDescriptionOf;
exports.SR$$$keywordDescriptionOpen = SR$$$keywordDescriptionOpen;
exports.SR$$$keywordDescriptionOr = SR$$$keywordDescriptionOr;
exports.SR$$$keywordDescriptionOverride = SR$$$keywordDescriptionOverride;
exports.SR$$$keywordDescriptionPrivate = SR$$$keywordDescriptionPrivate;
exports.SR$$$keywordDescriptionPublic = SR$$$keywordDescriptionPublic;
exports.SR$$$keywordDescriptionRec = SR$$$keywordDescriptionRec;
exports.SR$$$keywordDescriptionReturn = SR$$$keywordDescriptionReturn;
exports.SR$$$keywordDescriptionReturnBang = SR$$$keywordDescriptionReturnBang;
exports.SR$$$keywordDescriptionSelect = SR$$$keywordDescriptionSelect;
exports.SR$$$keywordDescriptionStatic = SR$$$keywordDescriptionStatic;
exports.SR$$$keywordDescriptionStruct = SR$$$keywordDescriptionStruct;
exports.SR$$$keywordDescriptionThen = SR$$$keywordDescriptionThen;
exports.SR$$$keywordDescriptionTo = SR$$$keywordDescriptionTo;
exports.SR$$$keywordDescriptionTry = SR$$$keywordDescriptionTry;
exports.SR$$$keywordDescriptionType = SR$$$keywordDescriptionType;
exports.SR$$$keywordDescriptionUpcast = SR$$$keywordDescriptionUpcast;
exports.SR$$$keywordDescriptionUse = SR$$$keywordDescriptionUse;
exports.SR$$$keywordDescriptionUseBang = SR$$$keywordDescriptionUseBang;
exports.SR$$$keywordDescriptionVal = SR$$$keywordDescriptionVal;
exports.SR$$$keywordDescriptionVoid = SR$$$keywordDescriptionVoid;
exports.SR$$$keywordDescriptionWhen = SR$$$keywordDescriptionWhen;
exports.SR$$$keywordDescriptionWhile = SR$$$keywordDescriptionWhile;
exports.SR$$$keywordDescriptionWith = SR$$$keywordDescriptionWith;
exports.SR$$$keywordDescriptionYield = SR$$$keywordDescriptionYield;
exports.SR$$$keywordDescriptionYieldBang = SR$$$keywordDescriptionYieldBang;
exports.SR$$$keywordDescriptionRightArrow = SR$$$keywordDescriptionRightArrow;
exports.SR$$$keywordDescriptionLeftArrow = SR$$$keywordDescriptionLeftArrow;
exports.SR$$$keywordDescriptionCast = SR$$$keywordDescriptionCast;
exports.SR$$$keywordDescriptionDynamicCast = SR$$$keywordDescriptionDynamicCast;
exports.SR$$$keywordDescriptionTypedQuotation = SR$$$keywordDescriptionTypedQuotation;
exports.SR$$$keywordDescriptionUntypedQuotation = SR$$$keywordDescriptionUntypedQuotation;
exports.SR$$$itemNotFoundDuringDynamicCodeGen$$30230F9B = SR$$$itemNotFoundDuringDynamicCodeGen$$30230F9B;
exports.SR$$$itemNotFoundInTypeDuringDynamicCodeGen$$Z46998140 = SR$$$itemNotFoundInTypeDuringDynamicCodeGen$$Z46998140;
exports.SR$$$descriptionWordIs = SR$$$descriptionWordIs;
exports.SR$$$notAFunction = SR$$$notAFunction;
exports.SR$$$notAFunctionButMaybeIndexerWithName$$Z721C83C5 = SR$$$notAFunctionButMaybeIndexerWithName$$Z721C83C5;
exports.SR$$$notAFunctionButMaybeIndexer = SR$$$notAFunctionButMaybeIndexer;
exports.SR$$$notAFunctionButMaybeIndexerErrorCode = SR$$$notAFunctionButMaybeIndexerErrorCode;
exports.SR$$$notAFunctionButMaybeDeclaration = SR$$$notAFunctionButMaybeDeclaration;
exports.SR$$$ArgumentsInSigAndImplMismatch$$Z384F8060 = SR$$$ArgumentsInSigAndImplMismatch$$Z384F8060;
exports.SR$$$pickleUnexpectedNonZero$$Z721C83C5 = SR$$$pickleUnexpectedNonZero$$Z721C83C5;
exports.SR$$$tcTupleMemberNotNormallyUsed = SR$$$tcTupleMemberNotNormallyUsed;
exports.SR$$$implicitlyDiscardedInSequenceExpression$$Z721C83C5 = SR$$$implicitlyDiscardedInSequenceExpression$$Z721C83C5;
exports.SR$$$implicitlyDiscardedSequenceInSequenceExpression$$Z721C83C5 = SR$$$implicitlyDiscardedSequenceInSequenceExpression$$Z721C83C5;
exports.SR$$$ilreadFileChanged$$Z721C83C5 = SR$$$ilreadFileChanged$$Z721C83C5;
exports.SR$$$writeToReadOnlyByref = SR$$$writeToReadOnlyByref;
exports.SR$$$readOnlyAttributeOnStructWithMutableField = SR$$$readOnlyAttributeOnStructWithMutableField;
exports.SR$$$tcByrefReturnImplicitlyDereferenced = SR$$$tcByrefReturnImplicitlyDereferenced;
exports.SR$$$tcByRefLikeNotStruct = SR$$$tcByRefLikeNotStruct;
exports.SR$$$chkNoByrefAddressOfValueFromExpression = SR$$$chkNoByrefAddressOfValueFromExpression;
exports.SR$$$chkNoReturnOfLimitedSpan = SR$$$chkNoReturnOfLimitedSpan;
exports.SR$$$chkNoWriteToLimitedSpan$$Z721C83C5 = SR$$$chkNoWriteToLimitedSpan$$Z721C83C5;
exports.SR$$$tastValueMustBeLocal = SR$$$tastValueMustBeLocal;
exports.SR$$$tcIsReadOnlyNotStruct = SR$$$tcIsReadOnlyNotStruct;
exports.SR$$$chkStructsMayNotReturnAddressesOfContents = SR$$$chkStructsMayNotReturnAddressesOfContents;
exports.SR$$$chkNoByrefLikeFunctionCall = SR$$$chkNoByrefLikeFunctionCall;
exports.SR$$$chkNoSpanLikeVariable$$Z721C83C5 = SR$$$chkNoSpanLikeVariable$$Z721C83C5;
exports.SR$$$chkNoSpanLikeValueFromExpression = SR$$$chkNoSpanLikeValueFromExpression;
exports.SR$$$tastCantTakeAddressOfExpression = SR$$$tastCantTakeAddressOfExpression;
exports.SR = void 0;

var _Types = require("../fable-core.2.0.3/Types");

var _String = require("../fable-core.2.0.3/String");

const SR = (0, _Types.declare)(function SR() {});
exports.SR = SR;

function SR$$$$002Ector() {
  return this != null ? SR.call(this) : new SR();
}

function SR$$$undefinedNameNamespace$$Z721C83C5(a0) {
  return (0, _String.toText)((0, _String.printf)("The namespace '%s' is not defined."))(a0);
}

function SR$$$undefinedNameNamespaceOrModule$$Z721C83C5(a0$$1) {
  return (0, _String.toText)((0, _String.printf)("The namespace or module '%s' is not defined."))(a0$$1);
}

function SR$$$undefinedNameFieldConstructorOrMember$$Z721C83C5(a0$$2) {
  return (0, _String.toText)((0, _String.printf)("The field, constructor or member '%s' is not defined."))(a0$$2);
}

function SR$$$undefinedNameValueConstructorNamespaceOrType$$Z721C83C5(a0$$3) {
  return (0, _String.toText)((0, _String.printf)("The value, constructor, namespace or type '%s' is not defined."))(a0$$3);
}

function SR$$$undefinedNameValueOfConstructor$$Z721C83C5(a0$$4) {
  return (0, _String.toText)((0, _String.printf)("The value or constructor '%s' is not defined."))(a0$$4);
}

function SR$$$undefinedNameValueNamespaceTypeOrModule$$Z721C83C5(a0$$5) {
  return (0, _String.toText)((0, _String.printf)("The value, namespace, type or module '%s' is not defined."))(a0$$5);
}

function SR$$$undefinedNameConstructorModuleOrNamespace$$Z721C83C5(a0$$6) {
  return (0, _String.toText)((0, _String.printf)("The constructor, module or namespace '%s' is not defined."))(a0$$6);
}

function SR$$$undefinedNameType$$Z721C83C5(a0$$7) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' is not defined."))(a0$$7);
}

function SR$$$undefinedNameTypeIn$$Z384F8060(a0$$8, a1) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' is not defined in '%s'."))(a0$$8)(a1);
}

function SR$$$undefinedNameRecordLabelOrNamespace$$Z721C83C5(a0$$9) {
  return (0, _String.toText)((0, _String.printf)("The record label or namespace '%s' is not defined."))(a0$$9);
}

function SR$$$undefinedNameRecordLabel$$Z721C83C5(a0$$10) {
  return (0, _String.toText)((0, _String.printf)("The record label '%s' is not defined."))(a0$$10);
}

function SR$$$undefinedNameSuggestionsIntro() {
  return (0, _String.toText)((0, _String.printf)("Maybe you want one of the following:"));
}

function SR$$$undefinedNameTypeParameter$$Z721C83C5(a0$$11) {
  return (0, _String.toText)((0, _String.printf)("The type parameter %s is not defined."))(a0$$11);
}

function SR$$$undefinedNamePatternDiscriminator$$Z721C83C5(a0$$12) {
  return (0, _String.toText)((0, _String.printf)("The pattern discriminator '%s' is not defined."))(a0$$12);
}

function SR$$$replaceWithSuggestion$$Z721C83C5(a0$$13) {
  return (0, _String.toText)((0, _String.printf)("Replace with '%s'"))(a0$$13);
}

function SR$$$addIndexerDot() {
  return (0, _String.toText)((0, _String.printf)("Add . for indexer access."));
}

function SR$$$listElementHasWrongType$$Z384F8060(a0$$14, a1$$1) {
  return (0, _String.toText)((0, _String.printf)("All elements of a list must be of the same type as the first element, which here is '%s'. This element has type '%s'."))(a0$$14)(a1$$1);
}

function SR$$$arrayElementHasWrongType$$Z384F8060(a0$$15, a1$$2) {
  return (0, _String.toText)((0, _String.printf)("All elements of an array must be of the same type as the first element, which here is '%s'. This element has type '%s'."))(a0$$15)(a1$$2);
}

function SR$$$missingElseBranch$$Z721C83C5(a0$$16) {
  return (0, _String.toText)((0, _String.printf)("This 'if' expression is missing an 'else' branch. Because 'if' is an expression, and not a statement, add an 'else' branch which also returns a value of type '%s'."))(a0$$16);
}

function SR$$$ifExpression$$Z384F8060(a0$$17, a1$$3) {
  return (0, _String.toText)((0, _String.printf)("The 'if' expression needs to have type '%s' to satisfy context type requirements. It currently has type '%s'."))(a0$$17)(a1$$3);
}

function SR$$$elseBranchHasWrongType$$Z384F8060(a0$$18, a1$$4) {
  return (0, _String.toText)((0, _String.printf)("All branches of an 'if' expression must return values of the same type as the first branch, which here is '%s'. This branch returns a value of type '%s'."))(a0$$18)(a1$$4);
}

function SR$$$followingPatternMatchClauseHasWrongType$$Z384F8060(a0$$19, a1$$5) {
  return (0, _String.toText)((0, _String.printf)("All branches of a pattern match expression must return values of the same type as the first branch, which here is '%s'. This branch returns a value of type '%s'."))(a0$$19)(a1$$5);
}

function SR$$$patternMatchGuardIsNotBool$$Z721C83C5(a0$$20) {
  return (0, _String.toText)((0, _String.printf)("A pattern match guard must be of type 'bool', but this 'when' expression is of type '%s'."))(a0$$20);
}

function SR$$$commaInsteadOfSemicolonInRecord() {
  return (0, _String.toText)((0, _String.printf)("A ';' is used to separate field values in records. Consider replacing ',' with ';'."));
}

function SR$$$derefInsteadOfNot() {
  return (0, _String.toText)((0, _String.printf)("The '!' operator is used to dereference a ref cell. Consider using 'not expr' here."));
}

function SR$$$buildUnexpectedTypeArgs$$Z18115A39(a0$$21, a1$$6) {
  return (0, _String.toText)((0, _String.printf)("The non-generic type '%s' does not expect any type arguments, but here is given %d type argument(s)"))(a0$$21)(a1$$6);
}

function SR$$$returnUsedInsteadOfReturnBang() {
  return (0, _String.toText)((0, _String.printf)("Consider using 'return!' instead of 'return'."));
}

function SR$$$yieldUsedInsteadOfYieldBang() {
  return (0, _String.toText)((0, _String.printf)("Consider using 'yield!' instead of 'yield'."));
}

function SR$$$tupleRequiredInAbstractMethod() {
  return (0, _String.toText)((0, _String.printf)("\nA tuple type is required for one or more arguments. Consider wrapping the given arguments in additional parentheses or review the definition of the interface."));
}

function SR$$$buildInvalidWarningNumber$$Z721C83C5(a0$$22) {
  return [203, (0, _String.toText)((0, _String.printf)("Invalid warning number '%s'"))(a0$$22)];
}

function SR$$$buildInvalidVersionString$$Z721C83C5(a0$$23) {
  return [204, (0, _String.toText)((0, _String.printf)("Invalid version string '%s'"))(a0$$23)];
}

function SR$$$buildInvalidVersionFile$$Z721C83C5(a0$$24) {
  return [205, (0, _String.toText)((0, _String.printf)("Invalid version file '%s'"))(a0$$24)];
}

function SR$$$buildProductName$$Z721C83C5(a0$$25) {
  return (0, _String.toText)((0, _String.printf)("Microsoft (R) F# Compiler version %s"))(a0$$25);
}

function SR$$$buildProductNameCommunity$$Z721C83C5(a0$$26) {
  return (0, _String.toText)((0, _String.printf)("F# Compiler for F# %s"))(a0$$26);
}

function SR$$$buildProblemWithFilename$$Z384F8060(a0$$27, a1$$7) {
  return [206, (0, _String.toText)((0, _String.printf)("Problem with filename '%s': %s"))(a0$$27)(a1$$7)];
}

function SR$$$buildNoInputsSpecified() {
  return [207, (0, _String.toText)((0, _String.printf)("No inputs specified"))];
}

function SR$$$buildPdbRequiresDebug() {
  return [209, (0, _String.toText)((0, _String.printf)("The '--pdb' option requires the '--debug' option to be used"))];
}

function SR$$$buildInvalidSearchDirectory$$Z721C83C5(a0$$28) {
  return [210, (0, _String.toText)((0, _String.printf)("The search directory '%s' is invalid"))(a0$$28)];
}

function SR$$$buildSearchDirectoryNotFound$$Z721C83C5(a0$$29) {
  return [211, (0, _String.toText)((0, _String.printf)("The search directory '%s' could not be found"))(a0$$29)];
}

function SR$$$buildInvalidFilename$$Z721C83C5(a0$$30) {
  return [212, (0, _String.toText)((0, _String.printf)("'%s' is not a valid filename"))(a0$$30)];
}

function SR$$$buildInvalidAssemblyName$$Z721C83C5(a0$$31) {
  return [213, (0, _String.toText)((0, _String.printf)("'%s' is not a valid assembly name"))(a0$$31)];
}

function SR$$$buildInvalidPrivacy$$Z721C83C5(a0$$32) {
  return [214, (0, _String.toText)((0, _String.printf)("Unrecognized privacy setting '%s' for managed resource, valid options are 'public' and 'private'"))(a0$$32)];
}

function SR$$$buildMultipleReferencesNotAllowed$$Z721C83C5(a0$$33) {
  return [215, (0, _String.toText)((0, _String.printf)("Multiple references to '%s.dll' are not permitted"))(a0$$33)];
}

function SR$$$buildCouldNotReadVersionInfoFromMscorlib() {
  return (0, _String.toText)((0, _String.printf)("Could not read version from mscorlib.dll"));
}

function SR$$$buildCannotReadAssembly$$Z721C83C5(a0$$34) {
  return [218, (0, _String.toText)((0, _String.printf)("Unable to read assembly '%s'"))(a0$$34)];
}

function SR$$$buildAssemblyResolutionFailed() {
  return [220, (0, _String.toText)((0, _String.printf)("Assembly resolution failure at or near this location"))];
}

function SR$$$buildImplicitModuleIsNotLegalIdentifier$$Z384F8060(a0$$35, a1$$8) {
  return [221, (0, _String.toText)((0, _String.printf)("The declarations in this file will be placed in an implicit module '%s' based on the file name '%s'. However this is not a valid F# identifier, so the contents will not be accessible from other files. Consider renaming the file or adding a 'module' or 'namespace' declaration at the top of the file."))(a0$$35)(a1$$8)];
}

function SR$$$buildMultiFileRequiresNamespaceOrModule() {
  return [222, (0, _String.toText)((0, _String.printf)("Files in libraries or multiple-file applications must begin with a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule'. Only the last source file of an application may omit such a declaration."))];
}

function SR$$$noEqualSignAfterModule() {
  return [222, (0, _String.toText)((0, _String.printf)("Files in libraries or multiple-file applications must begin with a namespace or module declaration. When using a module declaration at the start of a file the '=' sign is not allowed. If this is a top-level module, consider removing the = to resolve this error."))];
}

function SR$$$buildMultipleToplevelModules() {
  return [223, (0, _String.toText)((0, _String.printf)("This file contains multiple declarations of the form 'module SomeNamespace.SomeModule'. Only one declaration of this form is permitted in a file. Change your file to use an initial namespace declaration and/or use 'module ModuleName = ...' to define your modules."))];
}

function SR$$$buildOptionRequiresParameter$$Z721C83C5(a0$$36) {
  return [224, (0, _String.toText)((0, _String.printf)("Option requires parameter: %s"))(a0$$36)];
}

function SR$$$buildCouldNotFindSourceFile$$Z721C83C5(a0$$37) {
  return [225, (0, _String.toText)((0, _String.printf)("Source file '%s' could not be found"))(a0$$37)];
}

function SR$$$buildInvalidSourceFileExtension$$Z721C83C5(a0$$38) {
  return [226, (0, _String.toText)((0, _String.printf)("The file extension of '%s' is not recognized. Source files must have extension .fs, .fsi, .fsx, .fsscript, .ml or .mli."))(a0$$38)];
}

function SR$$$buildCouldNotResolveAssembly$$Z721C83C5(a0$$39) {
  return [227, (0, _String.toText)((0, _String.printf)("Could not resolve assembly '%s'"))(a0$$39)];
}

function SR$$$buildCouldNotResolveAssemblyRequiredByFile$$Z384F8060(a0$$40, a1$$9) {
  return [228, (0, _String.toText)((0, _String.printf)("Could not resolve assembly '%s' required by '%s'"))(a0$$40)(a1$$9)];
}

function SR$$$buildErrorOpeningBinaryFile$$Z384F8060(a0$$41, a1$$10) {
  return [229, (0, _String.toText)((0, _String.printf)("Error opening binary file '%s': %s"))(a0$$41)(a1$$10)];
}

function SR$$$buildDifferentVersionMustRecompile$$Z721C83C5(a0$$42) {
  return [231, (0, _String.toText)((0, _String.printf)("The F#-compiled DLL '%s' needs to be recompiled to be used with this version of F#"))(a0$$42)];
}

function SR$$$buildInvalidHashIDirective() {
  return [232, (0, _String.toText)((0, _String.printf)("Invalid directive. Expected '#I \"<path>\"'."))];
}

function SR$$$buildInvalidHashrDirective() {
  return [233, (0, _String.toText)((0, _String.printf)("Invalid directive. Expected '#r \"<file-or-assembly>\"'."))];
}

function SR$$$buildInvalidHashloadDirective() {
  return [234, (0, _String.toText)((0, _String.printf)("Invalid directive. Expected '#load \"<file>\" ... \"<file>\"'."))];
}

function SR$$$buildInvalidHashtimeDirective() {
  return [235, (0, _String.toText)((0, _String.printf)("Invalid directive. Expected '#time', '#time \"on\"' or '#time \"off\"'."))];
}

function SR$$$buildDirectivesInModulesAreIgnored() {
  return [236, (0, _String.toText)((0, _String.printf)("Directives inside modules are ignored"))];
}

function SR$$$buildSignatureAlreadySpecified$$Z721C83C5(a0$$43) {
  return [237, (0, _String.toText)((0, _String.printf)("A signature for the file or module '%s' has already been specified"))(a0$$43)];
}

function SR$$$buildImplementationAlreadyGivenDetail$$Z721C83C5(a0$$44) {
  return [238, (0, _String.toText)((0, _String.printf)("An implementation of file or module '%s' has already been given. Compilation order is significant in F# because of type inference. You may need to adjust the order of your files to place the signature file before the implementation. In Visual Studio files are type-checked in the order they appear in the project file, which can be edited manually or adjusted using the solution explorer."))(a0$$44)];
}

function SR$$$buildImplementationAlreadyGiven$$Z721C83C5(a0$$45) {
  return [239, (0, _String.toText)((0, _String.printf)("An implementation of the file or module '%s' has already been given"))(a0$$45)];
}

function SR$$$buildSignatureWithoutImplementation$$Z721C83C5(a0$$46) {
  return [240, (0, _String.toText)((0, _String.printf)("The signature file '%s' does not have a corresponding implementation file. If an implementation file exists then check the 'module' and 'namespace' declarations in the signature and implementation files match."))(a0$$46)];
}

function SR$$$buildArgInvalidInt$$Z721C83C5(a0$$47) {
  return [241, (0, _String.toText)((0, _String.printf)("'%s' is not a valid integer argument"))(a0$$47)];
}

function SR$$$buildArgInvalidFloat$$Z721C83C5(a0$$48) {
  return [242, (0, _String.toText)((0, _String.printf)("'%s' is not a valid floating point argument"))(a0$$48)];
}

function SR$$$buildUnrecognizedOption$$Z721C83C5(a0$$49) {
  return [243, (0, _String.toText)((0, _String.printf)("Unrecognized option: '%s'"))(a0$$49)];
}

function SR$$$buildInvalidModuleOrNamespaceName() {
  return [244, (0, _String.toText)((0, _String.printf)("Invalid module or namespace name"))];
}

function SR$$$pickleErrorReadingWritingMetadata$$Z384F8060(a0$$50, a1$$11) {
  return (0, _String.toText)((0, _String.printf)("Error reading/writing metadata for the F# compiled DLL '%s'. Was the DLL compiled with an earlier version of the F# compiler? (error: '%s')."))(a0$$50)(a1$$11);
}

function SR$$$tastTypeOrModuleNotConcrete$$Z721C83C5(a0$$51) {
  return [245, (0, _String.toText)((0, _String.printf)("The type/module '%s' is not a concrete module or type"))(a0$$51)];
}

function SR$$$tastTypeHasAssemblyCodeRepresentation$$Z721C83C5(a0$$52) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' has an inline assembly code representation"))(a0$$52);
}

function SR$$$tastNamespaceAndModuleWithSameNameInAssembly$$Z721C83C5(a0$$53) {
  return [247, (0, _String.toText)((0, _String.printf)("A namespace and a module named '%s' both occur in two parts of this assembly"))(a0$$53)];
}

function SR$$$tastTwoModulesWithSameNameInAssembly$$Z721C83C5(a0$$54) {
  return [248, (0, _String.toText)((0, _String.printf)("Two modules named '%s' occur in two parts of this assembly"))(a0$$54)];
}

function SR$$$tastDuplicateTypeDefinitionInAssembly$$Z384F8060(a0$$55, a1$$12) {
  return [249, (0, _String.toText)((0, _String.printf)("Two type definitions named '%s' occur in namespace '%s' in two parts of this assembly"))(a0$$55)(a1$$12)];
}

function SR$$$tastConflictingModuleAndTypeDefinitionInAssembly$$Z384F8060(a0$$56, a1$$13) {
  return [250, (0, _String.toText)((0, _String.printf)("A module and a type definition named '%s' occur in namespace '%s' in two parts of this assembly"))(a0$$56)(a1$$13)];
}

function SR$$$tastInvalidMemberSignature() {
  return [251, (0, _String.toText)((0, _String.printf)("Invalid member signature encountered because of an earlier error"))];
}

function SR$$$tastValueDoesNotHaveSetterType() {
  return [252, (0, _String.toText)((0, _String.printf)("This value does not have a valid property setter type"))];
}

function SR$$$tastInvalidFormForPropertyGetter() {
  return [253, (0, _String.toText)((0, _String.printf)("Invalid form for a property getter. At least one '()' argument is required when using the explicit syntax."))];
}

function SR$$$tastInvalidFormForPropertySetter() {
  return [254, (0, _String.toText)((0, _String.printf)("Invalid form for a property setter. At least one argument is required."))];
}

function SR$$$tastUnexpectedByRef() {
  return [255, (0, _String.toText)((0, _String.printf)("Unexpected use of a byref-typed variable"))];
}

function SR$$$tastValueMustBeMutable() {
  return [256, (0, _String.toText)((0, _String.printf)("A value must be mutable in order to mutate the contents or take the address of a value type, e.g. 'let mutable x = ...'"))];
}

function SR$$$tastInvalidMutationOfConstant() {
  return [257, (0, _String.toText)((0, _String.printf)("Invalid mutation of a constant expression. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...'."))];
}

function SR$$$tastValueHasBeenCopied() {
  return (0, _String.toText)((0, _String.printf)("The value has been copied to ensure the original is not mutated by this operation or because the copy is implicit when returning a struct from a member and another member is then accessed"));
}

function SR$$$tastRecursiveValuesMayNotBeInConstructionOfTuple() {
  return [259, (0, _String.toText)((0, _String.printf)("Recursively defined values cannot appear directly as part of the construction of a tuple value within a recursive binding"))];
}

function SR$$$tastRecursiveValuesMayNotAppearInConstructionOfType$$Z721C83C5(a0$$57) {
  return [260, (0, _String.toText)((0, _String.printf)("Recursive values cannot appear directly as a construction of the type '%s' within a recursive binding. This feature has been removed from the F# language. Consider using a record instead."))(a0$$57)];
}

function SR$$$tastRecursiveValuesMayNotBeAssignedToNonMutableField$$Z384F8060(a0$$58, a1$$14) {
  return [261, (0, _String.toText)((0, _String.printf)("Recursive values cannot be directly assigned to the non-mutable field '%s' of the type '%s' within a recursive binding. Consider using a mutable field instead."))(a0$$58)(a1$$14)];
}

function SR$$$tastUnexpectedDecodeOfAutoOpenAttribute() {
  return (0, _String.toText)((0, _String.printf)("Unexpected decode of AutoOpenAttribute"));
}

function SR$$$tastUnexpectedDecodeOfInternalsVisibleToAttribute() {
  return (0, _String.toText)((0, _String.printf)("Unexpected decode of InternalsVisibleToAttribute"));
}

function SR$$$tastUnexpectedDecodeOfInterfaceDataVersionAttribute() {
  return (0, _String.toText)((0, _String.printf)("Unexpected decode of InterfaceDataVersionAttribute"));
}

function SR$$$tastActivePatternsLimitedToSeven() {
  return [265, (0, _String.toText)((0, _String.printf)("Active patterns cannot return more than 7 possibilities"))];
}

function SR$$$tastNotAConstantExpression() {
  return [267, (0, _String.toText)((0, _String.printf)("This is not a valid constant expression or custom attribute value"))];
}

function SR$$$ValueNotContainedMutabilityAttributesDiffer$$30230F9B(a0$$59, a1$$15, a2) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe mutability attributes differ"))(a0$$59)(a1$$15)(a2);
}

function SR$$$ValueNotContainedMutabilityNamesDiffer$$30230F9B(a0$$60, a1$$16, a2$$1) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe names differ"))(a0$$60)(a1$$16)(a2$$1);
}

function SR$$$ValueNotContainedMutabilityCompiledNamesDiffer$$30230F9B(a0$$61, a1$$17, a2$$2) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled names differ"))(a0$$61)(a1$$17)(a2$$2);
}

function SR$$$ValueNotContainedMutabilityDisplayNamesDiffer$$30230F9B(a0$$62, a1$$18, a2$$3) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe display names differ"))(a0$$62)(a1$$18)(a2$$3);
}

function SR$$$ValueNotContainedMutabilityAccessibilityMore$$30230F9B(a0$$63, a1$$19, a2$$4) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe accessibility specified in the signature is more than that specified in the implementation"))(a0$$63)(a1$$19)(a2$$4);
}

function SR$$$ValueNotContainedMutabilityInlineFlagsDiffer$$30230F9B(a0$$64, a1$$20, a2$$5) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe inline flags differ"))(a0$$64)(a1$$20)(a2$$5);
}

function SR$$$ValueNotContainedMutabilityLiteralConstantValuesDiffer$$30230F9B(a0$$65, a1$$21, a2$$6) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe literal constant values and/or attributes differ"))(a0$$65)(a1$$21)(a2$$6);
}

function SR$$$ValueNotContainedMutabilityOneIsTypeFunction$$30230F9B(a0$$66, a1$$22, a2$$7) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a type function and the other is not. The signature requires explicit type parameters if they are present in the implementation."))(a0$$66)(a1$$22)(a2$$7);
}

function SR$$$ValueNotContainedMutabilityParameterCountsDiffer$$30230F9B(a0$$67, a1$$23, a2$$8) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe respective type parameter counts differ"))(a0$$67)(a1$$23)(a2$$8);
}

function SR$$$ValueNotContainedMutabilityTypesDiffer$$30230F9B(a0$$68, a1$$24, a2$$9) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe types differ"))(a0$$68)(a1$$24)(a2$$9);
}

function SR$$$ValueNotContainedMutabilityExtensionsDiffer$$30230F9B(a0$$69, a1$$25, a2$$10) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nOne is an extension member and the other is not"))(a0$$69)(a1$$25)(a2$$10);
}

function SR$$$ValueNotContainedMutabilityArityNotInferred$$30230F9B(a0$$70, a1$$26, a2$$11) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nAn arity was not inferred for this value"))(a0$$70)(a1$$26)(a2$$11);
}

function SR$$$ValueNotContainedMutabilityGenericParametersDiffer$$6BD52AFB(a0$$71, a1$$27, a2$$12, a3, a4) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe number of generic parameters in the signature and implementation differ (the signature declares %s but the implementation declares %s"))(a0$$71)(a1$$27)(a2$$12)(a3)(a4);
}

function SR$$$ValueNotContainedMutabilityGenericParametersAreDifferentKinds$$30230F9B(a0$$72, a1$$28, a2$$13) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe generic parameters in the signature and implementation have different kinds. Perhaps there is a missing [<Measure>] attribute."))(a0$$72)(a1$$28)(a2$$13);
}

function SR$$$ValueNotContainedMutabilityAritiesDiffer$$533BBE5B(a0$$73, a1$$29, a2$$14, a3$$1, a4$$1, a5, a6) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe arities in the signature and implementation differ. The signature specifies that '%s' is function definition or lambda expression accepting at least %s argument(s), but the implementation is a computed function value. To declare that a computed function value is a permitted implementation simply parenthesize its type in the signature, e.g.\n\tval %s: int -> (int -> int)\ninstead of\n\tval %s: int -> int -> int."))(a0$$73)(a1$$29)(a2$$14)(a3$$1)(a4$$1)(a5)(a6);
}

function SR$$$ValueNotContainedMutabilityDotNetNamesDiffer$$30230F9B(a0$$74, a1$$30, a2$$15) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe CLI member names differ"))(a0$$74)(a1$$30)(a2$$15);
}

function SR$$$ValueNotContainedMutabilityStaticsDiffer$$30230F9B(a0$$75, a1$$31, a2$$16) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nOne is static and the other isn't"))(a0$$75)(a1$$31)(a2$$16);
}

function SR$$$ValueNotContainedMutabilityVirtualsDiffer$$30230F9B(a0$$76, a1$$32, a2$$17) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nOne is virtual and the other isn't"))(a0$$76)(a1$$32)(a2$$17);
}

function SR$$$ValueNotContainedMutabilityAbstractsDiffer$$30230F9B(a0$$77, a1$$33, a2$$18) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nOne is abstract and the other isn't"))(a0$$77)(a1$$33)(a2$$18);
}

function SR$$$ValueNotContainedMutabilityFinalsDiffer$$30230F9B(a0$$78, a1$$34, a2$$19) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nOne is final and the other isn't"))(a0$$78)(a1$$34)(a2$$19);
}

function SR$$$ValueNotContainedMutabilityOverridesDiffer$$30230F9B(a0$$79, a1$$35, a2$$20) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nOne is marked as an override and the other isn't"))(a0$$79)(a1$$35)(a2$$20);
}

function SR$$$ValueNotContainedMutabilityOneIsConstructor$$30230F9B(a0$$80, a1$$36, a2$$21) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nOne is a constructor/property and the other is not"))(a0$$80)(a1$$36)(a2$$21);
}

function SR$$$ValueNotContainedMutabilityStaticButInstance$$30230F9B(a0$$81, a1$$37, a2$$22) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as a static member but the signature indicates its compiled representation is as an instance member"))(a0$$81)(a1$$37)(a2$$22);
}

function SR$$$ValueNotContainedMutabilityInstanceButStatic$$30230F9B(a0$$82, a1$$38, a2$$23) {
  return (0, _String.toText)((0, _String.printf)("Module '%s' contains\n    %s    \nbut its signature specifies\n    %s    \nThe compiled representation of this method is as an instance member, but the signature indicates its compiled representation is as a static member"))(a0$$82)(a1$$38)(a2$$23);
}

function SR$$$DefinitionsInSigAndImplNotCompatibleNamesDiffer$$30230F9B(a0$$83, a1$$39, a2$$24) {
  return [290, (0, _String.toText)((0, _String.printf)("The %s definitions in the signature and implementation are not compatible because the names differ. The type is called '%s' in the signature file but '%s' in implementation."))(a0$$83)(a1$$39)(a2$$24)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleParameterCountsDiffer$$Z384F8060(a0$$84, a1$$40) {
  return [291, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the respective type parameter counts differ"))(a0$$84)(a1$$40)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleAccessibilityDiffer$$Z384F8060(a0$$85, a1$$41) {
  return [292, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the accessibility specified in the signature is more than that specified in the implementation"))(a0$$85)(a1$$41)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleMissingInterface$$30230F9B(a0$$86, a1$$42, a2$$25) {
  return [293, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the signature requires that the type supports the interface %s but the interface has not been implemented"))(a0$$86)(a1$$42)(a2$$25)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleImplementationSaysNull$$Z384F8060(a0$$87, a1$$43) {
  return [294, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the implementation says this type may use nulls as a representation but the signature does not"))(a0$$87)(a1$$43)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleImplementationSaysNull2$$Z384F8060(a0$$88, a1$$44) {
  return [294, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the implementation says this type may use nulls as an extra value but the signature does not"))(a0$$88)(a1$$44)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleSignatureSaysNull$$Z384F8060(a0$$89, a1$$45) {
  return [295, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the signature says this type may use nulls as a representation but the implementation does not"))(a0$$89)(a1$$45)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleSignatureSaysNull2$$Z384F8060(a0$$90, a1$$46) {
  return [295, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the signature says this type may use nulls as an extra value but the implementation does not"))(a0$$90)(a1$$46)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleImplementationSealed$$Z384F8060(a0$$91, a1$$47) {
  return [296, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the implementation type is sealed but the signature implies it is not. Consider adding the [<Sealed>] attribute to the signature."))(a0$$91)(a1$$47)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleImplementationIsNotSealed$$Z384F8060(a0$$92, a1$$48) {
  return [297, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the implementation type is not sealed but signature implies it is. Consider adding the [<Sealed>] attribute to the implementation."))(a0$$92)(a1$$48)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleImplementationIsAbstract$$Z384F8060(a0$$93, a1$$49) {
  return [298, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the implementation is an abstract class but the signature is not. Consider adding the [<AbstractClass>] attribute to the signature."))(a0$$93)(a1$$49)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleSignatureIsAbstract$$Z384F8060(a0$$94, a1$$50) {
  return [299, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the signature is an abstract class but the implementation is not. Consider adding the [<AbstractClass>] attribute to the implementation."))(a0$$94)(a1$$50)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleTypesHaveDifferentBaseTypes$$Z384F8060(a0$$95, a1$$51) {
  return [300, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the types have different base types"))(a0$$95)(a1$$51)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleNumbersDiffer$$30230F9B(a0$$96, a1$$52, a2$$26) {
  return [301, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the number of %ss differ"))(a0$$96)(a1$$52)(a2$$26)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleSignatureDefinesButImplDoesNot$$Z46998140(a0$$97, a1$$53, a2$$27, a3$$2) {
  return [302, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the signature defines the %s '%s' but the implementation does not (or does, but not in the same order)"))(a0$$97)(a1$$53)(a2$$27)(a3$$2)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleImplDefinesButSignatureDoesNot$$Z46998140(a0$$98, a1$$54, a2$$28, a3$$3) {
  return [303, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the implementation defines the %s '%s' but the signature does not (or does, but not in the same order)"))(a0$$98)(a1$$54)(a2$$28)(a3$$3)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleImplDefinesStruct$$Z384F8060(a0$$99, a1$$55) {
  return [304, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the implementation defines a struct but the signature defines a type with a hidden representation"))(a0$$99)(a1$$55)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleDotNetTypeRepresentationIsHidden$$Z384F8060(a0$$100, a1$$56) {
  return [305, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because a CLI type representation is being hidden by a signature"))(a0$$100)(a1$$56)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleTypeIsHidden$$Z384F8060(a0$$101, a1$$57) {
  return [306, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because a type representation is being hidden by a signature"))(a0$$101)(a1$$57)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleTypeIsDifferentKind$$Z384F8060(a0$$102, a1$$58) {
  return [307, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the types are of different kinds"))(a0$$102)(a1$$58)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleILDiffer$$Z384F8060(a0$$103, a1$$59) {
  return [308, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the IL representations differ"))(a0$$103)(a1$$59)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleRepresentationsDiffer$$Z384F8060(a0$$104, a1$$60) {
  return [309, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the representations differ"))(a0$$104)(a1$$60)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleFieldWasPresent$$30230F9B(a0$$105, a1$$61, a2$$29) {
  return [311, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the field %s was present in the implementation but not in the signature"))(a0$$105)(a1$$61)(a2$$29)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleFieldOrderDiffer$$Z384F8060(a0$$106, a1$$62) {
  return [312, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the order of the fields is different in the signature and implementation"))(a0$$106)(a1$$62)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleFieldRequiredButNotSpecified$$30230F9B(a0$$107, a1$$63, a2$$30) {
  return [313, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the field %s was required by the signature but was not specified by the implementation"))(a0$$107)(a1$$63)(a2$$30)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleFieldIsInImplButNotSig$$30230F9B(a0$$108, a1$$64, a2$$31) {
  return [314, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the field '%s' was present in the implementation but not in the signature. Struct types must now reveal their fields in the signature for the type, though the fields may still be labelled 'private' or 'internal'."))(a0$$108)(a1$$64)(a2$$31)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInImpl$$30230F9B(a0$$109, a1$$65, a2$$32) {
  return [315, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the abstract member '%s' was required by the signature but was not specified by the implementation"))(a0$$109)(a1$$65)(a2$$32)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleAbstractMemberMissingInSig$$30230F9B(a0$$110, a1$$66, a2$$33) {
  return [316, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the abstract member '%s' was present in the implementation but not in the signature"))(a0$$110)(a1$$66)(a2$$33)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleSignatureDeclaresDiffer$$Z46998140(a0$$111, a1$$67, a2$$34, a3$$4) {
  return [317, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the signature declares a %s while the implementation declares a %s"))(a0$$111)(a1$$67)(a2$$34)(a3$$4)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleAbbreviationsDiffer$$Z46998140(a0$$112, a1$$68, a2$$35, a3$$5) {
  return [318, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the abbreviations differ: %s versus %s"))(a0$$112)(a1$$68)(a2$$35)(a3$$5)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleAbbreviationHiddenBySig$$Z384F8060(a0$$113, a1$$69) {
  return [319, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because an abbreviation is being hidden by a signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature."))(a0$$113)(a1$$69)];
}

function SR$$$DefinitionsInSigAndImplNotCompatibleSigHasAbbreviation$$Z384F8060(a0$$114, a1$$70) {
  return [320, (0, _String.toText)((0, _String.printf)("The %s definitions for type '%s' in the signature and implementation are not compatible because the signature has an abbreviation while the implementation does not"))(a0$$114)(a1$$70)];
}

function SR$$$ModuleContainsConstructorButNamesDiffer$$Z384F8060(a0$$115, a1$$71) {
  return (0, _String.toText)((0, _String.printf)("The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe names differ"))(a0$$115)(a1$$71);
}

function SR$$$ModuleContainsConstructorButDataFieldsDiffer$$Z384F8060(a0$$116, a1$$72) {
  return (0, _String.toText)((0, _String.printf)("The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe respective number of data fields differ"))(a0$$116)(a1$$72);
}

function SR$$$ModuleContainsConstructorButTypesOfFieldsDiffer$$Z384F8060(a0$$117, a1$$73) {
  return (0, _String.toText)((0, _String.printf)("The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nThe types of the fields differ"))(a0$$117)(a1$$73);
}

function SR$$$ModuleContainsConstructorButAccessibilityDiffers$$Z384F8060(a0$$118, a1$$74) {
  return (0, _String.toText)((0, _String.printf)("The module contains the constructor\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation"))(a0$$118)(a1$$74);
}

function SR$$$FieldNotContainedNamesDiffer$$Z384F8060(a0$$119, a1$$75) {
  return (0, _String.toText)((0, _String.printf)("The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe names differ"))(a0$$119)(a1$$75);
}

function SR$$$FieldNotContainedAccessibilitiesDiffer$$Z384F8060(a0$$120, a1$$76) {
  return (0, _String.toText)((0, _String.printf)("The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nthe accessibility specified in the signature is more than that specified in the implementation"))(a0$$120)(a1$$76);
}

function SR$$$FieldNotContainedStaticsDiffer$$Z384F8060(a0$$121, a1$$77) {
  return (0, _String.toText)((0, _String.printf)("The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe 'static' modifiers differ"))(a0$$121)(a1$$77);
}

function SR$$$FieldNotContainedMutablesDiffer$$Z384F8060(a0$$122, a1$$78) {
  return (0, _String.toText)((0, _String.printf)("The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe 'mutable' modifiers differ"))(a0$$122)(a1$$78);
}

function SR$$$FieldNotContainedLiteralsDiffer$$Z384F8060(a0$$123, a1$$79) {
  return (0, _String.toText)((0, _String.printf)("The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe 'literal' modifiers differ"))(a0$$123)(a1$$79);
}

function SR$$$FieldNotContainedTypesDiffer$$Z384F8060(a0$$124, a1$$80) {
  return (0, _String.toText)((0, _String.printf)("The module contains the field\n    %s    \nbut its signature specifies\n    %s    \nThe types differ"))(a0$$124)(a1$$80);
}

function SR$$$typrelCannotResolveImplicitGenericInstantiation$$Z384F8060(a0$$125, a1$$81) {
  return [331, (0, _String.toText)((0, _String.printf)("The implicit instantiation of a generic construct at or near this point could not be resolved because it could resolve to multiple unrelated types, e.g. '%s' and '%s'. Consider using type annotations to resolve the ambiguity"))(a0$$125)(a1$$81)];
}

function SR$$$typrelCannotResolveAmbiguityInPrintf() {
  return [333, (0, _String.toText)((0, _String.printf)("Could not resolve the ambiguity inherent in the use of a 'printf'-style format string"))];
}

function SR$$$typrelCannotResolveAmbiguityInEnum() {
  return [334, (0, _String.toText)((0, _String.printf)("Could not resolve the ambiguity in the use of a generic construct with an 'enum' constraint at or near this position"))];
}

function SR$$$typrelCannotResolveAmbiguityInDelegate() {
  return [335, (0, _String.toText)((0, _String.printf)("Could not resolve the ambiguity in the use of a generic construct with a 'delegate' constraint at or near this position"))];
}

function SR$$$typrelInvalidValue() {
  return [337, (0, _String.toText)((0, _String.printf)("Invalid value"))];
}

function SR$$$typrelSigImplNotCompatibleParamCountsDiffer() {
  return [338, (0, _String.toText)((0, _String.printf)("The signature and implementation are not compatible because the respective type parameter counts differ"))];
}

function SR$$$typrelSigImplNotCompatibleCompileTimeRequirementsDiffer() {
  return [339, (0, _String.toText)((0, _String.printf)("The signature and implementation are not compatible because the type parameter in the class/signature has a different compile-time requirement to the one in the member/implementation"))];
}

function SR$$$typrelSigImplNotCompatibleConstraintsDiffer$$Z384F8060(a0$$126, a1$$82) {
  return [340, (0, _String.toText)((0, _String.printf)("The signature and implementation are not compatible because the declaration of the type parameter '%s' requires a constraint of the form %s"))(a0$$126)(a1$$82)];
}

function SR$$$typrelSigImplNotCompatibleConstraintsDifferRemove$$Z384F8060(a0$$127, a1$$83) {
  return [341, (0, _String.toText)((0, _String.printf)("The signature and implementation are not compatible because the type parameter '%s' has a constraint of the form %s but the implementation does not. Either remove this constraint from the signature or add it to the implementation."))(a0$$127)(a1$$83)];
}

function SR$$$typrelTypeImplementsIComparableShouldOverrideObjectEquals$$Z721C83C5(a0$$128) {
  return [342, (0, _String.toText)((0, _String.printf)("The type '%s' implements 'System.IComparable'. Consider also adding an explicit override for 'Object.Equals'"))(a0$$128)];
}

function SR$$$typrelTypeImplementsIComparableDefaultObjectEqualsProvided$$Z721C83C5(a0$$129) {
  return [343, (0, _String.toText)((0, _String.printf)("The type '%s' implements 'System.IComparable' explicitly but provides no corresponding override for 'Object.Equals'. An implementation of 'Object.Equals' has been automatically provided, implemented via 'System.IComparable'. Consider implementing the override 'Object.Equals' explicitly"))(a0$$129)];
}

function SR$$$typrelExplicitImplementationOfGetHashCodeOrEquals$$Z721C83C5(a0$$130) {
  return [344, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' has an explicit implementation of 'Object.GetHashCode' or 'Object.Equals'. You must apply the 'CustomEquality' attribute to the type"))(a0$$130)];
}

function SR$$$typrelExplicitImplementationOfGetHashCode$$Z721C83C5(a0$$131) {
  return [345, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' has an explicit implementation of 'Object.GetHashCode'. Consider implementing a matching override for 'Object.Equals(obj)'"))(a0$$131)];
}

function SR$$$typrelExplicitImplementationOfEquals$$Z721C83C5(a0$$132) {
  return [346, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' has an explicit implementation of 'Object.Equals'. Consider implementing a matching override for 'Object.GetHashCode()'"))(a0$$132)];
}

function SR$$$ExceptionDefsNotCompatibleHiddenBySignature$$Z384F8060(a0$$133, a1$$84) {
  return (0, _String.toText)((0, _String.printf)("The exception definitions are not compatible because a CLI exception mapping is being hidden by a signature. The exception mapping must be visible to other modules. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s"))(a0$$133)(a1$$84);
}

function SR$$$ExceptionDefsNotCompatibleDotNetRepresentationsDiffer$$Z384F8060(a0$$134, a1$$85) {
  return (0, _String.toText)((0, _String.printf)("The exception definitions are not compatible because the CLI representations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s"))(a0$$134)(a1$$85);
}

function SR$$$ExceptionDefsNotCompatibleAbbreviationHiddenBySignature$$Z384F8060(a0$$135, a1$$86) {
  return (0, _String.toText)((0, _String.printf)("The exception definitions are not compatible because the exception abbreviation is being hidden by the signature. The abbreviation must be visible to other CLI languages. Consider making the abbreviation visible in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s."))(a0$$135)(a1$$86);
}

function SR$$$ExceptionDefsNotCompatibleSignaturesDiffer$$Z384F8060(a0$$136, a1$$87) {
  return (0, _String.toText)((0, _String.printf)("The exception definitions are not compatible because the exception abbreviations in the signature and implementation differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s."))(a0$$136)(a1$$87);
}

function SR$$$ExceptionDefsNotCompatibleExceptionDeclarationsDiffer$$Z384F8060(a0$$137, a1$$88) {
  return (0, _String.toText)((0, _String.printf)("The exception definitions are not compatible because the exception declarations differ. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s."))(a0$$137)(a1$$88);
}

function SR$$$ExceptionDefsNotCompatibleFieldInSigButNotImpl$$30230F9B(a0$$138, a1$$89, a2$$36) {
  return (0, _String.toText)((0, _String.printf)("The exception definitions are not compatible because the field '%s' was required by the signature but was not specified by the implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s."))(a0$$138)(a1$$89)(a2$$36);
}

function SR$$$ExceptionDefsNotCompatibleFieldInImplButNotSig$$30230F9B(a0$$139, a1$$90, a2$$37) {
  return (0, _String.toText)((0, _String.printf)("The exception definitions are not compatible because the field '%s' was present in the implementation but not in the signature. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s."))(a0$$139)(a1$$90)(a2$$37);
}

function SR$$$ExceptionDefsNotCompatibleFieldOrderDiffers$$Z384F8060(a0$$140, a1$$91) {
  return (0, _String.toText)((0, _String.printf)("The exception definitions are not compatible because the order of the fields is different in the signature and implementation. The module contains the exception definition\n    %s    \nbut its signature specifies\n\t%s."))(a0$$140)(a1$$91);
}

function SR$$$typrelModuleNamespaceAttributesDifferInSigAndImpl() {
  return [355, (0, _String.toText)((0, _String.printf)("The namespace or module attributes differ between signature and implementation"))];
}

function SR$$$typrelMethodIsOverconstrained() {
  return [356, (0, _String.toText)((0, _String.printf)("This method is over-constrained in its type parameters"))];
}

function SR$$$typrelOverloadNotFound$$Z384F8060(a0$$141, a1$$92) {
  return [357, (0, _String.toText)((0, _String.printf)("No implementations of '%s' had the correct number of arguments and type parameters. The required signature is '%s'."))(a0$$141)(a1$$92)];
}

function SR$$$typrelOverrideWasAmbiguous$$Z721C83C5(a0$$142) {
  return [358, (0, _String.toText)((0, _String.printf)("The override for '%s' was ambiguous"))(a0$$142)];
}

function SR$$$typrelMoreThenOneOverride$$Z721C83C5(a0$$143) {
  return [359, (0, _String.toText)((0, _String.printf)("More than one override implements '%s'"))(a0$$143)];
}

function SR$$$typrelMethodIsSealed$$Z721C83C5(a0$$144) {
  return [360, (0, _String.toText)((0, _String.printf)("The method '%s' is sealed and cannot be overridden"))(a0$$144)];
}

function SR$$$typrelOverrideImplementsMoreThenOneSlot$$30230F9B(a0$$145, a1$$93, a2$$38) {
  return [361, (0, _String.toText)((0, _String.printf)("The override '%s' implements more than one abstract slot, e.g. '%s' and '%s'"))(a0$$145)(a1$$93)(a2$$38)];
}

function SR$$$typrelDuplicateInterface() {
  return [362, (0, _String.toText)((0, _String.printf)("Duplicate or redundant interface"))];
}

function SR$$$typrelNeedExplicitImplementation$$Z721C83C5(a0$$146) {
  return [363, (0, _String.toText)((0, _String.printf)("The interface '%s' is included in multiple explicitly implemented interface types. Add an explicit implementation of this interface."))(a0$$146)];
}

function SR$$$typrelNamedArgumentHasBeenAssignedMoreThenOnce() {
  return [364, (0, _String.toText)((0, _String.printf)("A named argument has been assigned more than one value"))];
}

function SR$$$typrelNoImplementationGiven$$Z721C83C5(a0$$147) {
  return [365, (0, _String.toText)((0, _String.printf)("No implementation was given for '%s'"))(a0$$147)];
}

function SR$$$typrelNoImplementationGivenWithSuggestion$$Z721C83C5(a0$$148) {
  return [366, (0, _String.toText)((0, _String.printf)("No implementation was given for '%s'. Note that all interface members must be implemented and listed under an appropriate 'interface' declaration, e.g. 'interface ... with member ...'."))(a0$$148)];
}

function SR$$$typrelMemberDoesNotHaveCorrectNumberOfArguments$$Z384F8060(a0$$149, a1$$94) {
  return [367, (0, _String.toText)((0, _String.printf)("The member '%s' does not have the correct number of arguments. The required signature is '%s'."))(a0$$149)(a1$$94)];
}

function SR$$$typrelMemberDoesNotHaveCorrectNumberOfTypeParameters$$Z384F8060(a0$$150, a1$$95) {
  return [368, (0, _String.toText)((0, _String.printf)("The member '%s' does not have the correct number of method type parameters. The required signature is '%s'."))(a0$$150)(a1$$95)];
}

function SR$$$typrelMemberDoesNotHaveCorrectKindsOfGenericParameters$$Z384F8060(a0$$151, a1$$96) {
  return [369, (0, _String.toText)((0, _String.printf)("The member '%s' does not have the correct kinds of generic parameters. The required signature is '%s'."))(a0$$151)(a1$$96)];
}

function SR$$$typrelMemberCannotImplement$$30230F9B(a0$$152, a1$$97, a2$$39) {
  return [370, (0, _String.toText)((0, _String.printf)("The member '%s' cannot be used to implement '%s'. The required signature is '%s'."))(a0$$152)(a1$$97)(a2$$39)];
}

function SR$$$astParseEmbeddedILError() {
  return [371, (0, _String.toText)((0, _String.printf)("Error while parsing embedded IL"))];
}

function SR$$$astParseEmbeddedILTypeError() {
  return [372, (0, _String.toText)((0, _String.printf)("Error while parsing embedded IL type"))];
}

function SR$$$astDeprecatedIndexerNotation() {
  return (0, _String.toText)((0, _String.printf)("This indexer notation has been removed from the F# language"));
}

function SR$$$astInvalidExprLeftHandOfAssignment() {
  return [374, (0, _String.toText)((0, _String.printf)("Invalid expression on left of assignment"))];
}

function SR$$$augNoRefEqualsOnStruct() {
  return [376, (0, _String.toText)((0, _String.printf)("The 'ReferenceEquality' attribute cannot be used on structs. Consider using the 'StructuralEquality' attribute instead, or implement an override for 'System.Object.Equals(obj)'."))];
}

function SR$$$augInvalidAttrs() {
  return [377, (0, _String.toText)((0, _String.printf)("This type uses an invalid mix of the attributes 'NoEquality', 'ReferenceEquality', 'StructuralEquality', 'NoComparison' and 'StructuralComparison'"))];
}

function SR$$$augNoEqualityNeedsNoComparison() {
  return [378, (0, _String.toText)((0, _String.printf)("The 'NoEquality' attribute must be used in conjunction with the 'NoComparison' attribute"))];
}

function SR$$$augStructCompNeedsStructEquality() {
  return [379, (0, _String.toText)((0, _String.printf)("The 'StructuralComparison' attribute must be used in conjunction with the 'StructuralEquality' attribute"))];
}

function SR$$$augStructEqNeedsNoCompOrStructComp() {
  return [380, (0, _String.toText)((0, _String.printf)("The 'StructuralEquality' attribute must be used in conjunction with the 'NoComparison' or 'StructuralComparison' attributes"))];
}

function SR$$$augTypeCantHaveRefEqAndStructAttrs() {
  return [381, (0, _String.toText)((0, _String.printf)("A type cannot have both the 'ReferenceEquality' and 'StructuralEquality' or 'StructuralComparison' attributes"))];
}

function SR$$$augOnlyCertainTypesCanHaveAttrs() {
  return [382, (0, _String.toText)((0, _String.printf)("Only record, union, exception and struct types may be augmented with the 'ReferenceEquality', 'StructuralEquality' and 'StructuralComparison' attributes"))];
}

function SR$$$augRefEqCantHaveObjEquals() {
  return [383, (0, _String.toText)((0, _String.printf)("A type with attribute 'ReferenceEquality' cannot have an explicit implementation of 'Object.Equals(obj)', 'System.IEquatable<_>' or 'System.Collections.IStructuralEquatable'"))];
}

function SR$$$augCustomEqNeedsObjEquals() {
  return [384, (0, _String.toText)((0, _String.printf)("A type with attribute 'CustomEquality' must have an explicit implementation of at least one of 'Object.Equals(obj)', 'System.IEquatable<_>' or 'System.Collections.IStructuralEquatable'"))];
}

function SR$$$augCustomCompareNeedsIComp() {
  return [385, (0, _String.toText)((0, _String.printf)("A type with attribute 'CustomComparison' must have an explicit implementation of at least one of 'System.IComparable' or 'System.Collections.IStructuralComparable'"))];
}

function SR$$$augNoEqNeedsNoObjEquals() {
  return [386, (0, _String.toText)((0, _String.printf)("A type with attribute 'NoEquality' should not usually have an explicit implementation of 'Object.Equals(obj)'. Disable this warning if this is intentional for interoperability purposes"))];
}

function SR$$$augNoCompCantImpIComp() {
  return [386, (0, _String.toText)((0, _String.printf)("A type with attribute 'NoComparison' should not usually have an explicit implementation of 'System.IComparable', 'System.IComparable<_>' or 'System.Collections.IStructuralComparable'. Disable this warning if this is intentional for interoperability purposes"))];
}

function SR$$$augCustomEqNeedsNoCompOrCustomComp() {
  return [387, (0, _String.toText)((0, _String.printf)("The 'CustomEquality' attribute must be used in conjunction with the 'NoComparison' or 'CustomComparison' attributes"))];
}

function SR$$$forPositionalSpecifiersNotPermitted() {
  return (0, _String.toText)((0, _String.printf)("Positional specifiers are not permitted in format strings"));
}

function SR$$$forMissingFormatSpecifier() {
  return (0, _String.toText)((0, _String.printf)("Missing format specifier"));
}

function SR$$$forFlagSetTwice$$Z721C83C5(a0$$153) {
  return (0, _String.toText)((0, _String.printf)("'%s' flag set twice"))(a0$$153);
}

function SR$$$forPrefixFlagSpacePlusSetTwice() {
  return (0, _String.toText)((0, _String.printf)("Prefix flag (' ' or '+') set twice"));
}

function SR$$$forHashSpecifierIsInvalid() {
  return (0, _String.toText)((0, _String.printf)("The # formatting modifier is invalid in F#"));
}

function SR$$$forBadPrecision() {
  return (0, _String.toText)((0, _String.printf)("Bad precision in format specifier"));
}

function SR$$$forBadWidth() {
  return (0, _String.toText)((0, _String.printf)("Bad width in format specifier"));
}

function SR$$$forDoesNotSupportZeroFlag$$Z721C83C5(a0$$154) {
  return (0, _String.toText)((0, _String.printf)("'%s' format does not support '0' flag"))(a0$$154);
}

function SR$$$forPrecisionMissingAfterDot() {
  return (0, _String.toText)((0, _String.printf)("Precision missing after the '.'"));
}

function SR$$$forFormatDoesntSupportPrecision$$Z721C83C5(a0$$155) {
  return (0, _String.toText)((0, _String.printf)("'%s' format does not support precision"))(a0$$155);
}

function SR$$$forBadFormatSpecifier() {
  return (0, _String.toText)((0, _String.printf)("Bad format specifier (after l or L): Expected ld,li,lo,lu,lx or lX. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types."));
}

function SR$$$forLIsUnnecessary() {
  return (0, _String.toText)((0, _String.printf)("The 'l' or 'L' in this format specifier is unnecessary. In F# code you can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types."));
}

function SR$$$forHIsUnnecessary() {
  return (0, _String.toText)((0, _String.printf)("The 'h' or 'H' in this format specifier is unnecessary. You can use %%d, %%x, %%o or %%u instead, which are overloaded to work with all basic integer types."));
}

function SR$$$forDoesNotSupportPrefixFlag$$Z384F8060(a0$$156, a1$$98) {
  return (0, _String.toText)((0, _String.printf)("'%s' does not support prefix '%s' flag"))(a0$$156)(a1$$98);
}

function SR$$$forBadFormatSpecifierGeneral$$Z721C83C5(a0$$157) {
  return (0, _String.toText)((0, _String.printf)("Bad format specifier: '%s'"))(a0$$157);
}

function SR$$$elSysEnvExitDidntExit() {
  return (0, _String.toText)((0, _String.printf)("System.Environment.Exit did not exit"));
}

function SR$$$elDeprecatedOperator() {
  return (0, _String.toText)((0, _String.printf)("The treatment of this operator is now handled directly by the F# compiler and its meaning cannot be redefined"));
}

function SR$$$chkProtectedOrBaseCalled() {
  return [405, (0, _String.toText)((0, _String.printf)("A protected member is called or 'base' is being used. This is only allowed in the direct implementation of members since they could escape their object scope."))];
}

function SR$$$chkByrefUsedInInvalidWay$$Z721C83C5(a0$$158) {
  return [406, (0, _String.toText)((0, _String.printf)("The byref-typed variable '%s' is used in an invalid way. Byrefs cannot be captured by closures or passed to inner functions."))(a0$$158)];
}

function SR$$$chkBaseUsedInInvalidWay() {
  return [408, (0, _String.toText)((0, _String.printf)("The 'base' keyword is used in an invalid way. Base calls cannot be used in closures. Consider using a private member to make base calls."))];
}

function SR$$$chkVariableUsedInInvalidWay$$Z721C83C5(a0$$159) {
  return (0, _String.toText)((0, _String.printf)("The variable '%s' is used in an invalid way"))(a0$$159);
}

function SR$$$chkTypeLessAccessibleThanType$$Z384F8060(a0$$160, a1$$99) {
  return [410, (0, _String.toText)((0, _String.printf)("The type '%s' is less accessible than the value, member or type '%s' it is used in."))(a0$$160)(a1$$99)];
}

function SR$$$chkSystemVoidOnlyInTypeof() {
  return [411, (0, _String.toText)((0, _String.printf)("'System.Void' can only be used as 'typeof<System.Void>' in F#"))];
}

function SR$$$chkErrorUseOfByref() {
  return [412, (0, _String.toText)((0, _String.printf)("A type instantiation involves a byref type. This is not permitted by the rules of Common IL."))];
}

function SR$$$chkErrorContainsCallToRethrow() {
  return [413, (0, _String.toText)((0, _String.printf)("Calls to 'reraise' may only occur directly in a handler of a try-with"))];
}

function SR$$$chkSplicingOnlyInQuotations() {
  return [414, (0, _String.toText)((0, _String.printf)("Expression-splicing operators may only be used within quotations"))];
}

function SR$$$chkNoFirstClassSplicing() {
  return [415, (0, _String.toText)((0, _String.printf)("First-class uses of the expression-splicing operator are not permitted"))];
}

function SR$$$chkNoFirstClassAddressOf() {
  return [416, (0, _String.toText)((0, _String.printf)("First-class uses of the address-of operators are not permitted"))];
}

function SR$$$chkNoFirstClassRethrow() {
  return [417, (0, _String.toText)((0, _String.printf)("First-class uses of the 'reraise' function is not permitted"))];
}

function SR$$$chkNoByrefAtThisPoint$$Z721C83C5(a0$$161) {
  return [418, (0, _String.toText)((0, _String.printf)("The byref typed value '%s' cannot be used at this point"))(a0$$161)];
}

function SR$$$chkLimitationsOfBaseKeyword() {
  return [419, (0, _String.toText)((0, _String.printf)("'base' values may only be used to make direct calls to the base implementations of overridden members"))];
}

function SR$$$chkObjCtorsCantUseExceptionHandling() {
  return [420, (0, _String.toText)((0, _String.printf)("Object constructors cannot directly use try/with and try/finally prior to the initialization of the object. This includes constructs such as 'for x in ...' that may elaborate to uses of these constructs. This is a limitation imposed by Common IL."))];
}

function SR$$$chkNoAddressOfAtThisPoint$$Z721C83C5(a0$$162) {
  return [421, (0, _String.toText)((0, _String.printf)("The address of the variable '%s' cannot be used at this point"))(a0$$162)];
}

function SR$$$chkNoAddressStaticFieldAtThisPoint$$Z721C83C5(a0$$163) {
  return [422, (0, _String.toText)((0, _String.printf)("The address of the static field '%s' cannot be used at this point"))(a0$$163)];
}

function SR$$$chkNoAddressFieldAtThisPoint$$Z721C83C5(a0$$164) {
  return [423, (0, _String.toText)((0, _String.printf)("The address of the field '%s' cannot be used at this point"))(a0$$164)];
}

function SR$$$chkNoAddressOfArrayElementAtThisPoint() {
  return [424, (0, _String.toText)((0, _String.printf)("The address of an array element cannot be used at this point"))];
}

function SR$$$chkFirstClassFuncNoByref() {
  return [425, (0, _String.toText)((0, _String.printf)("The type of a first-class function cannot contain byrefs"))];
}

function SR$$$chkReturnTypeNoByref() {
  return [426, (0, _String.toText)((0, _String.printf)("A method return type would contain byrefs which is not permitted"))];
}

function SR$$$chkInvalidCustAttrVal() {
  return [428, (0, _String.toText)((0, _String.printf)("Invalid custom attribute value (not a constant or literal)"))];
}

function SR$$$chkAttrHasAllowMultiFalse$$Z721C83C5(a0$$165) {
  return [429, (0, _String.toText)((0, _String.printf)("The attribute type '%s' has 'AllowMultiple=false'. Multiple instances of this attribute cannot be attached to a single language element."))(a0$$165)];
}

function SR$$$chkMemberUsedInInvalidWay$$30230F9B(a0$$166, a1$$100, a2$$40) {
  return [430, (0, _String.toText)((0, _String.printf)("The member '%s' is used in an invalid way. A use of '%s' has been inferred prior to its definition at or near '%s'. This is an invalid forward reference."))(a0$$166)(a1$$100)(a2$$40)];
}

function SR$$$chkNoByrefAsTopValue() {
  return [431, (0, _String.toText)((0, _String.printf)("A byref typed value would be stored here. Top-level let-bound byref values are not permitted."))];
}

function SR$$$chkReflectedDefCantSplice() {
  return [432, (0, _String.toText)((0, _String.printf)("[<ReflectedDefinition>] terms cannot contain uses of the prefix splice operator '%%'"))];
}

function SR$$$chkEntryPointUsage() {
  return [433, (0, _String.toText)((0, _String.printf)("A function labeled with the 'EntryPointAttribute' attribute must be the last declaration in the last file in the compilation sequence."))];
}

function SR$$$chkUnionCaseCompiledForm() {
  return (0, _String.toText)((0, _String.printf)("compiled form of the union case"));
}

function SR$$$chkUnionCaseDefaultAugmentation() {
  return (0, _String.toText)((0, _String.printf)("default augmentation of the union case"));
}

function SR$$$chkPropertySameNameMethod$$Z384F8060(a0$$167, a1$$101) {
  return [434, (0, _String.toText)((0, _String.printf)("The property '%s' has the same name as a method in type '%s'."))(a0$$167)(a1$$101)];
}

function SR$$$chkGetterSetterDoNotMatchAbstract$$Z384F8060(a0$$168, a1$$102) {
  return [435, (0, _String.toText)((0, _String.printf)("The property '%s' of type '%s' has a getter and a setter that do not match. If one is abstract then the other must be as well."))(a0$$168)(a1$$102)];
}

function SR$$$chkPropertySameNameIndexer$$Z384F8060(a0$$169, a1$$103) {
  return [436, (0, _String.toText)((0, _String.printf)("The property '%s' has the same name as another property in type '%s', but one takes indexer arguments and the other does not. You may be missing an indexer argument to one of your properties."))(a0$$169)(a1$$103)];
}

function SR$$$chkCantStoreByrefValue() {
  return [437, (0, _String.toText)((0, _String.printf)("A type would store a byref typed value. This is not permitted by Common IL."))];
}

function SR$$$chkDuplicateMethod$$Z384F8060(a0$$170, a1$$104) {
  return [438, (0, _String.toText)((0, _String.printf)("Duplicate method. The method '%s' has the same name and signature as another method in type '%s'."))(a0$$170)(a1$$104)];
}

function SR$$$chkDuplicateMethodWithSuffix$$Z384F8060(a0$$171, a1$$105) {
  return [438, (0, _String.toText)((0, _String.printf)("Duplicate method. The method '%s' has the same name and signature as another method in type '%s' once tuples, functions, units of measure and/or provided types are erased."))(a0$$171)(a1$$105)];
}

function SR$$$chkDuplicateMethodCurried$$Z384F8060(a0$$172, a1$$106) {
  return [439, (0, _String.toText)((0, _String.printf)("The method '%s' has curried arguments but has the same name as another method in type '%s'. Methods with curried arguments cannot be overloaded. Consider using a method taking tupled arguments."))(a0$$172)(a1$$106)];
}

function SR$$$chkCurriedMethodsCantHaveOutParams() {
  return [440, (0, _String.toText)((0, _String.printf)("Methods with curried arguments cannot declare 'out', 'ParamArray', 'optional', 'ReflectedDefinition', 'byref', 'CallerLineNumber', 'CallerMemberName', or 'CallerFilePath' arguments"))];
}

function SR$$$chkDuplicateProperty$$Z384F8060(a0$$173, a1$$107) {
  return [441, (0, _String.toText)((0, _String.printf)("Duplicate property. The property '%s' has the same name and signature as another property in type '%s'."))(a0$$173)(a1$$107)];
}

function SR$$$chkDuplicatePropertyWithSuffix$$Z384F8060(a0$$174, a1$$108) {
  return [441, (0, _String.toText)((0, _String.printf)("Duplicate property. The property '%s' has the same name and signature as another property in type '%s' once tuples, functions, units of measure and/or provided types are erased."))(a0$$174)(a1$$108)];
}

function SR$$$chkDuplicateMethodInheritedType$$Z721C83C5(a0$$175) {
  return [442, (0, _String.toText)((0, _String.printf)("Duplicate method. The abstract method '%s' has the same name and signature as an abstract method in an inherited type."))(a0$$175)];
}

function SR$$$chkDuplicateMethodInheritedTypeWithSuffix$$Z721C83C5(a0$$176) {
  return [442, (0, _String.toText)((0, _String.printf)("Duplicate method. The abstract method '%s' has the same name and signature as an abstract method in an inherited type once tuples, functions, units of measure and/or provided types are erased."))(a0$$176)];
}

function SR$$$chkMultipleGenericInterfaceInstantiations$$Z384F8060(a0$$177, a1$$109) {
  return [443, (0, _String.toText)((0, _String.printf)("This type implements the same interface at different generic instantiations '%s' and '%s'. This is not permitted in this version of F#."))(a0$$177)(a1$$109)];
}

function SR$$$chkValueWithDefaultValueMustHaveDefaultValue() {
  return [444, (0, _String.toText)((0, _String.printf)("The type of a field using the 'DefaultValue' attribute must admit default initialization, i.e. have 'null' as a proper value or be a struct type whose fields all admit default initialization. You can use 'DefaultValue(false)' to disable this check"))];
}

function SR$$$chkNoByrefInTypeAbbrev() {
  return [445, (0, _String.toText)((0, _String.printf)("The type abbreviation contains byrefs. This is not permitted by F#."))];
}

function SR$$$crefBoundVarUsedInSplice$$Z721C83C5(a0$$178) {
  return [446, (0, _String.toText)((0, _String.printf)("The variable '%s' is bound in a quotation but is used as part of a spliced expression. This is not permitted since it may escape its scope."))(a0$$178)];
}

function SR$$$crefQuotationsCantContainGenericExprs() {
  return [447, (0, _String.toText)((0, _String.printf)("Quotations cannot contain uses of generic expressions"))];
}

function SR$$$crefQuotationsCantContainGenericFunctions() {
  return [448, (0, _String.toText)((0, _String.printf)("Quotations cannot contain function definitions that are inferred or declared to be generic. Consider adding some type constraints to make this a valid quoted expression."))];
}

function SR$$$crefQuotationsCantContainObjExprs() {
  return [449, (0, _String.toText)((0, _String.printf)("Quotations cannot contain object expressions"))];
}

function SR$$$crefQuotationsCantContainAddressOf() {
  return [450, (0, _String.toText)((0, _String.printf)("Quotations cannot contain expressions that take the address of a field"))];
}

function SR$$$crefQuotationsCantContainStaticFieldRef() {
  return [451, (0, _String.toText)((0, _String.printf)("Quotations cannot contain expressions that fetch static fields"))];
}

function SR$$$crefQuotationsCantContainInlineIL() {
  return [452, (0, _String.toText)((0, _String.printf)("Quotations cannot contain inline assembly code or pattern matching on arrays"))];
}

function SR$$$crefQuotationsCantContainDescendingForLoops() {
  return [453, (0, _String.toText)((0, _String.printf)("Quotations cannot contain descending for loops"))];
}

function SR$$$crefQuotationsCantFetchUnionIndexes() {
  return [454, (0, _String.toText)((0, _String.printf)("Quotations cannot contain expressions that fetch union case indexes"))];
}

function SR$$$crefQuotationsCantSetUnionFields() {
  return [455, (0, _String.toText)((0, _String.printf)("Quotations cannot contain expressions that set union case fields"))];
}

function SR$$$crefQuotationsCantSetExceptionFields() {
  return [456, (0, _String.toText)((0, _String.printf)("Quotations cannot contain expressions that set fields in exception values"))];
}

function SR$$$crefQuotationsCantRequireByref() {
  return [457, (0, _String.toText)((0, _String.printf)("Quotations cannot contain expressions that require byref pointers"))];
}

function SR$$$crefQuotationsCantCallTraitMembers() {
  return [458, (0, _String.toText)((0, _String.printf)("Quotations cannot contain expressions that make member constraint calls, or uses of operators that implicitly resolve to a member constraint call"))];
}

function SR$$$crefQuotationsCantContainThisConstant() {
  return [459, (0, _String.toText)((0, _String.printf)("Quotations cannot contain this kind of constant"))];
}

function SR$$$crefQuotationsCantContainThisPatternMatch() {
  return [460, (0, _String.toText)((0, _String.printf)("Quotations cannot contain this kind of pattern match"))];
}

function SR$$$crefQuotationsCantContainArrayPatternMatching() {
  return [461, (0, _String.toText)((0, _String.printf)("Quotations cannot contain array pattern matching"))];
}

function SR$$$crefQuotationsCantContainThisType() {
  return [462, (0, _String.toText)((0, _String.printf)("Quotations cannot contain this kind of type"))];
}

function SR$$$csTypeCannotBeResolvedAtCompileTime$$Z721C83C5(a0$$179) {
  return (0, _String.toText)((0, _String.printf)("The declared type parameter '%s' cannot be used here since the type parameter cannot be resolved at compile time"))(a0$$179);
}

function SR$$$csCodeLessGeneric() {
  return [464, (0, _String.toText)((0, _String.printf)("This code is less generic than indicated by its annotations. A unit-of-measure specified using '_' has been determined to be '1', i.e. dimensionless. Consider making the code generic, or removing the use of '_'."))];
}

function SR$$$csTypeInferenceMaxDepth() {
  return [465, (0, _String.toText)((0, _String.printf)("Type inference problem too complicated (maximum iteration depth reached). Consider adding further type annotations."))];
}

function SR$$$csExpectedArguments() {
  return (0, _String.toText)((0, _String.printf)("Expected arguments to an instance member"));
}

function SR$$$csIndexArgumentMismatch$$Z37302880(a0$$180, a1$$110) {
  return (0, _String.toText)((0, _String.printf)("This indexer expects %d arguments but is here given %d"))(a0$$180)(a1$$110);
}

function SR$$$csExpectTypeWithOperatorButGivenFunction$$Z721C83C5(a0$$181) {
  return (0, _String.toText)((0, _String.printf)("Expecting a type supporting the operator '%s' but given a function type. You may be missing an argument to a function."))(a0$$181);
}

function SR$$$csExpectTypeWithOperatorButGivenTuple$$Z721C83C5(a0$$182) {
  return (0, _String.toText)((0, _String.printf)("Expecting a type supporting the operator '%s' but given a tuple type"))(a0$$182);
}

function SR$$$csTypesDoNotSupportOperator$$Z384F8060(a0$$183, a1$$111) {
  return (0, _String.toText)((0, _String.printf)("None of the types '%s' support the operator '%s'"))(a0$$183)(a1$$111);
}

function SR$$$csTypeDoesNotSupportOperator$$Z384F8060(a0$$184, a1$$112) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not support the operator '%s'"))(a0$$184)(a1$$112);
}

function SR$$$csTypesDoNotSupportOperatorNullable$$Z384F8060(a0$$185, a1$$113) {
  return (0, _String.toText)((0, _String.printf)("None of the types '%s' support the operator '%s'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'."))(a0$$185)(a1$$113);
}

function SR$$$csTypeDoesNotSupportOperatorNullable$$Z384F8060(a0$$186, a1$$114) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not support the operator '%s'. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'."))(a0$$186)(a1$$114);
}

function SR$$$csTypeDoesNotSupportConversion$$Z384F8060(a0$$187, a1$$115) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not support a conversion to the type '%s'"))(a0$$187)(a1$$115);
}

function SR$$$csMethodFoundButIsStatic$$30230F9B(a0$$188, a1$$116, a2$$41) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' has a method '%s' (full name '%s'), but the method is static"))(a0$$188)(a1$$116)(a2$$41);
}

function SR$$$csMethodFoundButIsNotStatic$$30230F9B(a0$$189, a1$$117, a2$$42) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' has a method '%s' (full name '%s'), but the method is not static"))(a0$$189)(a1$$117)(a2$$42);
}

function SR$$$csStructConstraintInconsistent() {
  return [472, (0, _String.toText)((0, _String.printf)("The constraints 'struct' and 'not struct' are inconsistent"))];
}

function SR$$$csTypeDoesNotHaveNull$$Z721C83C5(a0$$190) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not have 'null' as a proper value"))(a0$$190);
}

function SR$$$csNullableTypeDoesNotHaveNull$$Z721C83C5(a0$$191) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not have 'null' as a proper value. To create a null value for a Nullable type use 'System.Nullable()'."))(a0$$191);
}

function SR$$$csTypeDoesNotSupportComparison1$$Z721C83C5(a0$$192) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not support the 'comparison' constraint because it has the 'NoComparison' attribute"))(a0$$192);
}

function SR$$$csTypeDoesNotSupportComparison2$$Z721C83C5(a0$$193) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface"))(a0$$193);
}

function SR$$$csTypeDoesNotSupportComparison3$$Z721C83C5(a0$$194) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not support the 'comparison' constraint because it is a record, union or struct with one or more structural element types which do not support the 'comparison' constraint. Either avoid the use of comparison with this type, or add the 'StructuralComparison' attribute to the type to determine which field type does not support comparison"))(a0$$194);
}

function SR$$$csTypeDoesNotSupportEquality1$$Z721C83C5(a0$$195) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not support the 'equality' constraint because it has the 'NoEquality' attribute"))(a0$$195);
}

function SR$$$csTypeDoesNotSupportEquality2$$Z721C83C5(a0$$196) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not support the 'equality' constraint because it is a function type"))(a0$$196);
}

function SR$$$csTypeDoesNotSupportEquality3$$Z721C83C5(a0$$197) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' does not support the 'equality' constraint because it is a record, union or struct with one or more structural element types which do not support the 'equality' constraint. Either avoid the use of equality with this type, or add the 'StructuralEquality' attribute to the type to determine which field type does not support equality"))(a0$$197);
}

function SR$$$csTypeIsNotEnumType$$Z721C83C5(a0$$198) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' is not a CLI enum type"))(a0$$198);
}

function SR$$$csTypeHasNonStandardDelegateType$$Z721C83C5(a0$$199) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' has a non-standard delegate type"))(a0$$199);
}

function SR$$$csTypeIsNotDelegateType$$Z721C83C5(a0$$200) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' is not a CLI delegate type"))(a0$$200);
}

function SR$$$csTypeParameterCannotBeNullable() {
  return (0, _String.toText)((0, _String.printf)("This type parameter cannot be instantiated to 'Nullable'. This is a restriction imposed in order to ensure the meaning of 'null' in some CLI languages is not confusing when used in conjunction with 'Nullable' values."));
}

function SR$$$csGenericConstructRequiresStructType$$Z721C83C5(a0$$201) {
  return (0, _String.toText)((0, _String.printf)("A generic construct requires that the type '%s' is a CLI or F# struct type"))(a0$$201);
}

function SR$$$csGenericConstructRequiresUnmanagedType$$Z721C83C5(a0$$202) {
  return (0, _String.toText)((0, _String.printf)("A generic construct requires that the type '%s' is an unmanaged type"))(a0$$202);
}

function SR$$$csTypeNotCompatibleBecauseOfPrintf$$Z384F8060(a0$$203, a1$$118) {
  return (0, _String.toText)((0, _String.printf)("The type '%s' is not compatible with any of the types %s, arising from the use of a printf-style format string"))(a0$$203)(a1$$118);
}

function SR$$$csGenericConstructRequiresReferenceSemantics$$Z721C83C5(a0$$204) {
  return (0, _String.toText)((0, _String.printf)("A generic construct requires that the type '%s' have reference semantics, but it does not, i.e. it is a struct"))(a0$$204);
}

function SR$$$csGenericConstructRequiresNonAbstract$$Z721C83C5(a0$$205) {
  return (0, _String.toText)((0, _String.printf)("A generic construct requires that the type '%s' be non-abstract"))(a0$$205);
}

function SR$$$csGenericConstructRequiresPublicDefaultConstructor$$Z721C83C5(a0$$206) {
  return (0, _String.toText)((0, _String.printf)("A generic construct requires that the type '%s' have a public default constructor"))(a0$$206);
}

function SR$$$csTypeInstantiationLengthMismatch() {
  return [483, (0, _String.toText)((0, _String.printf)("Type instantiation length mismatch"))];
}

function SR$$$csOptionalArgumentNotPermittedHere() {
  return [484, (0, _String.toText)((0, _String.printf)("Optional arguments not permitted here"))];
}

function SR$$$csMemberIsNotStatic$$Z721C83C5(a0$$207) {
  return [485, (0, _String.toText)((0, _String.printf)("%s is not a static member"))(a0$$207)];
}

function SR$$$csMemberIsNotInstance$$Z721C83C5(a0$$208) {
  return [486, (0, _String.toText)((0, _String.printf)("%s is not an instance member"))(a0$$208)];
}

function SR$$$csArgumentLengthMismatch() {
  return [487, (0, _String.toText)((0, _String.printf)("Argument length mismatch"))];
}

function SR$$$csArgumentTypesDoNotMatch() {
  return [488, (0, _String.toText)((0, _String.printf)("The argument types don't match"))];
}

function SR$$$csMethodExpectsParams() {
  return [489, (0, _String.toText)((0, _String.printf)("This method expects a CLI 'params' parameter in this position. 'params' is a way of passing a variable number of arguments to a method in languages such as C#. Consider passing an array for this argument"))];
}

function SR$$$csMemberIsNotAccessible$$Z384F8060(a0$$209, a1$$119) {
  return [490, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' is not %s"))(a0$$209)(a1$$119)];
}

function SR$$$csMemberIsNotAccessible2$$Z384F8060(a0$$210, a1$$120) {
  return [491, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' is not %s. Private members may only be accessed from within the declaring type. Protected members may only be accessed from an extending type and cannot be accessed from inner lambda expressions."))(a0$$210)(a1$$120)];
}

function SR$$$csMethodIsNotAStaticMethod$$Z721C83C5(a0$$211) {
  return [492, (0, _String.toText)((0, _String.printf)("%s is not a static method"))(a0$$211)];
}

function SR$$$csMethodIsNotAnInstanceMethod$$Z721C83C5(a0$$212) {
  return [493, (0, _String.toText)((0, _String.printf)("%s is not an instance method"))(a0$$212)];
}

function SR$$$csMemberHasNoArgumentOrReturnProperty$$30230F9B(a0$$213, a1$$121, a2$$43) {
  return (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' has no argument or settable return property '%s'. %s."))(a0$$213)(a1$$121)(a2$$43);
}

function SR$$$csCtorHasNoArgumentOrReturnProperty$$30230F9B(a0$$214, a1$$122, a2$$44) {
  return (0, _String.toText)((0, _String.printf)("The object constructor '%s' has no argument or settable return property '%s'. %s."))(a0$$214)(a1$$122)(a2$$44);
}

function SR$$$csRequiredSignatureIs$$Z721C83C5(a0$$215) {
  return [495, (0, _String.toText)((0, _String.printf)("The required signature is %s"))(a0$$215)];
}

function SR$$$csMemberSignatureMismatch$$6820229C(a0$$216, a1$$123, a2$$45) {
  return [496, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' requires %d argument(s). The required signature is '%s'."))(a0$$216)(a1$$123)(a2$$45)];
}

function SR$$$csMemberSignatureMismatch2$$6820229C(a0$$217, a1$$124, a2$$46) {
  return [497, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' requires %d additional argument(s). The required signature is '%s'."))(a0$$217)(a1$$124)(a2$$46)];
}

function SR$$$csMemberSignatureMismatch3$$Z1E38F5D9(a0$$218, a1$$125, a2$$47, a3$$6) {
  return [498, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' requires %d argument(s). The required signature is '%s'. Some names for missing arguments are %s."))(a0$$218)(a1$$125)(a2$$47)(a3$$6)];
}

function SR$$$csMemberSignatureMismatch4$$Z1E38F5D9(a0$$219, a1$$126, a2$$48, a3$$7) {
  return [499, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' requires %d additional argument(s). The required signature is '%s'. Some names for missing arguments are %s."))(a0$$219)(a1$$126)(a2$$48)(a3$$7)];
}

function SR$$$csMemberSignatureMismatchArityNamed$$3FB802DC(a0$$220, a1$$127, a2$$49, a3$$8, a4$$2) {
  return [500, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' requires %d argument(s) but is here given %d unnamed and %d named argument(s). The required signature is '%s'."))(a0$$220)(a1$$127)(a2$$49)(a3$$8)(a4$$2)];
}

function SR$$$csMemberSignatureMismatchArity$$Z2A429BA0(a0$$221, a1$$128, a2$$50, a3$$9) {
  return [501, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' takes %d argument(s) but is here given %d. The required signature is '%s'."))(a0$$221)(a1$$128)(a2$$50)(a3$$9)];
}

function SR$$$csCtorSignatureMismatchArity$$Z2A429BA0(a0$$222, a1$$129, a2$$51, a3$$10) {
  return [501, (0, _String.toText)((0, _String.printf)("The object constructor '%s' takes %d argument(s) but is here given %d. The required signature is '%s'."))(a0$$222)(a1$$129)(a2$$51)(a3$$10)];
}

function SR$$$csCtorSignatureMismatchArityProp$$Z2A429BA0(a0$$223, a1$$130, a2$$52, a3$$11) {
  return [501, (0, _String.toText)((0, _String.printf)("The object constructor '%s' takes %d argument(s) but is here given %d. The required signature is '%s'. If some of the arguments are meant to assign values to properties, consider separating those arguments with a comma (',')."))(a0$$223)(a1$$130)(a2$$52)(a3$$11)];
}

function SR$$$csMemberSignatureMismatchArityType$$Z2A429BA0(a0$$224, a1$$131, a2$$53, a3$$12) {
  return [502, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' takes %d type argument(s) but is here given %d. The required signature is '%s'."))(a0$$224)(a1$$131)(a2$$53)(a3$$12)];
}

function SR$$$csMemberNotAccessible$$Z3E662FC0(a0$$225, a1$$132, a2$$54, a3$$13) {
  return [503, (0, _String.toText)((0, _String.printf)("A member or object constructor '%s' taking %d arguments is not accessible from this code location. All accessible versions of method '%s' take %d arguments."))(a0$$225)(a1$$132)(a2$$54)(a3$$13)];
}

function SR$$$csIncorrectGenericInstantiation$$107DD5FC(a0$$226, a1$$133, a2$$55) {
  return [504, (0, _String.toText)((0, _String.printf)("Incorrect generic instantiation. No %s member named '%s' takes %d generic arguments."))(a0$$226)(a1$$133)(a2$$55)];
}

function SR$$$csMemberOverloadArityMismatch$$487EF8FB(a0$$227, a1$$134, a2$$56) {
  return [505, (0, _String.toText)((0, _String.printf)("The member or object constructor '%s' does not take %d argument(s). An overload was found taking %d arguments."))(a0$$227)(a1$$134)(a2$$56)];
}

function SR$$$csNoMemberTakesTheseArguments$$107DD5FC(a0$$228, a1$$135, a2$$57) {
  return [506, (0, _String.toText)((0, _String.printf)("No %s member or object constructor named '%s' takes %d arguments"))(a0$$228)(a1$$135)(a2$$57)];
}

function SR$$$csNoMemberTakesTheseArguments2$$Z727ACCE0(a0$$229, a1$$136, a2$$58, a3$$14) {
  return [507, (0, _String.toText)((0, _String.printf)("No %s member or object constructor named '%s' takes %d arguments. Note the call to this member also provides %d named arguments."))(a0$$229)(a1$$136)(a2$$58)(a3$$14)];
}

function SR$$$csNoMemberTakesTheseArguments3$$Z522416B9(a0$$230, a1$$137, a2$$59, a3$$15) {
  return [508, (0, _String.toText)((0, _String.printf)("No %s member or object constructor named '%s' takes %d arguments. The named argument '%s' doesn't correspond to any argument or settable return property for any overload."))(a0$$230)(a1$$137)(a2$$59)(a3$$15)];
}

function SR$$$csMethodNotFound$$Z721C83C5(a0$$231) {
  return [509, (0, _String.toText)((0, _String.printf)("Method or object constructor '%s' not found"))(a0$$231)];
}

function SR$$$csNoOverloadsFound$$Z721C83C5(a0$$232) {
  return (0, _String.toText)((0, _String.printf)("No overloads match for method '%s'."))(a0$$232);
}

function SR$$$csMethodIsOverloaded$$Z721C83C5(a0$$233) {
  return (0, _String.toText)((0, _String.printf)("A unique overload for method '%s' could not be determined based on type information prior to this program point. A type annotation may be needed."))(a0$$233);
}

function SR$$$csCandidates$$Z721C83C5(a0$$234) {
  return (0, _String.toText)((0, _String.printf)("Candidates: %s"))(a0$$234);
}

function SR$$$csSeeAvailableOverloads() {
  return (0, _String.toText)((0, _String.printf)("The available overloads are shown below."));
}

function SR$$$parsDoCannotHaveVisibilityDeclarations$$Z721C83C5(a0$$235) {
  return [512, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted on 'do' bindings, but '%s' was given."))(a0$$235)];
}

function SR$$$parsEofInHashIf() {
  return [513, (0, _String.toText)((0, _String.printf)("End of file in #if section begun at or after here"))];
}

function SR$$$parsEofInString() {
  return [514, (0, _String.toText)((0, _String.printf)("End of file in string begun at or before here"))];
}

function SR$$$parsEofInVerbatimString() {
  return [515, (0, _String.toText)((0, _String.printf)("End of file in verbatim string begun at or before here"))];
}

function SR$$$parsEofInComment() {
  return [516, (0, _String.toText)((0, _String.printf)("End of file in comment begun at or before here"))];
}

function SR$$$parsEofInStringInComment() {
  return [517, (0, _String.toText)((0, _String.printf)("End of file in string embedded in comment begun at or before here"))];
}

function SR$$$parsEofInVerbatimStringInComment() {
  return [518, (0, _String.toText)((0, _String.printf)("End of file in verbatim string embedded in comment begun at or before here"))];
}

function SR$$$parsEofInIfOcaml() {
  return [519, (0, _String.toText)((0, _String.printf)("End of file in IF-OCAML section begun at or before here"))];
}

function SR$$$parsEofInDirective() {
  return [520, (0, _String.toText)((0, _String.printf)("End of file in directive begun at or before here"))];
}

function SR$$$parsNoHashEndIfFound() {
  return [521, (0, _String.toText)((0, _String.printf)("No #endif found for #if or #else"))];
}

function SR$$$parsAttributesIgnored() {
  return [522, (0, _String.toText)((0, _String.printf)("Attributes have been ignored in this construct"))];
}

function SR$$$parsUseBindingsIllegalInImplicitClassConstructors() {
  return [523, (0, _String.toText)((0, _String.printf)("'use' bindings are not permitted in primary constructors"))];
}

function SR$$$parsUseBindingsIllegalInModules() {
  return [524, (0, _String.toText)((0, _String.printf)("'use' bindings are not permitted in modules and are treated as 'let' bindings"))];
}

function SR$$$parsIntegerForLoopRequiresSimpleIdentifier() {
  return [525, (0, _String.toText)((0, _String.printf)("An integer for loop must use a simple identifier"))];
}

function SR$$$parsOnlyOneWithAugmentationAllowed() {
  return [526, (0, _String.toText)((0, _String.printf)("At most one 'with' augmentation is permitted"))];
}

function SR$$$parsUnexpectedSemicolon() {
  return [527, (0, _String.toText)((0, _String.printf)("A semicolon is not expected at this point"))];
}

function SR$$$parsUnexpectedEndOfFile() {
  return [528, (0, _String.toText)((0, _String.printf)("Unexpected end of input"))];
}

function SR$$$parsUnexpectedVisibilityDeclaration$$Z721C83C5(a0$$236) {
  return [529, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted here, but '%s' was given."))(a0$$236)];
}

function SR$$$parsOnlyHashDirectivesAllowed() {
  return [530, (0, _String.toText)((0, _String.printf)("Only '#' compiler directives may occur prior to the first 'namespace' declaration"))];
}

function SR$$$parsVisibilityDeclarationsShouldComePriorToIdentifier() {
  return [531, (0, _String.toText)((0, _String.printf)("Accessibility modifiers should come immediately prior to the identifier naming a construct"))];
}

function SR$$$parsNamespaceOrModuleNotBoth() {
  return [532, (0, _String.toText)((0, _String.printf)("Files should begin with either a namespace or module declaration, e.g. 'namespace SomeNamespace.SubNamespace' or 'module SomeNamespace.SomeModule', but not both. To define a module within a namespace use 'module SomeModule = ...'"))];
}

function SR$$$parsModuleAbbreviationMustBeSimpleName() {
  return [534, (0, _String.toText)((0, _String.printf)("A module abbreviation must be a simple name, not a path"))];
}

function SR$$$parsIgnoreAttributesOnModuleAbbreviation() {
  return [535, (0, _String.toText)((0, _String.printf)("Ignoring attributes on module abbreviation"))];
}

function SR$$$parsIgnoreAttributesOnModuleAbbreviationAlwaysPrivate$$Z721C83C5(a0$$237) {
  return [536, (0, _String.toText)((0, _String.printf)("The '%s' accessibility attribute is not allowed on module abbreviation. Module abbreviations are always private."))(a0$$237)];
}

function SR$$$parsIgnoreVisibilityOnModuleAbbreviationAlwaysPrivate$$Z721C83C5(a0$$238) {
  return [537, (0, _String.toText)((0, _String.printf)("The '%s' visibility attribute is not allowed on module abbreviation. Module abbreviations are always private."))(a0$$238)];
}

function SR$$$parsUnClosedBlockInHashLight() {
  return [538, (0, _String.toText)((0, _String.printf)("Unclosed block"))];
}

function SR$$$parsUnmatchedBeginOrStruct() {
  return [539, (0, _String.toText)((0, _String.printf)("Unmatched 'begin' or 'struct'"))];
}

function SR$$$parsModuleDefnMustBeSimpleName() {
  return [541, (0, _String.toText)((0, _String.printf)("A module name must be a simple name, not a path"))];
}

function SR$$$parsUnexpectedEmptyModuleDefn() {
  return [542, (0, _String.toText)((0, _String.printf)("Unexpected empty type moduleDefn list"))];
}

function SR$$$parsAttributesMustComeBeforeVal() {
  return (0, _String.toText)((0, _String.printf)("Attributes should be placed before 'val'"));
}

function SR$$$parsAttributesAreNotPermittedOnInterfaceImplementations() {
  return [543, (0, _String.toText)((0, _String.printf)("Attributes are not permitted on interface implementations"))];
}

function SR$$$parsSyntaxError() {
  return [544, (0, _String.toText)((0, _String.printf)("Syntax error"))];
}

function SR$$$parsAugmentationsIllegalOnDelegateType() {
  return [545, (0, _String.toText)((0, _String.printf)("Augmentations are not permitted on delegate type moduleDefns"))];
}

function SR$$$parsUnmatchedClassInterfaceOrStruct() {
  return [546, (0, _String.toText)((0, _String.printf)("Unmatched 'class', 'interface' or 'struct'"))];
}

function SR$$$parsEmptyTypeDefinition() {
  return [547, (0, _String.toText)((0, _String.printf)("A type definition requires one or more members or other declarations. If you intend to define an empty class, struct or interface, then use 'type ... = class end', 'interface end' or 'struct end'."))];
}

function SR$$$parsUnmatchedWith() {
  return [550, (0, _String.toText)((0, _String.printf)("Unmatched 'with' or badly formatted 'with' block"))];
}

function SR$$$parsGetOrSetRequired() {
  return [551, (0, _String.toText)((0, _String.printf)("'get', 'set' or 'get,set' required"))];
}

function SR$$$parsOnlyClassCanTakeValueArguments() {
  return [552, (0, _String.toText)((0, _String.printf)("Only class types may take value arguments"))];
}

function SR$$$parsUnmatchedBegin() {
  return [553, (0, _String.toText)((0, _String.printf)("Unmatched 'begin'"))];
}

function SR$$$parsInvalidDeclarationSyntax() {
  return [554, (0, _String.toText)((0, _String.printf)("Invalid declaration syntax"))];
}

function SR$$$parsGetAndOrSetRequired() {
  return [555, (0, _String.toText)((0, _String.printf)("'get' and/or 'set' required"))];
}

function SR$$$parsTypeAnnotationsOnGetSet() {
  return [556, (0, _String.toText)((0, _String.printf)("Type annotations on property getters and setters must be given after the 'get()' or 'set(v)', e.g. 'with get() : string = ...'"))];
}

function SR$$$parsGetterMustHaveAtLeastOneArgument() {
  return [557, (0, _String.toText)((0, _String.printf)("A getter property is expected to be a function, e.g. 'get() = ...' or 'get(index) = ...'"))];
}

function SR$$$parsMultipleAccessibilitiesForGetSet() {
  return [558, (0, _String.toText)((0, _String.printf)("Multiple accessibilities given for property getter or setter"))];
}

function SR$$$parsSetSyntax() {
  return [559, (0, _String.toText)((0, _String.printf)("Property setters must be defined using 'set value = ', 'set idx value = ' or 'set (idx1,...,idxN) value = ... '"))];
}

function SR$$$parsInterfacesHaveSameVisibilityAsEnclosingType() {
  return [560, (0, _String.toText)((0, _String.printf)("Interfaces always have the same visibility as the enclosing type"))];
}

function SR$$$parsAccessibilityModsIllegalForAbstract() {
  return [561, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not allowed on this member. Abstract slots always have the same visibility as the enclosing type."))];
}

function SR$$$parsAttributesIllegalOnInherit() {
  return [562, (0, _String.toText)((0, _String.printf)("Attributes are not permitted on 'inherit' declarations"))];
}

function SR$$$parsVisibilityIllegalOnInherit() {
  return [563, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted on an 'inherits' declaration"))];
}

function SR$$$parsInheritDeclarationsCannotHaveAsBindings() {
  return [564, (0, _String.toText)((0, _String.printf)("'inherit' declarations cannot have 'as' bindings. To access members of the base class when overriding a method, the syntax 'base.SomeMember' may be used; 'base' is a keyword. Remove this 'as' binding."))];
}

function SR$$$parsAttributesIllegalHere() {
  return [565, (0, _String.toText)((0, _String.printf)("Attributes are not allowed here"))];
}

function SR$$$parsTypeAbbreviationsCannotHaveVisibilityDeclarations() {
  return [566, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted in this position for type abbreviations"))];
}

function SR$$$parsEnumTypesCannotHaveVisibilityDeclarations() {
  return [567, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted in this position for enum types"))];
}

function SR$$$parsAllEnumFieldsRequireValues() {
  return [568, (0, _String.toText)((0, _String.printf)("All enum fields must be given values"))];
}

function SR$$$parsInlineAssemblyCannotHaveVisibilityDeclarations() {
  return [569, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted on inline assembly code types"))];
}

function SR$$$parsUnexpectedIdentifier$$Z721C83C5(a0$$239) {
  return [571, (0, _String.toText)((0, _String.printf)("Unexpected identifier: '%s'"))(a0$$239)];
}

function SR$$$parsUnionCasesCannotHaveVisibilityDeclarations() {
  return [572, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted on union cases. Use 'type U = internal ...' or 'type U = private ...' to give an accessibility to the whole representation."))];
}

function SR$$$parsEnumFieldsCannotHaveVisibilityDeclarations() {
  return [573, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted on enumeration fields"))];
}

function SR$$$parsConsiderUsingSeparateRecordType() {
  return (0, _String.toText)((0, _String.printf)("Consider using a separate record type instead"));
}

function SR$$$parsRecordFieldsCannotHaveVisibilityDeclarations() {
  return [575, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted on record fields. Use 'type R = internal ...' or 'type R = private ...' to give an accessibility to the whole representation."))];
}

function SR$$$parsLetAndForNonRecBindings() {
  return [576, (0, _String.toText)((0, _String.printf)("The declaration form 'let ... and ...' for non-recursive bindings is not used in F# code. Consider using a sequence of 'let' bindings"))];
}

function SR$$$parsUnmatchedParen() {
  return [583, (0, _String.toText)((0, _String.printf)("Unmatched '('"))];
}

function SR$$$parsSuccessivePatternsShouldBeSpacedOrTupled() {
  return [584, (0, _String.toText)((0, _String.printf)("Successive patterns should be separated by spaces or tupled"))];
}

function SR$$$parsNoMatchingInForLet() {
  return [586, (0, _String.toText)((0, _String.printf)("No matching 'in' found for this 'let'"))];
}

function SR$$$parsErrorInReturnForLetIncorrectIndentation() {
  return [587, (0, _String.toText)((0, _String.printf)("Error in the return expression for this 'let'. Possible incorrect indentation."))];
}

function SR$$$parsExpectedExpressionAfterLet$$Z384F8060(a0$$240, a1$$138) {
  return [588, (0, _String.toText)((0, _String.printf)("The block following this '%s' is unfinished. Every code block is an expression and must have a result. '%s' cannot be the final code element in a block. Consider giving this block an explicit result."))(a0$$240)(a1$$138)];
}

function SR$$$parsIncompleteIf() {
  return [589, (0, _String.toText)((0, _String.printf)("Incomplete conditional. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'."))];
}

function SR$$$parsAssertIsNotFirstClassValue() {
  return [590, (0, _String.toText)((0, _String.printf)("'assert' may not be used as a first class value. Use 'assert <expr>' instead."))];
}

function SR$$$parsIdentifierExpected() {
  return [594, (0, _String.toText)((0, _String.printf)("Identifier expected"))];
}

function SR$$$parsInOrEqualExpected() {
  return [595, (0, _String.toText)((0, _String.printf)("'in' or '=' expected"))];
}

function SR$$$parsArrowUseIsLimited() {
  return [596, (0, _String.toText)((0, _String.printf)("The use of '->' in sequence and computation expressions is limited to the form 'for pat in expr -> expr'. Use the syntax 'for ... in ... do ... yield...' to generate elements in more complex sequence expressions."))];
}

function SR$$$parsSuccessiveArgsShouldBeSpacedOrTupled() {
  return [597, (0, _String.toText)((0, _String.printf)("Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized"))];
}

function SR$$$parsUnmatchedBracket() {
  return [598, (0, _String.toText)((0, _String.printf)("Unmatched '['"))];
}

function SR$$$parsMissingQualificationAfterDot() {
  return [599, (0, _String.toText)((0, _String.printf)("Missing qualification after '.'"))];
}

function SR$$$parsParenFormIsForML() {
  return (0, _String.toText)((0, _String.printf)("In F# code you may use 'expr.[expr]'. A type annotation may be required to indicate the first expression is an array"));
}

function SR$$$parsMismatchedQuote$$Z721C83C5(a0$$241) {
  return [601, (0, _String.toText)((0, _String.printf)("Mismatched quotation, beginning with '%s'"))(a0$$241)];
}

function SR$$$parsUnmatched$$Z721C83C5(a0$$242) {
  return [602, (0, _String.toText)((0, _String.printf)("Unmatched '%s'"))(a0$$242)];
}

function SR$$$parsUnmatchedBracketBar() {
  return [603, (0, _String.toText)((0, _String.printf)("Unmatched '[|'"))];
}

function SR$$$parsUnmatchedBrace() {
  return [604, (0, _String.toText)((0, _String.printf)("Unmatched '{'"))];
}

function SR$$$parsFieldBinding() {
  return [609, (0, _String.toText)((0, _String.printf)("Field bindings must have the form 'id = expr;'"))];
}

function SR$$$parsMemberIllegalInObjectImplementation() {
  return [610, (0, _String.toText)((0, _String.printf)("This member is not permitted in an object implementation"))];
}

function SR$$$parsMissingFunctionBody() {
  return [611, (0, _String.toText)((0, _String.printf)("Missing function body"))];
}

function SR$$$parsSyntaxErrorInLabeledType() {
  return [613, (0, _String.toText)((0, _String.printf)("Syntax error in labelled type argument"))];
}

function SR$$$parsUnexpectedInfixOperator() {
  return [615, (0, _String.toText)((0, _String.printf)("Unexpected infix operator in type expression"))];
}

function SR$$$parsMultiArgumentGenericTypeFormDeprecated() {
  return (0, _String.toText)((0, _String.printf)("The syntax '(typ,...,typ) ident' is not used in F# code. Consider using 'ident<typ,...,typ>' instead"));
}

function SR$$$parsInvalidLiteralInType() {
  return [618, (0, _String.toText)((0, _String.printf)("Invalid literal in type"))];
}

function SR$$$parsUnexpectedOperatorForUnitOfMeasure() {
  return [619, (0, _String.toText)((0, _String.printf)("Unexpected infix operator in unit-of-measure expression. Legal operators are '*', '/' and '^'."))];
}

function SR$$$parsUnexpectedIntegerLiteralForUnitOfMeasure() {
  return [620, (0, _String.toText)((0, _String.printf)("Unexpected integer literal in unit-of-measure expression"))];
}

function SR$$$parsUnexpectedTypeParameter() {
  return [621, (0, _String.toText)((0, _String.printf)("Syntax error: unexpected type parameter specification"))];
}

function SR$$$parsMismatchedQuotationName$$Z721C83C5(a0$$243) {
  return [622, (0, _String.toText)((0, _String.printf)("Mismatched quotation operator name, beginning with '%s'"))(a0$$243)];
}

function SR$$$parsActivePatternCaseMustBeginWithUpperCase() {
  return [623, (0, _String.toText)((0, _String.printf)("Active pattern case identifiers must begin with an uppercase letter"))];
}

function SR$$$parsActivePatternCaseContainsPipe() {
  return [624, (0, _String.toText)((0, _String.printf)("The '|' character is not permitted in active pattern case identifiers"))];
}

function SR$$$parsIllegalDenominatorForMeasureExponent() {
  return [625, (0, _String.toText)((0, _String.printf)("Denominator must not be 0 in unit-of-measure exponent"))];
}

function SR$$$parsNoEqualShouldFollowNamespace() {
  return (0, _String.toText)((0, _String.printf)("No '=' symbol should follow a 'namespace' declaration"));
}

function SR$$$parsSyntaxModuleStructEndDeprecated() {
  return (0, _String.toText)((0, _String.printf)("The syntax 'module ... = struct .. end' is not used in F# code. Consider using 'module ... = begin .. end'"));
}

function SR$$$parsSyntaxModuleSigEndDeprecated() {
  return (0, _String.toText)((0, _String.printf)("The syntax 'module ... : sig .. end' is not used in F# code. Consider using 'module ... = begin .. end'"));
}

function SR$$$tcStaticFieldUsedWhenInstanceFieldExpected() {
  return [627, (0, _String.toText)((0, _String.printf)("A static field was used where an instance field is expected"))];
}

function SR$$$tcMethodNotAccessible$$Z721C83C5(a0$$244) {
  return [629, (0, _String.toText)((0, _String.printf)("Method '%s' is not accessible from this code location"))(a0$$244)];
}

function SR$$$tcImplicitMeasureFollowingSlash() {
  return [632, (0, _String.toText)((0, _String.printf)("Implicit product of measures following /"))];
}

function SR$$$tcUnexpectedMeasureAnon() {
  return [633, (0, _String.toText)((0, _String.printf)("Unexpected SynMeasure.Anon"))];
}

function SR$$$tcNonZeroConstantCannotHaveGenericUnit() {
  return [634, (0, _String.toText)((0, _String.printf)("Non-zero constants cannot have generic units. For generic zero, write 0.0<_>."))];
}

function SR$$$tcSeqResultsUseYield() {
  return [635, (0, _String.toText)((0, _String.printf)("In sequence expressions, results are generated using 'yield'"))];
}

function SR$$$tcUnexpectedBigRationalConstant() {
  return (0, _String.toText)((0, _String.printf)("Unexpected big rational constant"));
}

function SR$$$tcInvalidTypeForUnitsOfMeasure() {
  return [636, (0, _String.toText)((0, _String.printf)("Units-of-measure supported only on float, float32, decimal and signed integer types"))];
}

function SR$$$tcUnexpectedConstUint16Array() {
  return (0, _String.toText)((0, _String.printf)("Unexpected Const_uint16array"));
}

function SR$$$tcUnexpectedConstByteArray() {
  return (0, _String.toText)((0, _String.printf)("Unexpected Const_bytearray"));
}

function SR$$$tcParameterRequiresName() {
  return [640, (0, _String.toText)((0, _String.printf)("A parameter with attributes must also be given a name, e.g. '[<Attribute>] Name : Type'"))];
}

function SR$$$tcReturnValuesCannotHaveNames() {
  return [641, (0, _String.toText)((0, _String.printf)("Return values cannot have names"))];
}

function SR$$$tcMemberKindPropertyGetSetNotExpected() {
  return (0, _String.toText)((0, _String.printf)("MemberKind.PropertyGetSet only expected in parse trees"));
}

function SR$$$tcNamespaceCannotContainValues() {
  return [201, (0, _String.toText)((0, _String.printf)("Namespaces cannot contain values. Consider using a module to hold your value declarations."))];
}

function SR$$$tcNamespaceCannotContainExtensionMembers() {
  return [644, (0, _String.toText)((0, _String.printf)("Namespaces cannot contain extension members except in the same file and namespace declaration group where the type is defined. Consider using a module to hold declarations of extension members."))];
}

function SR$$$tcMultipleVisibilityAttributes() {
  return [645, (0, _String.toText)((0, _String.printf)("Multiple visibility attributes have been specified for this identifier"))];
}

function SR$$$tcMultipleVisibilityAttributesWithLet() {
  return [646, (0, _String.toText)((0, _String.printf)("Multiple visibility attributes have been specified for this identifier. 'let' bindings in classes are always private, as are any 'let' bindings inside expressions."))];
}

function SR$$$tcInvalidMethodNameForRelationalOperator$$Z384F8060(a0$$245, a1$$139) {
  return (0, _String.toText)((0, _String.printf)("The name '(%s)' should not be used as a member name. To define comparison semantics for a type, implement the 'System.IComparable' interface. If defining a static member for use from other CLI languages then use the name '%s' instead."))(a0$$245)(a1$$139);
}

function SR$$$tcInvalidMethodNameForEquality$$Z384F8060(a0$$246, a1$$140) {
  return (0, _String.toText)((0, _String.printf)("The name '(%s)' should not be used as a member name. To define equality semantics for a type, override the 'Object.Equals' member. If defining a static member for use from other CLI languages then use the name '%s' instead."))(a0$$246)(a1$$140);
}

function SR$$$tcInvalidMemberName$$Z384F8060(a0$$247, a1$$141) {
  return (0, _String.toText)((0, _String.printf)("The name '(%s)' should not be used as a member name. If defining a static member for use from other CLI languages then use the name '%s' instead."))(a0$$247)(a1$$141);
}

function SR$$$tcInvalidMemberNameFixedTypes$$Z721C83C5(a0$$248) {
  return (0, _String.toText)((0, _String.printf)("The name '(%s)' should not be used as a member name because it is given a standard definition in the F# library over fixed types"))(a0$$248);
}

function SR$$$tcInvalidOperatorDefinitionRelational$$Z721C83C5(a0$$249) {
  return (0, _String.toText)((0, _String.printf)("The '%s' operator should not normally be redefined. To define overloaded comparison semantics for a particular type, implement the 'System.IComparable' interface in the definition of that type."))(a0$$249);
}

function SR$$$tcInvalidOperatorDefinitionEquality$$Z721C83C5(a0$$250) {
  return (0, _String.toText)((0, _String.printf)("The '%s' operator should not normally be redefined. To define equality semantics for a type, override the 'Object.Equals' member in the definition of that type."))(a0$$250);
}

function SR$$$tcInvalidOperatorDefinition$$Z721C83C5(a0$$251) {
  return (0, _String.toText)((0, _String.printf)("The '%s' operator should not normally be redefined. Consider using a different operator name"))(a0$$251);
}

function SR$$$tcInvalidIndexOperatorDefinition$$Z721C83C5(a0$$252) {
  return (0, _String.toText)((0, _String.printf)("The '%s' operator cannot be redefined. Consider using a different operator name"))(a0$$252);
}

function SR$$$tcExpectModuleOrNamespaceParent$$Z721C83C5(a0$$253) {
  return (0, _String.toText)((0, _String.printf)("Expected module or namespace parent %s"))(a0$$253);
}

function SR$$$tcImplementsIComparableExplicitly$$Z721C83C5(a0$$254) {
  return [647, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' implements the interface 'System.IComparable' explicitly. You must apply the 'CustomComparison' attribute to the type."))(a0$$254)];
}

function SR$$$tcImplementsGenericIComparableExplicitly$$Z721C83C5(a0$$255) {
  return [648, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' implements the interface 'System.IComparable<_>' explicitly. You must apply the 'CustomComparison' attribute to the type, and should also provide a consistent implementation of the non-generic interface System.IComparable."))(a0$$255)];
}

function SR$$$tcImplementsIStructuralComparableExplicitly$$Z721C83C5(a0$$256) {
  return [649, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' implements the interface 'System.IStructuralComparable' explicitly. Apply the 'CustomComparison' attribute to the type."))(a0$$256)];
}

function SR$$$tcRecordFieldInconsistentTypes() {
  return [656, (0, _String.toText)((0, _String.printf)("This record contains fields from inconsistent types"))];
}

function SR$$$tcDllImportStubsCannotBeInlined() {
  return [657, (0, _String.toText)((0, _String.printf)("DLLImport stubs cannot be inlined"))];
}

function SR$$$tcStructsCanOnlyBindThisAtMemberDeclaration() {
  return [658, (0, _String.toText)((0, _String.printf)("Structs may only bind a 'this' parameter at member declarations"))];
}

function SR$$$tcUnexpectedExprAtRecInfPoint() {
  return [659, (0, _String.toText)((0, _String.printf)("Unexpected expression at recursive inference point"))];
}

function SR$$$tcLessGenericBecauseOfAnnotation$$Z384F8060(a0$$257, a1$$142) {
  return [660, (0, _String.toText)((0, _String.printf)("This code is less generic than required by its annotations because the explicit type variable '%s' could not be generalized. It was constrained to be '%s'."))(a0$$257)(a1$$142)];
}

function SR$$$tcConstrainedTypeVariableCannotBeGeneralized() {
  return [661, (0, _String.toText)((0, _String.printf)("One or more of the explicit class or function type variables for this binding could not be generalized, because they were constrained to other types"))];
}

function SR$$$tcGenericParameterHasBeenConstrained$$Z721C83C5(a0$$258) {
  return [662, (0, _String.toText)((0, _String.printf)("A generic type parameter has been used in a way that constrains it to always be '%s'"))(a0$$258)];
}

function SR$$$tcTypeParameterHasBeenConstrained$$Z721C83C5(a0$$259) {
  return [663, (0, _String.toText)((0, _String.printf)("This type parameter has been used in a way that constrains it to always be '%s'"))(a0$$259)];
}

function SR$$$tcTypeParametersInferredAreNotStable() {
  return [664, (0, _String.toText)((0, _String.printf)("The type parameters inferred for this value are not stable under the erasure of type abbreviations. This is due to the use of type abbreviations which drop or reorder type parameters, e.g. \n\ttype taggedInt<'a> = int or\n\ttype swap<'a,'b> = 'b * 'a.\nConsider declaring the type parameters for this value explicitly, e.g.\n\tlet f<'a,'b> ((x,y) : swap<'b,'a>) : swap<'a,'b> = (y,x)."))];
}

function SR$$$tcExplicitTypeParameterInvalid() {
  return [665, (0, _String.toText)((0, _String.printf)("Explicit type parameters may only be used on module or member bindings"))];
}

function SR$$$tcOverridingMethodRequiresAllOrNoTypeParameters() {
  return [666, (0, _String.toText)((0, _String.printf)("You must explicitly declare either all or no type parameters when overriding a generic abstract method"))];
}

function SR$$$tcFieldsDoNotDetermineUniqueRecordType() {
  return [667, (0, _String.toText)((0, _String.printf)("The field labels and expected type of this record expression or pattern do not uniquely determine a corresponding record type"))];
}

function SR$$$tcFieldAppearsTwiceInRecord$$Z721C83C5(a0$$260) {
  return [668, (0, _String.toText)((0, _String.printf)("The field '%s' appears twice in this record expression or pattern"))(a0$$260)];
}

function SR$$$tcUnknownUnion() {
  return [669, (0, _String.toText)((0, _String.printf)("Unknown union case"))];
}

function SR$$$tcNotSufficientlyGenericBecauseOfScope$$Z721C83C5(a0$$261) {
  return [670, (0, _String.toText)((0, _String.printf)("This code is not sufficiently generic. The type variable %s could not be generalized because it would escape its scope."))(a0$$261)];
}

function SR$$$tcPropertyRequiresExplicitTypeParameters() {
  return [671, (0, _String.toText)((0, _String.printf)("A property cannot have explicit type parameters. Consider using a method instead."))];
}

function SR$$$tcConstructorCannotHaveTypeParameters() {
  return [672, (0, _String.toText)((0, _String.printf)("A constructor cannot have explicit type parameters. Consider using a static construction method instead."))];
}

function SR$$$tcInstanceMemberRequiresTarget() {
  return [673, (0, _String.toText)((0, _String.printf)("This instance member needs a parameter to represent the object being invoked. Make the member static or use the notation 'member x.Member(args) = ...'."))];
}

function SR$$$tcUnexpectedPropertyInSyntaxTree() {
  return [674, (0, _String.toText)((0, _String.printf)("Unexpected source-level property specification in syntax tree"))];
}

function SR$$$tcStaticInitializerRequiresArgument() {
  return [675, (0, _String.toText)((0, _String.printf)("A static initializer requires an argument"))];
}

function SR$$$tcObjectConstructorRequiresArgument() {
  return [676, (0, _String.toText)((0, _String.printf)("An object constructor requires an argument"))];
}

function SR$$$tcStaticMemberShouldNotHaveThis() {
  return [677, (0, _String.toText)((0, _String.printf)("This static member should not have a 'this' parameter. Consider using the notation 'member Member(args) = ...'."))];
}

function SR$$$tcExplicitStaticInitializerSyntax() {
  return [678, (0, _String.toText)((0, _String.printf)("An explicit static initializer should use the syntax 'static new(args) = expr'"))];
}

function SR$$$tcExplicitObjectConstructorSyntax() {
  return [679, (0, _String.toText)((0, _String.printf)("An explicit object constructor should use the syntax 'new(args) = expr'"))];
}

function SR$$$tcUnexpectedPropertySpec() {
  return [680, (0, _String.toText)((0, _String.printf)("Unexpected source-level property specification"))];
}

function SR$$$tcObjectExpressionFormDeprecated() {
  return (0, _String.toText)((0, _String.printf)("This form of object expression is not used in F#. Use 'member this.MemberName ... = ...' to define member implementations in object expressions."));
}

function SR$$$tcInvalidDeclaration() {
  return [682, (0, _String.toText)((0, _String.printf)("Invalid declaration"))];
}

function SR$$$tcAttributesInvalidInPatterns() {
  return [683, (0, _String.toText)((0, _String.printf)("Attributes are not allowed within patterns"))];
}

function SR$$$tcFunctionRequiresExplicitTypeArguments$$Z721C83C5(a0$$262) {
  return [685, (0, _String.toText)((0, _String.printf)("The generic function '%s' must be given explicit type argument(s)"))(a0$$262)];
}

function SR$$$tcDoesNotAllowExplicitTypeArguments$$Z721C83C5(a0$$263) {
  return [686, (0, _String.toText)((0, _String.printf)("The method or function '%s' should not be given explicit type argument(s) because it does not declare its type parameters explicitly"))(a0$$263)];
}

function SR$$$tcTypeParameterArityMismatch$$Z37302880(a0$$264, a1$$143) {
  return [687, (0, _String.toText)((0, _String.printf)("This value, type or method expects %d type parameter(s) but was given %d"))(a0$$264)(a1$$143)];
}

function SR$$$tcDefaultStructConstructorCall() {
  return [688, (0, _String.toText)((0, _String.printf)("The default, zero-initializing constructor of a struct type may only be used if all the fields of the struct type admit default initialization"))];
}

function SR$$$tcCouldNotFindIDisposable() {
  return (0, _String.toText)((0, _String.printf)("Couldn't find Dispose on IDisposable, or it was overloaded"));
}

function SR$$$tcNonLiteralCannotBeUsedInPattern() {
  return [689, (0, _String.toText)((0, _String.printf)("This value is not a literal and cannot be used in a pattern"))];
}

function SR$$$tcFieldIsReadonly() {
  return [690, (0, _String.toText)((0, _String.printf)("This field is readonly"))];
}

function SR$$$tcNameArgumentsMustAppearLast() {
  return [691, (0, _String.toText)((0, _String.printf)("Named arguments must appear after all other arguments"))];
}

function SR$$$tcFunctionRequiresExplicitLambda$$Z524259A4(a0$$265) {
  return [692, (0, _String.toText)((0, _String.printf)("This function value is being used to construct a delegate type whose signature includes a byref argument. You must use an explicit lambda expression taking %d arguments."))(a0$$265)];
}

function SR$$$tcTypeCannotBeEnumerated$$Z721C83C5(a0$$266) {
  return [693, (0, _String.toText)((0, _String.printf)("The type '%s' is not a type whose values can be enumerated with this syntax, i.e. is not compatible with either seq<_>, IEnumerable<_> or IEnumerable and does not have a GetEnumerator method"))(a0$$266)];
}

function SR$$$tcInvalidMixtureOfRecursiveForms() {
  return [695, (0, _String.toText)((0, _String.printf)("This recursive binding uses an invalid mixture of recursive forms"))];
}

function SR$$$tcInvalidObjectConstructionExpression() {
  return [696, (0, _String.toText)((0, _String.printf)("This is not a valid object construction expression. Explicit object constructors must either call an alternate constructor or initialize all fields of the object and specify a call to a super class constructor."))];
}

function SR$$$tcInvalidConstraint() {
  return [697, (0, _String.toText)((0, _String.printf)("Invalid constraint"))];
}

function SR$$$tcInvalidConstraintTypeSealed() {
  return [698, (0, _String.toText)((0, _String.printf)("Invalid constraint: the type used for the constraint is sealed, which means the constraint could only be satisfied by at most one solution"))];
}

function SR$$$tcInvalidEnumConstraint() {
  return [699, (0, _String.toText)((0, _String.printf)("An 'enum' constraint must be of the form 'enum<type>'"))];
}

function SR$$$tcInvalidNewConstraint() {
  return [700, (0, _String.toText)((0, _String.printf)("'new' constraints must take one argument of type 'unit' and return the constructed type"))];
}

function SR$$$tcInvalidPropertyType() {
  return [701, (0, _String.toText)((0, _String.printf)("This property has an invalid type. Properties taking multiple indexer arguments should have types of the form 'ty1 * ty2 -> ty3'. Properties returning functions should have types of the form '(ty1 -> ty2)'."))];
}

function SR$$$tcExpectedUnitOfMeasureMarkWithAttribute() {
  return [702, (0, _String.toText)((0, _String.printf)("Expected unit-of-measure parameter, not type parameter. Explicit unit-of-measure parameters must be marked with the [<Measure>] attribute."))];
}

function SR$$$tcExpectedTypeParameter() {
  return [703, (0, _String.toText)((0, _String.printf)("Expected type parameter, not unit-of-measure parameter"))];
}

function SR$$$tcExpectedTypeNotUnitOfMeasure() {
  return [704, (0, _String.toText)((0, _String.printf)("Expected type, not unit-of-measure"))];
}

function SR$$$tcExpectedUnitOfMeasureNotType() {
  return [705, (0, _String.toText)((0, _String.printf)("Expected unit-of-measure, not type"))];
}

function SR$$$tcInvalidUnitsOfMeasurePrefix() {
  return [706, (0, _String.toText)((0, _String.printf)("Units-of-measure cannot be used as prefix arguments to a type. Rewrite as postfix arguments in angle brackets."))];
}

function SR$$$tcUnitsOfMeasureInvalidInTypeConstructor() {
  return [707, (0, _String.toText)((0, _String.printf)("Unit-of-measure cannot be used in type constructor application"))];
}

function SR$$$tcRequireBuilderMethod$$Z721C83C5(a0$$267) {
  return [708, (0, _String.toText)((0, _String.printf)("This control construct may only be used if the computation expression builder defines a '%s' method"))(a0$$267)];
}

function SR$$$tcTypeHasNoNestedTypes() {
  return [709, (0, _String.toText)((0, _String.printf)("This type has no nested types"))];
}

function SR$$$tcUnexpectedSymbolInTypeExpression$$Z721C83C5(a0$$268) {
  return [711, (0, _String.toText)((0, _String.printf)("Unexpected %s in type expression"))(a0$$268)];
}

function SR$$$tcTypeParameterInvalidAsTypeConstructor() {
  return [712, (0, _String.toText)((0, _String.printf)("Type parameter cannot be used as type constructor"))];
}

function SR$$$tcIllegalSyntaxInTypeExpression() {
  return [713, (0, _String.toText)((0, _String.printf)("Illegal syntax in type expression"))];
}

function SR$$$tcAnonymousUnitsOfMeasureCannotBeNested() {
  return [714, (0, _String.toText)((0, _String.printf)("Anonymous unit-of-measure cannot be nested inside another unit-of-measure expression"))];
}

function SR$$$tcAnonymousTypeInvalidInDeclaration() {
  return [715, (0, _String.toText)((0, _String.printf)("Anonymous type variables are not permitted in this declaration"))];
}

function SR$$$tcUnexpectedSlashInType() {
  return [716, (0, _String.toText)((0, _String.printf)("Unexpected / in type"))];
}

function SR$$$tcUnexpectedTypeArguments() {
  return [717, (0, _String.toText)((0, _String.printf)("Unexpected type arguments"))];
}

function SR$$$tcOptionalArgsOnlyOnMembers() {
  return [718, (0, _String.toText)((0, _String.printf)("Optional arguments are only permitted on type members"))];
}

function SR$$$tcNameNotBoundInPattern$$Z721C83C5(a0$$269) {
  return [719, (0, _String.toText)((0, _String.printf)("Name '%s' not bound in pattern context"))(a0$$269)];
}

function SR$$$tcInvalidNonPrimitiveLiteralInPatternMatch() {
  return [720, (0, _String.toText)((0, _String.printf)("Non-primitive numeric literal constants cannot be used in pattern matches because they can be mapped to multiple different types through the use of a NumericLiteral module. Consider using replacing with a variable, and use 'when <variable> = <constant>' at the end of the match clause."))];
}

function SR$$$tcInvalidTypeArgumentUsage() {
  return [721, (0, _String.toText)((0, _String.printf)("Type arguments cannot be specified here"))];
}

function SR$$$tcRequireActivePatternWithOneResult() {
  return [722, (0, _String.toText)((0, _String.printf)("Only active patterns returning exactly one result may accept arguments"))];
}

function SR$$$tcInvalidArgForParameterizedPattern() {
  return [723, (0, _String.toText)((0, _String.printf)("Invalid argument to parameterized pattern label"))];
}

function SR$$$tcInvalidIndexIntoActivePatternArray() {
  return [724, (0, _String.toText)((0, _String.printf)("Internal error. Invalid index into active pattern array"))];
}

function SR$$$tcUnionCaseDoesNotTakeArguments() {
  return [725, (0, _String.toText)((0, _String.printf)("This union case does not take arguments"))];
}

function SR$$$tcUnionCaseRequiresOneArgument() {
  return [726, (0, _String.toText)((0, _String.printf)("This union case takes one argument"))];
}

function SR$$$tcUnionCaseExpectsTupledArguments$$Z524259A4(a0$$270) {
  return [727, (0, _String.toText)((0, _String.printf)("This union case expects %d arguments in tupled form"))(a0$$270)];
}

function SR$$$tcFieldIsNotStatic$$Z721C83C5(a0$$271) {
  return [728, (0, _String.toText)((0, _String.printf)("Field '%s' is not static"))(a0$$271)];
}

function SR$$$tcFieldNotLiteralCannotBeUsedInPattern() {
  return [729, (0, _String.toText)((0, _String.printf)("This field is not a literal and cannot be used in a pattern"))];
}

function SR$$$tcRequireVarConstRecogOrLiteral() {
  return [730, (0, _String.toText)((0, _String.printf)("This is not a variable, constant, active recognizer or literal"))];
}

function SR$$$tcInvalidPattern() {
  return [731, (0, _String.toText)((0, _String.printf)("This is not a valid pattern"))];
}

function SR$$$tcUseWhenPatternGuard() {
  return (0, _String.toText)((0, _String.printf)("Character range matches have been removed in F#. Consider using a 'when' pattern guard instead."));
}

function SR$$$tcIllegalPattern() {
  return [733, (0, _String.toText)((0, _String.printf)("Illegal pattern"))];
}

function SR$$$tcSyntaxErrorUnexpectedQMark() {
  return [734, (0, _String.toText)((0, _String.printf)("Syntax error - unexpected '?' symbol"))];
}

function SR$$$tcExpressionCountMisMatch$$Z37302880(a0$$272, a1$$144) {
  return [735, (0, _String.toText)((0, _String.printf)("Expected %d expressions, got %d"))(a0$$272)(a1$$144)];
}

function SR$$$tcExprUndelayed() {
  return [736, (0, _String.toText)((0, _String.printf)("TcExprUndelayed: delayed"))];
}

function SR$$$tcExpressionRequiresSequence() {
  return [737, (0, _String.toText)((0, _String.printf)("This expression form may only be used in sequence and computation expressions"))];
}

function SR$$$tcInvalidObjectExpressionSyntaxForm() {
  return [738, (0, _String.toText)((0, _String.printf)("Invalid object expression. Objects without overrides or interfaces should use the expression form 'new Type(args)' without braces."))];
}

function SR$$$tcInvalidObjectSequenceOrRecordExpression() {
  return [739, (0, _String.toText)((0, _String.printf)("Invalid object, sequence or record expression"))];
}

function SR$$$tcInvalidSequenceExpressionSyntaxForm() {
  return [740, (0, _String.toText)((0, _String.printf)("Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq { ... }'"))];
}

function SR$$$tcExpressionWithIfRequiresParenthesis() {
  return (0, _String.toText)((0, _String.printf)("This list or array expression includes an element of the form 'if ... then ... else'. Parenthesize this expression to indicate it is an individual element of the list or array, to disambiguate this from a list generated using a sequence expression"));
}

function SR$$$tcUnableToParseFormatString$$Z721C83C5(a0$$273) {
  return [741, (0, _String.toText)((0, _String.printf)("Unable to parse format string '%s'"))(a0$$273)];
}

function SR$$$tcListLiteralMaxSize() {
  return [742, (0, _String.toText)((0, _String.printf)("This list expression exceeds the maximum size for list literals. Use an array for larger literals and call Array.ToList."))];
}

function SR$$$tcExpressionFormRequiresObjectConstructor() {
  return [743, (0, _String.toText)((0, _String.printf)("The expression form 'expr then expr' may only be used as part of an explicit object constructor"))];
}

function SR$$$tcNamedArgumentsCannotBeUsedInMemberTraits() {
  return [744, (0, _String.toText)((0, _String.printf)("Named arguments cannot be given to member trait calls"))];
}

function SR$$$tcNotValidEnumCaseName() {
  return [745, (0, _String.toText)((0, _String.printf)("This is not a valid name for an enumeration case"))];
}

function SR$$$tcFieldIsNotMutable() {
  return [746, (0, _String.toText)((0, _String.printf)("This field is not mutable"))];
}

function SR$$$tcConstructRequiresListArrayOrSequence() {
  return [747, (0, _String.toText)((0, _String.printf)("This construct may only be used within list, array and sequence expressions, e.g. expressions of the form 'seq { ... }', '[ ... ]' or '[| ... |]'. These use the syntax 'for ... in ... do ... yield...' to generate elements"))];
}

function SR$$$tcConstructRequiresComputationExpressions() {
  return [748, (0, _String.toText)((0, _String.printf)("This construct may only be used within computation expressions. To return a value from an ordinary function simply write the expression without 'return'."))];
}

function SR$$$tcConstructRequiresSequenceOrComputations() {
  return [749, (0, _String.toText)((0, _String.printf)("This construct may only be used within sequence or computation expressions"))];
}

function SR$$$tcConstructRequiresComputationExpression() {
  return [750, (0, _String.toText)((0, _String.printf)("This construct may only be used within computation expressions"))];
}

function SR$$$tcInvalidIndexerExpression() {
  return [751, (0, _String.toText)((0, _String.printf)("Invalid indexer expression"))];
}

function SR$$$tcObjectOfIndeterminateTypeUsedRequireTypeConstraint() {
  return [752, (0, _String.toText)((0, _String.printf)("The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints"))];
}

function SR$$$tcCannotInheritFromVariableType() {
  return [753, (0, _String.toText)((0, _String.printf)("Cannot inherit from a variable type"))];
}

function SR$$$tcObjectConstructorsOnTypeParametersCannotTakeArguments() {
  return [754, (0, _String.toText)((0, _String.printf)("Calls to object constructors on type parameters cannot be given arguments"))];
}

function SR$$$tcCompiledNameAttributeMisused() {
  return [755, (0, _String.toText)((0, _String.printf)("The 'CompiledName' attribute cannot be used with this language element"))];
}

function SR$$$tcNamedTypeRequired$$Z721C83C5(a0$$274) {
  return [756, (0, _String.toText)((0, _String.printf)("'%s' may only be used with named types"))(a0$$274)];
}

function SR$$$tcInheritCannotBeUsedOnInterfaceType() {
  return [757, (0, _String.toText)((0, _String.printf)("'inherit' cannot be used on interface types. Consider implementing the interface by using 'interface ... with ... end' instead."))];
}

function SR$$$tcNewCannotBeUsedOnInterfaceType() {
  return [758, (0, _String.toText)((0, _String.printf)("'new' cannot be used on interface types. Consider using an object expression '{ new ... with ... }' instead."))];
}

function SR$$$tcAbstractTypeCannotBeInstantiated() {
  return [759, (0, _String.toText)((0, _String.printf)("Instances of this type cannot be created since it has been marked abstract or not all methods have been given implementations. Consider using an object expression '{ new ... with ... }' instead."))];
}

function SR$$$tcIDisposableTypeShouldUseNew() {
  return [760, (0, _String.toText)((0, _String.printf)("It is recommended that objects supporting the IDisposable interface are created using the syntax 'new Type(args)', rather than 'Type(args)' or 'Type' as a function value representing the constructor, to indicate that resources may be owned by the generated value"))];
}

function SR$$$tcSyntaxCanOnlyBeUsedToCreateObjectTypes$$Z721C83C5(a0$$275) {
  return [761, (0, _String.toText)((0, _String.printf)("'%s' may only be used to construct object types"))(a0$$275)];
}

function SR$$$tcConstructorRequiresCall$$Z721C83C5(a0$$276) {
  return [762, (0, _String.toText)((0, _String.printf)("Constructors for the type '%s' must directly or indirectly call its implicit object constructor. Use a call to the implicit object constructor instead of a record expression."))(a0$$276)];
}

function SR$$$tcUndefinedField$$Z384F8060(a0$$277, a1$$145) {
  return [763, (0, _String.toText)((0, _String.printf)("The field '%s' has been given a value, but is not present in the type '%s'"))(a0$$277)(a1$$145)];
}

function SR$$$tcFieldRequiresAssignment$$Z384F8060(a0$$278, a1$$146) {
  return [764, (0, _String.toText)((0, _String.printf)("No assignment given for field '%s' of type '%s'"))(a0$$278)(a1$$146)];
}

function SR$$$tcExtraneousFieldsGivenValues() {
  return [765, (0, _String.toText)((0, _String.printf)("Extraneous fields have been given values"))];
}

function SR$$$tcObjectExpressionsCanOnlyOverrideAbstractOrVirtual() {
  return [766, (0, _String.toText)((0, _String.printf)("Only overrides of abstract and virtual members may be specified in object expressions"))];
}

function SR$$$tcNoAbstractOrVirtualMemberFound$$Z721C83C5(a0$$279) {
  return [767, (0, _String.toText)((0, _String.printf)("The member '%s' does not correspond to any abstract or virtual method available to override or implement."))(a0$$279)];
}

function SR$$$tcMemberFoundIsNotAbstractOrVirtual$$Z384F8060(a0$$280, a1$$147) {
  return [767, (0, _String.toText)((0, _String.printf)("The type %s contains the member '%s' but it is not a virtual or abstract method that is available to override or implement."))(a0$$280)(a1$$147)];
}

function SR$$$tcArgumentArityMismatch$$8A8C5B(a0$$281, a1$$148, a2$$60, a3$$16, a4$$3) {
  return [768, (0, _String.toText)((0, _String.printf)("The member '%s' does not accept the correct number of arguments. %d argument(s) are expected, but %d were given. The required signature is '%s'.%s"))(a0$$281)(a1$$148)(a2$$60)(a3$$16)(a4$$3)];
}

function SR$$$tcArgumentArityMismatchOneOverload$$8A8C5B(a0$$282, a1$$149, a2$$61, a3$$17, a4$$4) {
  return [769, (0, _String.toText)((0, _String.printf)("The member '%s' does not accept the correct number of arguments. One overload accepts %d arguments, but %d were given. The required signature is '%s'.%s"))(a0$$282)(a1$$149)(a2$$61)(a3$$17)(a4$$4)];
}

function SR$$$tcSimpleMethodNameRequired() {
  return [770, (0, _String.toText)((0, _String.printf)("A simple method name is required here"))];
}

function SR$$$tcPredefinedTypeCannotBeUsedAsSuperType() {
  return [771, (0, _String.toText)((0, _String.printf)("The types System.ValueType, System.Enum, System.Delegate, System.MulticastDelegate and System.Array cannot be used as super types in an object expression or class"))];
}

function SR$$$tcNewMustBeUsedWithNamedType() {
  return [772, (0, _String.toText)((0, _String.printf)("'new' must be used with a named type"))];
}

function SR$$$tcCannotCreateExtensionOfSealedType() {
  return [773, (0, _String.toText)((0, _String.printf)("Cannot create an extension of a sealed type"))];
}

function SR$$$tcNoArgumentsForRecordValue() {
  return [774, (0, _String.toText)((0, _String.printf)("No arguments may be given when constructing a record value"))];
}

function SR$$$tcNoInterfaceImplementationForConstructionExpression() {
  return [775, (0, _String.toText)((0, _String.printf)("Interface implementations cannot be given on construction expressions"))];
}

function SR$$$tcObjectConstructionCanOnlyBeUsedInClassTypes() {
  return [776, (0, _String.toText)((0, _String.printf)("Object construction expressions may only be used to implement constructors in class types"))];
}

function SR$$$tcOnlySimpleBindingsCanBeUsedInConstructionExpressions() {
  return [777, (0, _String.toText)((0, _String.printf)("Only simple bindings of the form 'id = expr' can be used in construction expressions"))];
}

function SR$$$tcObjectsMustBeInitializedWithObjectExpression() {
  return [778, (0, _String.toText)((0, _String.printf)("Objects must be initialized by an object construction expression that calls an inherited object constructor and assigns a value to each field"))];
}

function SR$$$tcExpectedInterfaceType() {
  return [779, (0, _String.toText)((0, _String.printf)("Expected an interface type"))];
}

function SR$$$tcConstructorForInterfacesDoNotTakeArguments() {
  return [780, (0, _String.toText)((0, _String.printf)("Constructor expressions for interfaces do not take arguments"))];
}

function SR$$$tcConstructorRequiresArguments() {
  return [781, (0, _String.toText)((0, _String.printf)("This object constructor requires arguments"))];
}

function SR$$$tcNewRequiresObjectConstructor() {
  return [782, (0, _String.toText)((0, _String.printf)("'new' may only be used with object constructors"))];
}

function SR$$$tcAtLeastOneOverrideIsInvalid() {
  return [783, (0, _String.toText)((0, _String.printf)("At least one override did not correctly implement its corresponding abstract member"))];
}

function SR$$$tcNumericLiteralRequiresModule$$Z721C83C5(a0$$283) {
  return [784, (0, _String.toText)((0, _String.printf)("This numeric literal requires that a module '%s' defining functions FromZero, FromOne, FromInt32, FromInt64 and FromString be in scope"))(a0$$283)];
}

function SR$$$tcInvalidRecordConstruction() {
  return [785, (0, _String.toText)((0, _String.printf)("Invalid record construction"))];
}

function SR$$$tcExpressionFormRequiresRecordTypes() {
  return [786, (0, _String.toText)((0, _String.printf)("The expression form { expr with ... } may only be used with record types. To build object types use { new Type(...) with ... }"))];
}

function SR$$$tcInheritedTypeIsNotObjectModelType() {
  return [787, (0, _String.toText)((0, _String.printf)("The inherited type is not an object model type"))];
}

function SR$$$tcObjectConstructionExpressionCanOnlyImplementConstructorsInObjectModelTypes() {
  return [788, (0, _String.toText)((0, _String.printf)("Object construction expressions (i.e. record expressions with inheritance specifications) may only be used to implement constructors in object model types. Use 'new ObjectType(args)' to construct instances of object model types outside of constructors"))];
}

function SR$$$tcEmptyRecordInvalid() {
  return [789, (0, _String.toText)((0, _String.printf)("'{ }' is not a valid expression. Records must include at least one field. Empty sequences are specified by using Seq.empty or an empty list '[]'."))];
}

function SR$$$tcTypeIsNotARecordTypeNeedConstructor() {
  return [790, (0, _String.toText)((0, _String.printf)("This type is not a record type. Values of class and struct types must be created using calls to object constructors."))];
}

function SR$$$tcTypeIsNotARecordType() {
  return [791, (0, _String.toText)((0, _String.printf)("This type is not a record type"))];
}

function SR$$$tcConstructIsAmbiguousInComputationExpression() {
  return [792, (0, _String.toText)((0, _String.printf)("This construct is ambiguous as part of a computation expression. Nested expressions may be written using 'let _ = (...)' and nested computations using 'let! res = builder { ... }'."))];
}

function SR$$$tcConstructIsAmbiguousInSequenceExpression() {
  return [793, (0, _String.toText)((0, _String.printf)("This construct is ambiguous as part of a sequence expression. Nested expressions may be written using 'let _ = (...)' and nested sequences using 'yield! seq {... }'."))];
}

function SR$$$tcDoBangIllegalInSequenceExpression() {
  return [794, (0, _String.toText)((0, _String.printf)("'do!' cannot be used within sequence expressions"))];
}

function SR$$$tcUseForInSequenceExpression() {
  return [795, (0, _String.toText)((0, _String.printf)("The use of 'let! x = coll' in sequence expressions is not permitted. Use 'for x in coll' instead."))];
}

function SR$$$tcTryIllegalInSequenceExpression() {
  return [796, (0, _String.toText)((0, _String.printf)("'try'/'with' cannot be used within sequence expressions"))];
}

function SR$$$tcUseYieldBangForMultipleResults() {
  return [797, (0, _String.toText)((0, _String.printf)("In sequence expressions, multiple results are generated using 'yield!'"))];
}

function SR$$$tcInvalidAssignment() {
  return [799, (0, _String.toText)((0, _String.printf)("Invalid assignment"))];
}

function SR$$$tcInvalidUseOfTypeName() {
  return [800, (0, _String.toText)((0, _String.printf)("Invalid use of a type name"))];
}

function SR$$$tcTypeHasNoAccessibleConstructor() {
  return [801, (0, _String.toText)((0, _String.printf)("This type has no accessible object constructors"))];
}

function SR$$$tcInvalidUseOfInterfaceType() {
  return [804, (0, _String.toText)((0, _String.printf)("Invalid use of an interface type"))];
}

function SR$$$tcInvalidUseOfDelegate() {
  return [805, (0, _String.toText)((0, _String.printf)("Invalid use of a delegate constructor. Use the syntax 'new Type(args)' or just 'Type(args)'."))];
}

function SR$$$tcPropertyIsNotStatic$$Z721C83C5(a0$$284) {
  return [806, (0, _String.toText)((0, _String.printf)("Property '%s' is not static"))(a0$$284)];
}

function SR$$$tcPropertyIsNotReadable$$Z721C83C5(a0$$285) {
  return [807, (0, _String.toText)((0, _String.printf)("Property '%s' is not readable"))(a0$$285)];
}

function SR$$$tcLookupMayNotBeUsedHere() {
  return [808, (0, _String.toText)((0, _String.printf)("This lookup cannot be used here"))];
}

function SR$$$tcPropertyIsStatic$$Z721C83C5(a0$$286) {
  return [809, (0, _String.toText)((0, _String.printf)("Property '%s' is static"))(a0$$286)];
}

function SR$$$tcPropertyCannotBeSet1$$Z721C83C5(a0$$287) {
  return [810, (0, _String.toText)((0, _String.printf)("Property '%s' cannot be set"))(a0$$287)];
}

function SR$$$tcConstructorsCannotBeFirstClassValues() {
  return [811, (0, _String.toText)((0, _String.printf)("Constructors must be applied to arguments and cannot be used as first-class values. If necessary use an anonymous function '(fun arg1 ... argN -> new Type(arg1,...,argN))'."))];
}

function SR$$$tcSyntaxFormUsedOnlyWithRecordLabelsPropertiesAndFields() {
  return [812, (0, _String.toText)((0, _String.printf)("The syntax 'expr.id' may only be used with record labels, properties and fields"))];
}

function SR$$$tcEventIsStatic$$Z721C83C5(a0$$288) {
  return [813, (0, _String.toText)((0, _String.printf)("Event '%s' is static"))(a0$$288)];
}

function SR$$$tcEventIsNotStatic$$Z721C83C5(a0$$289) {
  return [814, (0, _String.toText)((0, _String.printf)("Event '%s' is not static"))(a0$$289)];
}

function SR$$$tcNamedArgumentDidNotMatch$$Z721C83C5(a0$$290) {
  return [815, (0, _String.toText)((0, _String.printf)("The named argument '%s' did not match any argument or mutable property"))(a0$$290)];
}

function SR$$$tcOverloadsCannotHaveCurriedArguments() {
  return [816, (0, _String.toText)((0, _String.printf)("One or more of the overloads of this method has curried arguments. Consider redesigning these members to take arguments in tupled form."))];
}

function SR$$$tcUnnamedArgumentsDoNotFormPrefix() {
  return (0, _String.toText)((0, _String.printf)("The unnamed arguments do not form a prefix of the arguments of the method called"));
}

function SR$$$tcStaticOptimizationConditionalsOnlyForFSharpLibrary() {
  return [817, (0, _String.toText)((0, _String.printf)("Static optimization conditionals are only for use within the F# library"))];
}

function SR$$$tcFormalArgumentIsNotOptional() {
  return [818, (0, _String.toText)((0, _String.printf)("The corresponding formal argument is not optional"))];
}

function SR$$$tcInvalidOptionalAssignmentToPropertyOrField() {
  return [819, (0, _String.toText)((0, _String.printf)("Invalid optional assignment to a property or field"))];
}

function SR$$$tcDelegateConstructorMustBePassed() {
  return [820, (0, _String.toText)((0, _String.printf)("A delegate constructor must be passed a single function value"))];
}

function SR$$$tcBindingCannotBeUseAndRec() {
  return [821, (0, _String.toText)((0, _String.printf)("A binding cannot be marked both 'use' and 'rec'"))];
}

function SR$$$tcVolatileOnlyOnClassLetBindings() {
  return [823, (0, _String.toText)((0, _String.printf)("The 'VolatileField' attribute may only be used on 'let' bindings in classes"))];
}

function SR$$$tcAttributesAreNotPermittedOnLetBindings() {
  return [824, (0, _String.toText)((0, _String.printf)("Attributes are not permitted on 'let' bindings in expressions"))];
}

function SR$$$tcDefaultValueAttributeRequiresVal() {
  return [825, (0, _String.toText)((0, _String.printf)("The 'DefaultValue' attribute may only be used on 'val' declarations"))];
}

function SR$$$tcConditionalAttributeRequiresMembers() {
  return [826, (0, _String.toText)((0, _String.printf)("The 'ConditionalAttribute' attribute may only be used on members"))];
}

function SR$$$tcInvalidActivePatternName() {
  return [827, (0, _String.toText)((0, _String.printf)("This is not a valid name for an active pattern"))];
}

function SR$$$tcEntryPointAttributeRequiresFunctionInModule() {
  return [828, (0, _String.toText)((0, _String.printf)("The 'EntryPointAttribute' attribute may only be used on function definitions in modules"))];
}

function SR$$$tcMutableValuesCannotBeInline() {
  return [829, (0, _String.toText)((0, _String.printf)("Mutable values cannot be marked 'inline'"))];
}

function SR$$$tcMutableValuesMayNotHaveGenericParameters() {
  return [830, (0, _String.toText)((0, _String.printf)("Mutable values cannot have generic parameters"))];
}

function SR$$$tcMutableValuesSyntax() {
  return [831, (0, _String.toText)((0, _String.printf)("Mutable function values should be written 'let mutable f = (fun args -> ...)'"))];
}

function SR$$$tcOnlyFunctionsCanBeInline() {
  return [832, (0, _String.toText)((0, _String.printf)("Only functions may be marked 'inline'"))];
}

function SR$$$tcIllegalAttributesForLiteral() {
  return [833, (0, _String.toText)((0, _String.printf)("A literal value cannot be given the [<ThreadStatic>] or [<ContextStatic>] attributes"))];
}

function SR$$$tcLiteralCannotBeMutable() {
  return [834, (0, _String.toText)((0, _String.printf)("A literal value cannot be marked 'mutable'"))];
}

function SR$$$tcLiteralCannotBeInline() {
  return [835, (0, _String.toText)((0, _String.printf)("A literal value cannot be marked 'inline'"))];
}

function SR$$$tcLiteralCannotHaveGenericParameters() {
  return [836, (0, _String.toText)((0, _String.printf)("Literal values cannot have generic parameters"))];
}

function SR$$$tcInvalidConstantExpression() {
  return [837, (0, _String.toText)((0, _String.printf)("This is not a valid constant expression"))];
}

function SR$$$tcTypeIsInaccessible() {
  return [838, (0, _String.toText)((0, _String.printf)("This type is not accessible from this code location"))];
}

function SR$$$tcUnexpectedConditionInImportedAssembly() {
  return [839, (0, _String.toText)((0, _String.printf)("Unexpected condition in imported assembly: failed to decode AttributeUsage attribute"))];
}

function SR$$$tcUnrecognizedAttributeTarget() {
  return [840, (0, _String.toText)((0, _String.printf)("Unrecognized attribute target. Valid attribute targets are 'assembly', 'module', 'type', 'method', 'property', 'return', 'param', 'field', 'event', 'constructor'."))];
}

function SR$$$tcAttributeIsNotValidForLanguageElementUseDo() {
  return [841, (0, _String.toText)((0, _String.printf)("This attribute is not valid for use on this language element. Assembly attributes should be attached to a 'do ()' declaration, if necessary within an F# module."))];
}

function SR$$$tcAttributeIsNotValidForLanguageElement() {
  return [842, (0, _String.toText)((0, _String.printf)("This attribute is not valid for use on this language element"))];
}

function SR$$$tcOptionalArgumentsCannotBeUsedInCustomAttribute() {
  return [843, (0, _String.toText)((0, _String.printf)("Optional arguments cannot be used in custom attributes"))];
}

function SR$$$tcPropertyCannotBeSet0() {
  return [844, (0, _String.toText)((0, _String.printf)("This property cannot be set"))];
}

function SR$$$tcPropertyOrFieldNotFoundInAttribute() {
  return [845, (0, _String.toText)((0, _String.printf)("This property or field was not found on this custom attribute type"))];
}

function SR$$$tcCustomAttributeMustBeReferenceType() {
  return [846, (0, _String.toText)((0, _String.printf)("A custom attribute must be a reference type"))];
}

function SR$$$tcCustomAttributeArgumentMismatch() {
  return [847, (0, _String.toText)((0, _String.printf)("The number of args for a custom attribute does not match the expected number of args for the attribute constructor"))];
}

function SR$$$tcCustomAttributeMustInvokeConstructor() {
  return [848, (0, _String.toText)((0, _String.printf)("A custom attribute must invoke an object constructor"))];
}

function SR$$$tcAttributeExpressionsMustBeConstructorCalls() {
  return [849, (0, _String.toText)((0, _String.printf)("Attribute expressions must be calls to object constructors"))];
}

function SR$$$tcUnsupportedAttribute() {
  return [850, (0, _String.toText)((0, _String.printf)("This attribute cannot be used in this version of F#"))];
}

function SR$$$tcInvalidInlineSpecification() {
  return [851, (0, _String.toText)((0, _String.printf)("Invalid inline specification"))];
}

function SR$$$tcInvalidUseBinding() {
  return [852, (0, _String.toText)((0, _String.printf)("'use' bindings must be of the form 'use <var> = <expr>'"))];
}

function SR$$$tcAbstractMembersIllegalInAugmentation() {
  return [853, (0, _String.toText)((0, _String.printf)("Abstract members are not permitted in an augmentation - they must be defined as part of the type itself"))];
}

function SR$$$tcMethodOverridesIllegalHere() {
  return [854, (0, _String.toText)((0, _String.printf)("Method overrides and interface implementations are not permitted here"))];
}

function SR$$$tcNoMemberFoundForOverride() {
  return [855, (0, _String.toText)((0, _String.printf)("No abstract or interface member was found that corresponds to this override"))];
}

function SR$$$tcOverrideArityMismatch$$Z721C83C5(a0$$291) {
  return [856, (0, _String.toText)((0, _String.printf)("This override takes a different number of arguments to the corresponding abstract member. The following abstract members were found:%s"))(a0$$291)];
}

function SR$$$tcDefaultImplementationAlreadyExists() {
  return [857, (0, _String.toText)((0, _String.printf)("This method already has a default implementation"))];
}

function SR$$$tcDefaultAmbiguous() {
  return [858, (0, _String.toText)((0, _String.printf)("The method implemented by this default is ambiguous"))];
}

function SR$$$tcNoPropertyFoundForOverride() {
  return [859, (0, _String.toText)((0, _String.printf)("No abstract property was found that corresponds to this override"))];
}

function SR$$$tcAbstractPropertyMissingGetOrSet$$Z721C83C5(a0$$292) {
  return [860, (0, _String.toText)((0, _String.printf)("This property overrides or implements an abstract property but the abstract property doesn't have a corresponding %s"))(a0$$292)];
}

function SR$$$tcInvalidSignatureForSet() {
  return [861, (0, _String.toText)((0, _String.printf)("Invalid signature for set member"))];
}

function SR$$$tcNewMemberHidesAbstractMember$$Z721C83C5(a0$$293) {
  return [864, (0, _String.toText)((0, _String.printf)("This new member hides the abstract member '%s'. Rename the member or use 'override' instead."))(a0$$293)];
}

function SR$$$tcNewMemberHidesAbstractMemberWithSuffix$$Z721C83C5(a0$$294) {
  return [864, (0, _String.toText)((0, _String.printf)("This new member hides the abstract member '%s' once tuples, functions, units of measure and/or provided types are erased. Rename the member or use 'override' instead."))(a0$$294)];
}

function SR$$$tcStaticInitializersIllegalInInterface() {
  return [865, (0, _String.toText)((0, _String.printf)("Interfaces cannot contain definitions of static initializers"))];
}

function SR$$$tcObjectConstructorsIllegalInInterface() {
  return [866, (0, _String.toText)((0, _String.printf)("Interfaces cannot contain definitions of object constructors"))];
}

function SR$$$tcMemberOverridesIllegalInInterface() {
  return [867, (0, _String.toText)((0, _String.printf)("Interfaces cannot contain definitions of member overrides"))];
}

function SR$$$tcConcreteMembersIllegalInInterface() {
  return [868, (0, _String.toText)((0, _String.printf)("Interfaces cannot contain definitions of concrete members. You may need to define a constructor on your type to indicate that the type is a class."))];
}

function SR$$$tcConstructorsDisallowedInExceptionAugmentation() {
  return [869, (0, _String.toText)((0, _String.printf)("Constructors cannot be specified in exception augmentations"))];
}

function SR$$$tcStructsCannotHaveConstructorWithNoArguments() {
  return [870, (0, _String.toText)((0, _String.printf)("Structs cannot have an object constructor with no arguments. This is a restriction imposed on all CLI languages as structs automatically support a default constructor."))];
}

function SR$$$tcConstructorsIllegalForThisType() {
  return [871, (0, _String.toText)((0, _String.printf)("Constructors cannot be defined for this type"))];
}

function SR$$$tcRecursiveBindingsWithMembersMustBeDirectAugmentation() {
  return [872, (0, _String.toText)((0, _String.printf)("Recursive bindings that include member specifications can only occur as a direct augmentation of a type"))];
}

function SR$$$tcOnlySimplePatternsInLetRec() {
  return [873, (0, _String.toText)((0, _String.printf)("Only simple variable patterns can be bound in 'let rec' constructs"))];
}

function SR$$$tcOnlyRecordFieldsAndSimpleLetCanBeMutable() {
  return [874, (0, _String.toText)((0, _String.printf)("Only record fields and simple, non-recursive 'let' bindings may be marked mutable"))];
}

function SR$$$tcMemberIsNotSufficientlyGeneric() {
  return [875, (0, _String.toText)((0, _String.printf)("This member is not sufficiently generic"))];
}

function SR$$$tcLiteralAttributeRequiresConstantValue() {
  return [876, (0, _String.toText)((0, _String.printf)("A declaration may only be the [<Literal>] attribute if a constant value is also given, e.g. 'val x : int = 1'"))];
}

function SR$$$tcValueInSignatureRequiresLiteralAttribute() {
  return [877, (0, _String.toText)((0, _String.printf)("A declaration may only be given a value in a signature if the declaration has the [<Literal>] attribute"))];
}

function SR$$$tcThreadStaticAndContextStaticMustBeStatic() {
  return [878, (0, _String.toText)((0, _String.printf)("Thread-static and context-static variables must be static and given the [<DefaultValue>] attribute to indicate that the value is initialized to the default value on each new thread"))];
}

function SR$$$tcVolatileFieldsMustBeMutable() {
  return [879, (0, _String.toText)((0, _String.printf)("Volatile fields must be marked 'mutable' and cannot be thread-static"))];
}

function SR$$$tcUninitializedValFieldsMustBeMutable() {
  return [880, (0, _String.toText)((0, _String.printf)("Uninitialized 'val' fields must be mutable and marked with the '[<DefaultValue>]' attribute. Consider using a 'let' binding instead of a 'val' field."))];
}

function SR$$$tcStaticValFieldsMustBeMutableAndPrivate() {
  return [881, (0, _String.toText)((0, _String.printf)("Static 'val' fields in types must be mutable, private and marked with the '[<DefaultValue>]' attribute. They are initialized to the 'null' or 'zero' value for their type. Consider also using a 'static let mutable' binding in a class type."))];
}

function SR$$$tcFieldRequiresName() {
  return [882, (0, _String.toText)((0, _String.printf)("This field requires a name"))];
}

function SR$$$tcInvalidNamespaceModuleTypeUnionName() {
  return [883, (0, _String.toText)((0, _String.printf)("Invalid namespace, module, type or union case name"))];
}

function SR$$$tcIllegalFormForExplicitTypeDeclaration() {
  return [884, (0, _String.toText)((0, _String.printf)("Explicit type declarations for constructors must be of the form 'ty1 * ... * tyN -> resTy'. Parentheses may be required around 'resTy'"))];
}

function SR$$$tcReturnTypesForUnionMustBeSameAsType() {
  return [885, (0, _String.toText)((0, _String.printf)("Return types of union cases must be identical to the type being defined, up to abbreviations"))];
}

function SR$$$tcInvalidEnumerationLiteral() {
  return [886, (0, _String.toText)((0, _String.printf)("This is not a valid value for an enumeration literal"))];
}

function SR$$$tcTypeIsNotInterfaceType1$$Z721C83C5(a0$$295) {
  return [887, (0, _String.toText)((0, _String.printf)("The type '%s' is not an interface type"))(a0$$295)];
}

function SR$$$tcDuplicateSpecOfInterface() {
  return [888, (0, _String.toText)((0, _String.printf)("Duplicate specification of an interface"))];
}

function SR$$$tcFieldValIllegalHere() {
  return [889, (0, _String.toText)((0, _String.printf)("A field/val declaration is not permitted here"))];
}

function SR$$$tcInheritIllegalHere() {
  return [890, (0, _String.toText)((0, _String.printf)("A inheritance declaration is not permitted here"))];
}

function SR$$$tcModuleRequiresQualifiedAccess$$Z721C83C5(a0$$296) {
  return [892, (0, _String.toText)((0, _String.printf)("This declaration opens the module '%s', which is marked as 'RequireQualifiedAccess'. Adjust your code to use qualified references to the elements of the module instead, e.g. 'List.map' instead of 'map'. This change will ensure that your code is robust as new constructs are added to libraries."))(a0$$296)];
}

function SR$$$tcOpenUsedWithPartiallyQualifiedPath$$Z721C83C5(a0$$297) {
  return [893, (0, _String.toText)((0, _String.printf)("This declaration opens the namespace or module '%s' through a partially qualified path. Adjust this code to use the full path of the namespace. This change will make your code more robust as new constructs are added to the F# and CLI libraries."))(a0$$297)];
}

function SR$$$tcLocalClassBindingsCannotBeInline() {
  return [894, (0, _String.toText)((0, _String.printf)("Local class bindings cannot be marked inline. Consider lifting the definition out of the class or else do not mark it as inline."))];
}

function SR$$$tcTypeAbbreviationsMayNotHaveMembers() {
  return [895, (0, _String.toText)((0, _String.printf)("Type abbreviations cannot have members"))];
}

function SR$$$tcTypeAbbreviationsCheckedAtCompileTime() {
  return (0, _String.toText)((0, _String.printf)("As of F# 4.1, the accessibility of type abbreviations is checked at compile-time. Consider changing the accessibility of the type abbreviation. Ignoring this warning might lead to runtime errors."));
}

function SR$$$tcEnumerationsMayNotHaveMembers() {
  return [896, (0, _String.toText)((0, _String.printf)("Enumerations cannot have members"))];
}

function SR$$$tcMeasureDeclarationsRequireStaticMembers() {
  return [897, (0, _String.toText)((0, _String.printf)("Measure declarations may have only static members"))];
}

function SR$$$tcStructsMayNotContainDoBindings() {
  return (0, _String.toText)((0, _String.printf)("Structs cannot contain 'do' bindings because the default constructor for structs would not execute these bindings"));
}

function SR$$$tcStructsMayNotContainLetBindings() {
  return [901, (0, _String.toText)((0, _String.printf)("Structs cannot contain value definitions because the default constructor for structs will not execute these bindings. Consider adding additional arguments to the primary constructor for the type."))];
}

function SR$$$tcStaticLetBindingsRequireClassesWithImplicitConstructors() {
  return [902, (0, _String.toText)((0, _String.printf)("Static value definitions may only be used in types with a primary constructor. Consider adding arguments to the type definition, e.g. 'type X(args) = ...'."))];
}

function SR$$$tcMeasureDeclarationsRequireStaticMembersNotConstructors() {
  return [904, (0, _String.toText)((0, _String.printf)("Measure declarations may have only static members: constructors are not available"))];
}

function SR$$$tcMemberAndLocalClassBindingHaveSameName$$Z721C83C5(a0$$298) {
  return [905, (0, _String.toText)((0, _String.printf)("A member and a local class binding both have the name '%s'"))(a0$$298)];
}

function SR$$$tcTypeAbbreviationsCannotHaveInterfaceDeclaration() {
  return [906, (0, _String.toText)((0, _String.printf)("Type abbreviations cannot have interface declarations"))];
}

function SR$$$tcEnumerationsCannotHaveInterfaceDeclaration() {
  return [907, (0, _String.toText)((0, _String.printf)("Enumerations cannot have interface declarations"))];
}

function SR$$$tcTypeIsNotInterfaceType0() {
  return [908, (0, _String.toText)((0, _String.printf)("This type is not an interface type"))];
}

function SR$$$tcAllImplementedInterfacesShouldBeDeclared() {
  return [909, (0, _String.toText)((0, _String.printf)("All implemented interfaces should be declared on the initial declaration of the type"))];
}

function SR$$$tcDefaultImplementationForInterfaceHasAlreadyBeenAdded() {
  return [910, (0, _String.toText)((0, _String.printf)("A default implementation of this interface has already been added because the explicit implementation of the interface was not specified at the definition of the type"))];
}

function SR$$$tcMemberNotPermittedInInterfaceImplementation() {
  return [911, (0, _String.toText)((0, _String.printf)("This member is not permitted in an interface implementation"))];
}

function SR$$$tcDeclarationElementNotPermittedInAugmentation() {
  return [912, (0, _String.toText)((0, _String.printf)("This declaration element is not permitted in an augmentation"))];
}

function SR$$$tcTypesCannotContainNestedTypes() {
  return [913, (0, _String.toText)((0, _String.printf)("Types cannot contain nested type definitions"))];
}

function SR$$$tcTypeExceptionOrModule() {
  return (0, _String.toText)((0, _String.printf)("type, exception or module"));
}

function SR$$$tcTypeOrModule() {
  return (0, _String.toText)((0, _String.printf)("type or module"));
}

function SR$$$tcImplementsIStructuralEquatableExplicitly$$Z721C83C5(a0$$299) {
  return [914, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' implements the interface 'System.IStructuralEquatable' explicitly. Apply the 'CustomEquality' attribute to the type."))(a0$$299)];
}

function SR$$$tcImplementsIEquatableExplicitly$$Z721C83C5(a0$$300) {
  return [915, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' implements the interface 'System.IEquatable<_>' explicitly. Apply the 'CustomEquality' attribute to the type and provide a consistent implementation of the non-generic override 'System.Object.Equals(obj)'."))(a0$$300)];
}

function SR$$$tcExplicitTypeSpecificationCannotBeUsedForExceptionConstructors() {
  return [916, (0, _String.toText)((0, _String.printf)("Explicit type specifications cannot be used for exception constructors"))];
}

function SR$$$tcExceptionAbbreviationsShouldNotHaveArgumentList() {
  return [917, (0, _String.toText)((0, _String.printf)("Exception abbreviations should not have argument lists"))];
}

function SR$$$tcAbbreviationsFordotNetExceptionsCannotTakeArguments() {
  return [918, (0, _String.toText)((0, _String.printf)("Abbreviations for Common IL exceptions cannot take arguments"))];
}

function SR$$$tcExceptionAbbreviationsMustReferToValidExceptions() {
  return [919, (0, _String.toText)((0, _String.printf)("Exception abbreviations must refer to existing exceptions or F# types deriving from System.Exception"))];
}

function SR$$$tcAbbreviationsFordotNetExceptionsMustHaveMatchingObjectConstructor() {
  return [920, (0, _String.toText)((0, _String.printf)("Abbreviations for Common IL exception types must have a matching object constructor"))];
}

function SR$$$tcNotAnException() {
  return [921, (0, _String.toText)((0, _String.printf)("Not an exception"))];
}

function SR$$$tcInvalidModuleName() {
  return [924, (0, _String.toText)((0, _String.printf)("Invalid module name"))];
}

function SR$$$tcInvalidTypeExtension() {
  return [925, (0, _String.toText)((0, _String.printf)("Invalid type extension"))];
}

function SR$$$tcAttributesOfTypeSpecifyMultipleKindsForType() {
  return [926, (0, _String.toText)((0, _String.printf)("The attributes of this type specify multiple kinds for the type"))];
}

function SR$$$tcKindOfTypeSpecifiedDoesNotMatchDefinition() {
  return [927, (0, _String.toText)((0, _String.printf)("The kind of the type specified by its attributes does not match the kind implied by its definition"))];
}

function SR$$$tcMeasureDefinitionsCannotHaveTypeParameters() {
  return [928, (0, _String.toText)((0, _String.printf)("Measure definitions cannot have type parameters"))];
}

function SR$$$tcTypeRequiresDefinition() {
  return [929, (0, _String.toText)((0, _String.printf)("This type requires a definition"))];
}

function SR$$$tcTypeAbbreviationHasTypeParametersMissingOnType() {
  return (0, _String.toText)((0, _String.printf)("This type abbreviation has one or more declared type parameters that do not appear in the type being abbreviated. Type abbreviations must use all declared type parameters in the type being abbreviated. Consider removing one or more type parameters, or use a concrete type definition that wraps an underlying type, such as 'type C<'a> = C of ...'."));
}

function SR$$$tcStructsInterfacesEnumsDelegatesMayNotInheritFromOtherTypes() {
  return [931, (0, _String.toText)((0, _String.printf)("Structs, interfaces, enums and delegates cannot inherit from other types"))];
}

function SR$$$tcTypesCannotInheritFromMultipleConcreteTypes() {
  return [932, (0, _String.toText)((0, _String.printf)("Types cannot inherit from multiple concrete types"))];
}

function SR$$$tcRecordsUnionsAbbreviationsStructsMayNotHaveAllowNullLiteralAttribute() {
  return [934, (0, _String.toText)((0, _String.printf)("Records, union, abbreviations and struct types cannot have the 'AllowNullLiteral' attribute"))];
}

function SR$$$tcAllowNullTypesMayOnlyInheritFromAllowNullTypes() {
  return [935, (0, _String.toText)((0, _String.printf)("Types with the 'AllowNullLiteral' attribute may only inherit from or implement types which also allow the use of the null literal"))];
}

function SR$$$tcGenericTypesCannotHaveStructLayout() {
  return [936, (0, _String.toText)((0, _String.printf)("Generic types cannot be given the 'StructLayout' attribute"))];
}

function SR$$$tcOnlyStructsCanHaveStructLayout() {
  return [937, (0, _String.toText)((0, _String.printf)("Only structs and classes without primary constructors may be given the 'StructLayout' attribute"))];
}

function SR$$$tcRepresentationOfTypeHiddenBySignature() {
  return [938, (0, _String.toText)((0, _String.printf)("The representation of this type is hidden by the signature. It must be given an attribute such as [<Sealed>], [<Class>] or [<Interface>] to indicate the characteristics of the type."))];
}

function SR$$$tcOnlyClassesCanHaveAbstract() {
  return [939, (0, _String.toText)((0, _String.printf)("Only classes may be given the 'AbstractClass' attribute"))];
}

function SR$$$tcOnlyTypesRepresentingUnitsOfMeasureCanHaveMeasure() {
  return [940, (0, _String.toText)((0, _String.printf)("Only types representing units-of-measure may be given the 'Measure' attribute"))];
}

function SR$$$tcOverridesCannotHaveVisibilityDeclarations() {
  return [941, (0, _String.toText)((0, _String.printf)("Accessibility modifiers are not permitted on overrides or interface implementations"))];
}

function SR$$$tcTypesAreAlwaysSealedDU() {
  return [942, (0, _String.toText)((0, _String.printf)("Discriminated union types are always sealed"))];
}

function SR$$$tcTypesAreAlwaysSealedRecord() {
  return [942, (0, _String.toText)((0, _String.printf)("Record types are always sealed"))];
}

function SR$$$tcTypesAreAlwaysSealedAssemblyCode() {
  return [942, (0, _String.toText)((0, _String.printf)("Assembly code types are always sealed"))];
}

function SR$$$tcTypesAreAlwaysSealedStruct() {
  return [942, (0, _String.toText)((0, _String.printf)("Struct types are always sealed"))];
}

function SR$$$tcTypesAreAlwaysSealedDelegate() {
  return [942, (0, _String.toText)((0, _String.printf)("Delegate types are always sealed"))];
}

function SR$$$tcTypesAreAlwaysSealedEnum() {
  return [942, (0, _String.toText)((0, _String.printf)("Enum types are always sealed"))];
}

function SR$$$tcInterfaceTypesAndDelegatesCannotContainFields() {
  return [943, (0, _String.toText)((0, _String.printf)("Interface types and delegate types cannot contain fields"))];
}

function SR$$$tcAbbreviatedTypesCannotBeSealed() {
  return [944, (0, _String.toText)((0, _String.printf)("Abbreviated types cannot be given the 'Sealed' attribute"))];
}

function SR$$$tcCannotInheritFromSealedType() {
  return [945, (0, _String.toText)((0, _String.printf)("Cannot inherit a sealed type"))];
}

function SR$$$tcCannotInheritFromInterfaceType() {
  return [946, (0, _String.toText)((0, _String.printf)("Cannot inherit from interface type. Use interface ... with instead."))];
}

function SR$$$tcStructTypesCannotContainAbstractMembers() {
  return [947, (0, _String.toText)((0, _String.printf)("Struct types cannot contain abstract members"))];
}

function SR$$$tcInterfaceTypesCannotBeSealed() {
  return [948, (0, _String.toText)((0, _String.printf)("Interface types cannot be sealed"))];
}

function SR$$$tcInvalidDelegateSpecification() {
  return [949, (0, _String.toText)((0, _String.printf)("Delegate specifications must be of the form 'typ -> typ'"))];
}

function SR$$$tcDelegatesCannotBeCurried() {
  return [950, (0, _String.toText)((0, _String.printf)("Delegate specifications must not be curried types. Use 'typ * ... * typ -> typ' for multi-argument delegates, and 'typ -> (typ -> typ)' for delegates returning function values."))];
}

function SR$$$tcInvalidTypeForLiteralEnumeration() {
  return [951, (0, _String.toText)((0, _String.printf)("Literal enumerations must have type int, uint, int16, uint16, int64, uint64, byte, sbyte or char"))];
}

function SR$$$tcTypeDefinitionIsCyclic() {
  return [953, (0, _String.toText)((0, _String.printf)("This type definition involves an immediate cyclic reference through an abbreviation"))];
}

function SR$$$tcTypeDefinitionIsCyclicThroughInheritance() {
  return [954, (0, _String.toText)((0, _String.printf)("This type definition involves an immediate cyclic reference through a struct field or inheritance relation"))];
}

function SR$$$tcReservedSyntaxForAugmentation() {
  return (0, _String.toText)((0, _String.printf)("The syntax 'type X with ...' is reserved for augmentations. Types whose representations are hidden but which have members are now declared in signatures using 'type X = ...'. You may also need to add the '[<Sealed>] attribute to the type definition in the signature"));
}

function SR$$$tcMembersThatExtendInterfaceMustBePlacedInSeparateModule() {
  return [956, (0, _String.toText)((0, _String.printf)("Members that extend interface, delegate or enum types must be placed in a module separate to the definition of the type. This module must either have the AutoOpen attribute or be opened explicitly by client code to bring the extension members into scope."))];
}

function SR$$$tcDeclaredTypeParametersForExtensionDoNotMatchOriginal$$Z721C83C5(a0$$301) {
  return [957, (0, _String.toText)((0, _String.printf)("One or more of the declared type parameters for this type extension have a missing or wrong type constraint not matching the original type constraints on '%s'"))(a0$$301)];
}

function SR$$$tcTypeDefinitionsWithImplicitConstructionMustHaveOneInherit() {
  return [959, (0, _String.toText)((0, _String.printf)("Type definitions may only have one 'inherit' specification and it must be the first declaration"))];
}

function SR$$$tcTypeDefinitionsWithImplicitConstructionMustHaveLocalBindingsBeforeMembers() {
  return [960, (0, _String.toText)((0, _String.printf)("'let' and 'do' bindings must come before member and interface definitions in type definitions"))];
}

function SR$$$tcInheritDeclarationMissingArguments() {
  return [961, (0, _String.toText)((0, _String.printf)("This 'inherit' declaration specifies the inherited type but no arguments. Consider supplying arguments, e.g. 'inherit BaseType(args)'."))];
}

function SR$$$tcInheritConstructionCallNotPartOfImplicitSequence() {
  return [962, (0, _String.toText)((0, _String.printf)("This 'inherit' declaration has arguments, but is not in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'."))];
}

function SR$$$tcLetAndDoRequiresImplicitConstructionSequence() {
  return [963, (0, _String.toText)((0, _String.printf)("This definition may only be used in a type with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'."))];
}

function SR$$$tcTypeAbbreviationsCannotHaveAugmentations() {
  return [964, (0, _String.toText)((0, _String.printf)("Type abbreviations cannot have augmentations"))];
}

function SR$$$tcModuleAbbreviationForNamespace$$Z721C83C5(a0$$302) {
  return [965, (0, _String.toText)((0, _String.printf)("The path '%s' is a namespace. A module abbreviation may not abbreviate a namespace."))(a0$$302)];
}

function SR$$$tcTypeUsedInInvalidWay$$30230F9B(a0$$303, a1$$150, a2$$62) {
  return [966, (0, _String.toText)((0, _String.printf)("The type '%s' is used in an invalid way. A value prior to '%s' has an inferred type involving '%s', which is an invalid forward reference."))(a0$$303)(a1$$150)(a2$$62)];
}

function SR$$$tcMemberUsedInInvalidWay$$30230F9B(a0$$304, a1$$151, a2$$63) {
  return [967, (0, _String.toText)((0, _String.printf)("The member '%s' is used in an invalid way. A use of '%s' has been inferred prior to the definition of '%s', which is an invalid forward reference."))(a0$$304)(a1$$151)(a2$$63)];
}

function SR$$$tcAttributeAutoOpenWasIgnored$$Z384F8060(a0$$305, a1$$152) {
  return [970, (0, _String.toText)((0, _String.printf)("The attribute 'AutoOpen(\"%s\")' in the assembly '%s' did not refer to a valid module or namespace in that assembly and has been ignored"))(a0$$305)(a1$$152)];
}

function SR$$$ilUndefinedValue$$Z721C83C5(a0$$306) {
  return [971, (0, _String.toText)((0, _String.printf)("Undefined value '%s'"))(a0$$306)];
}

function SR$$$ilLabelNotFound$$Z721C83C5(a0$$307) {
  return [972, (0, _String.toText)((0, _String.printf)("Label %s not found"))(a0$$307)];
}

function SR$$$ilIncorrectNumberOfTypeArguments() {
  return [973, (0, _String.toText)((0, _String.printf)("Incorrect number of type arguments to local call"))];
}

function SR$$$ilDynamicInvocationNotSupported$$Z721C83C5(a0$$308) {
  return (0, _String.toText)((0, _String.printf)("Dynamic invocation of %s is not supported"))(a0$$308);
}

function SR$$$ilAddressOfLiteralFieldIsInvalid() {
  return [975, (0, _String.toText)((0, _String.printf)("Taking the address of a literal field is invalid"))];
}

function SR$$$ilAddressOfValueHereIsInvalid$$Z721C83C5(a0$$309) {
  return [976, (0, _String.toText)((0, _String.printf)("This operation involves taking the address of a value '%s' represented using a local variable or other special representation. This is invalid."))(a0$$309)];
}

function SR$$$ilCustomMarshallersCannotBeUsedInFSharp() {
  return [980, (0, _String.toText)((0, _String.printf)("Custom marshallers cannot be specified in F# code. Consider using a C# helper function."))];
}

function SR$$$ilMarshalAsAttributeCannotBeDecoded() {
  return [981, (0, _String.toText)((0, _String.printf)("The MarshalAs attribute could not be decoded"))];
}

function SR$$$ilSignatureForExternalFunctionContainsTypeParameters() {
  return [982, (0, _String.toText)((0, _String.printf)("The signature for this external function contains type parameters. Constrain the argument and return types to indicate the types of the corresponding C function."))];
}

function SR$$$ilDllImportAttributeCouldNotBeDecoded() {
  return [983, (0, _String.toText)((0, _String.printf)("The DllImport attribute could not be decoded"))];
}

function SR$$$ilLiteralFieldsCannotBeSet() {
  return [984, (0, _String.toText)((0, _String.printf)("Literal fields cannot be set"))];
}

function SR$$$ilStaticMethodIsNotLambda$$Z721C83C5(a0$$310) {
  return [985, (0, _String.toText)((0, _String.printf)("GenSetStorage: %s was represented as a static method but was not an appropriate lambda expression"))(a0$$310)];
}

function SR$$$ilMutableVariablesCannotEscapeMethod() {
  return [986, (0, _String.toText)((0, _String.printf)("Mutable variables cannot escape their method"))];
}

function SR$$$ilUnexpectedUnrealizedValue() {
  return [987, (0, _String.toText)((0, _String.printf)("Compiler error: unexpected unrealized value"))];
}

function SR$$$ilMainModuleEmpty() {
  return [988, (0, _String.toText)((0, _String.printf)("Main module of program is empty: nothing will happen when it is run"))];
}

function SR$$$ilTypeCannotBeUsedForLiteralField() {
  return [989, (0, _String.toText)((0, _String.printf)("This type cannot be used for a literal field"))];
}

function SR$$$ilUnexpectedGetSetAnnotation() {
  return [990, (0, _String.toText)((0, _String.printf)("Unexpected GetSet annotation on a property"))];
}

function SR$$$ilFieldOffsetAttributeCouldNotBeDecoded() {
  return [991, (0, _String.toText)((0, _String.printf)("The FieldOffset attribute could not be decoded"))];
}

function SR$$$ilStructLayoutAttributeCouldNotBeDecoded() {
  return [992, (0, _String.toText)((0, _String.printf)("The StructLayout attribute could not be decoded"))];
}

function SR$$$ilDefaultAugmentationAttributeCouldNotBeDecoded() {
  return [993, (0, _String.toText)((0, _String.printf)("The DefaultAugmentation attribute could not be decoded"))];
}

function SR$$$ilReflectedDefinitionsCannotUseSliceOperator() {
  return [994, (0, _String.toText)((0, _String.printf)("Reflected definitions cannot contain uses of the prefix splice operator '%%'"))];
}

function SR$$$optsProblemWithCodepage$$Z176EF219(a0$$311, a1$$153) {
  return [1000, (0, _String.toText)((0, _String.printf)("Problem with codepage '%d': %s"))(a0$$311)(a1$$153)];
}

function SR$$$optsCopyright() {
  return (0, _String.toText)((0, _String.printf)("Copyright (c) Microsoft Corporation. All Rights Reserved."));
}

function SR$$$optsCopyrightCommunity() {
  return (0, _String.toText)((0, _String.printf)("Freely distributed under the MIT Open Source License.  https://github.com/Microsoft/visualfsharp/blob/master/License.txt"));
}

function SR$$$optsNameOfOutputFile() {
  return (0, _String.toText)((0, _String.printf)("Name of the output file (Short form: -o)"));
}

function SR$$$optsBuildConsole() {
  return (0, _String.toText)((0, _String.printf)("Build a console executable"));
}

function SR$$$optsBuildWindows() {
  return (0, _String.toText)((0, _String.printf)("Build a Windows executable"));
}

function SR$$$optsBuildLibrary() {
  return (0, _String.toText)((0, _String.printf)("Build a library (Short form: -a)"));
}

function SR$$$optsBuildModule() {
  return (0, _String.toText)((0, _String.printf)("Build a module that can be added to another assembly"));
}

function SR$$$optsDelaySign() {
  return (0, _String.toText)((0, _String.printf)("Delay-sign the assembly using only the public portion of the strong name key"));
}

function SR$$$optsPublicSign() {
  return (0, _String.toText)((0, _String.printf)("Public-sign the assembly using only the public portion of the strong name key, and mark the assembly as signed"));
}

function SR$$$optsWriteXml() {
  return (0, _String.toText)((0, _String.printf)("Write the xmldoc of the assembly to the given file"));
}

function SR$$$optsStrongKeyFile() {
  return (0, _String.toText)((0, _String.printf)("Specify a strong name key file"));
}

function SR$$$optsStrongKeyContainer() {
  return (0, _String.toText)((0, _String.printf)("Specify a strong name key container"));
}

function SR$$$optsPlatform() {
  return (0, _String.toText)((0, _String.printf)("Limit which platforms this code can run on: x86, Itanium, x64, anycpu32bitpreferred, or anycpu. The default is anycpu."));
}

function SR$$$optsNoOpt() {
  return (0, _String.toText)((0, _String.printf)("Only include optimization information essential for implementing inlined constructs. Inhibits cross-module inlining but improves binary compatibility."));
}

function SR$$$optsNoInterface() {
  return (0, _String.toText)((0, _String.printf)("Don't add a resource to the generated assembly containing F#-specific metadata"));
}

function SR$$$optsSig() {
  return (0, _String.toText)((0, _String.printf)("Print the inferred interface of the assembly to a file"));
}

function SR$$$optsReference() {
  return (0, _String.toText)((0, _String.printf)("Reference an assembly (Short form: -r)"));
}

function SR$$$optsWin32res() {
  return (0, _String.toText)((0, _String.printf)("Specify a Win32 resource file (.res)"));
}

function SR$$$optsWin32manifest() {
  return (0, _String.toText)((0, _String.printf)("Specify a Win32 manifest file"));
}

function SR$$$optsNowin32manifest() {
  return (0, _String.toText)((0, _String.printf)("Do not include the default Win32 manifest"));
}

function SR$$$optsEmbedAllSource() {
  return (0, _String.toText)((0, _String.printf)("Embed all source files in the portable PDB file"));
}

function SR$$$optsEmbedSource() {
  return (0, _String.toText)((0, _String.printf)("Embed specific source files in the portable PDB file"));
}

function SR$$$optsSourceLink() {
  return (0, _String.toText)((0, _String.printf)("Source link information file to embed in the portable PDB file"));
}

function SR$$$optsEmbeddedSourceRequirePortablePDBs() {
  return [1501, (0, _String.toText)((0, _String.printf)("--embed switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)"))];
}

function SR$$$optsSourceLinkRequirePortablePDBs() {
  return [1502, (0, _String.toText)((0, _String.printf)("--sourcelink switch only supported when emitting a Portable PDB (--debug:portable or --debug:embedded)"))];
}

function SR$$$srcFileTooLarge() {
  return (0, _String.toText)((0, _String.printf)("Source file is too large to embed in a portable PDB"));
}

function SR$$$optsResource() {
  return (0, _String.toText)((0, _String.printf)("Embed the specified managed resource"));
}

function SR$$$optsLinkresource() {
  return (0, _String.toText)((0, _String.printf)("Link the specified resource to this assembly where the resinfo format is <file>[,<string name>[,public|private]]"));
}

function SR$$$optsDebugPM() {
  return (0, _String.toText)((0, _String.printf)("Emit debug information (Short form: -g)"));
}

function SR$$$optsDebug$$Z721C83C5(a0$$312) {
  return (0, _String.toText)((0, _String.printf)("Specify debugging type: full, portable, embedded, pdbonly. ('%s' is the default if no debuggging type specified and enables attaching a debugger to a running program, 'portable' is a cross-platform format, 'embedded' is a cross-platform format embedded into the output file)."))(a0$$312);
}

function SR$$$optsOptimize() {
  return (0, _String.toText)((0, _String.printf)("Enable optimizations (Short form: -O)"));
}

function SR$$$optsTailcalls() {
  return (0, _String.toText)((0, _String.printf)("Enable or disable tailcalls"));
}

function SR$$$optsDeterministic() {
  return (0, _String.toText)((0, _String.printf)("Produce a deterministic assembly (including module version GUID and timestamp)"));
}

function SR$$$optsCrossoptimize() {
  return (0, _String.toText)((0, _String.printf)("Enable or disable cross-module optimizations"));
}

function SR$$$optsWarnaserrorPM() {
  return (0, _String.toText)((0, _String.printf)("Report all warnings as errors"));
}

function SR$$$optsWarnaserror() {
  return (0, _String.toText)((0, _String.printf)("Report specific warnings as errors"));
}

function SR$$$optsWarn() {
  return (0, _String.toText)((0, _String.printf)("Set a warning level (0-5)"));
}

function SR$$$optsNowarn() {
  return (0, _String.toText)((0, _String.printf)("Disable specific warning messages"));
}

function SR$$$optsWarnOn() {
  return (0, _String.toText)((0, _String.printf)("Enable specific warnings that may be off by default"));
}

function SR$$$optsChecked() {
  return (0, _String.toText)((0, _String.printf)("Generate overflow checks"));
}

function SR$$$optsDefine() {
  return (0, _String.toText)((0, _String.printf)("Define conditional compilation symbols (Short form: -d)"));
}

function SR$$$optsMlcompatibility() {
  return (0, _String.toText)((0, _String.printf)("Ignore ML compatibility warnings"));
}

function SR$$$optsNologo() {
  return (0, _String.toText)((0, _String.printf)("Suppress compiler copyright message"));
}

function SR$$$optsHelp() {
  return (0, _String.toText)((0, _String.printf)("Display this usage message (Short form: -?)"));
}

function SR$$$optsResponseFile() {
  return (0, _String.toText)((0, _String.printf)("Read response file for more options"));
}

function SR$$$optsCodepage() {
  return (0, _String.toText)((0, _String.printf)("Specify the codepage used to read source files"));
}

function SR$$$optsUtf8output() {
  return (0, _String.toText)((0, _String.printf)("Output messages in UTF-8 encoding"));
}

function SR$$$optsFullpaths() {
  return (0, _String.toText)((0, _String.printf)("Output messages with fully qualified paths"));
}

function SR$$$optsLib() {
  return (0, _String.toText)((0, _String.printf)("Specify a directory for the include path which is used to resolve source files and assemblies (Short form: -I)"));
}

function SR$$$optsBaseaddress() {
  return (0, _String.toText)((0, _String.printf)("Base address for the library to be built"));
}

function SR$$$optsNoframework() {
  return (0, _String.toText)((0, _String.printf)("Do not reference the default CLI assemblies by default"));
}

function SR$$$optsStandalone() {
  return (0, _String.toText)((0, _String.printf)("Statically link the F# library and all referenced DLLs that depend on it into the assembly being generated"));
}

function SR$$$optsStaticlink() {
  return (0, _String.toText)((0, _String.printf)("Statically link the given assembly and all referenced DLLs that depend on this assembly. Use an assembly name e.g. mylib, not a DLL name."));
}

function SR$$$optsResident() {
  return (0, _String.toText)((0, _String.printf)("Use a resident background compilation service to improve compiler startup times."));
}

function SR$$$optsPdb() {
  return (0, _String.toText)((0, _String.printf)("Name the output debug file"));
}

function SR$$$optsSimpleresolution() {
  return (0, _String.toText)((0, _String.printf)("Resolve assembly references using directory-based rules rather than MSBuild resolution"));
}

function SR$$$optsUnrecognizedTarget$$Z721C83C5(a0$$313) {
  return [1048, (0, _String.toText)((0, _String.printf)("Unrecognized target '%s', expected 'exe', 'winexe', 'library' or 'module'"))(a0$$313)];
}

function SR$$$optsUnrecognizedDebugType$$Z721C83C5(a0$$314) {
  return [1049, (0, _String.toText)((0, _String.printf)("Unrecognized debug type '%s', expected 'pdbonly' or 'full'"))(a0$$314)];
}

function SR$$$optsInvalidWarningLevel$$Z524259A4(a0$$315) {
  return [1050, (0, _String.toText)((0, _String.printf)("Invalid warning level '%d'"))(a0$$315)];
}

function SR$$$optsShortFormOf$$Z721C83C5(a0$$316) {
  return (0, _String.toText)((0, _String.printf)("Short form of '%s'"))(a0$$316);
}

function SR$$$optsClirootDeprecatedMsg() {
  return (0, _String.toText)((0, _String.printf)("The command-line option '--cliroot' has been deprecated. Use an explicit reference to a specific copy of mscorlib.dll instead."));
}

function SR$$$optsClirootDescription() {
  return (0, _String.toText)((0, _String.printf)("Use to override where the compiler looks for mscorlib.dll and framework components"));
}

function SR$$$optsHelpBannerOutputFiles() {
  return (0, _String.toText)((0, _String.printf)("- OUTPUT FILES -"));
}

function SR$$$optsHelpBannerInputFiles() {
  return (0, _String.toText)((0, _String.printf)("- INPUT FILES -"));
}

function SR$$$optsHelpBannerResources() {
  return (0, _String.toText)((0, _String.printf)("- RESOURCES -"));
}

function SR$$$optsHelpBannerCodeGen() {
  return (0, _String.toText)((0, _String.printf)("- CODE GENERATION -"));
}

function SR$$$optsHelpBannerAdvanced() {
  return (0, _String.toText)((0, _String.printf)("- ADVANCED -"));
}

function SR$$$optsHelpBannerMisc() {
  return (0, _String.toText)((0, _String.printf)("- MISCELLANEOUS -"));
}

function SR$$$optsHelpBannerLanguage() {
  return (0, _String.toText)((0, _String.printf)("- LANGUAGE -"));
}

function SR$$$optsHelpBannerErrsAndWarns() {
  return (0, _String.toText)((0, _String.printf)("- ERRORS AND WARNINGS -"));
}

function SR$$$optsUnknownArgumentToTheTestSwitch$$Z721C83C5(a0$$317) {
  return [1063, (0, _String.toText)((0, _String.printf)("Unknown --test argument: '%s'"))(a0$$317)];
}

function SR$$$optsUnknownPlatform$$Z721C83C5(a0$$318) {
  return [1064, (0, _String.toText)((0, _String.printf)("Unrecognized platform '%s', valid values are 'x86', 'x64', 'Itanium', 'anycpu32bitpreferred', and 'anycpu'"))(a0$$318)];
}

function SR$$$optsInternalNoDescription$$Z721C83C5(a0$$319) {
  return (0, _String.toText)((0, _String.printf)("The command-line option '%s' is for test purposes only"))(a0$$319);
}

function SR$$$optsDCLONoDescription$$Z721C83C5(a0$$320) {
  return (0, _String.toText)((0, _String.printf)("The command-line option '%s' has been deprecated"))(a0$$320);
}

function SR$$$optsDCLODeprecatedSuggestAlternative$$Z384F8060(a0$$321, a1$$154) {
  return (0, _String.toText)((0, _String.printf)("The command-line option '%s' has been deprecated. Use '%s' instead."))(a0$$321)(a1$$154);
}

function SR$$$optsDCLOHtmlDoc$$Z721C83C5(a0$$322) {
  return (0, _String.toText)((0, _String.printf)("The command-line option '%s' has been deprecated. HTML document generation is now part of the F# Power Pack, via the tool FsHtmlDoc.exe."))(a0$$322);
}

function SR$$$optsConsoleColors() {
  return (0, _String.toText)((0, _String.printf)("Output warning and error messages in color"));
}

function SR$$$optsUseHighEntropyVA() {
  return (0, _String.toText)((0, _String.printf)("Enable high-entropy ASLR"));
}

function SR$$$optsSubSystemVersion() {
  return (0, _String.toText)((0, _String.printf)("Specify subsystem version of this assembly"));
}

function SR$$$optsTargetProfile() {
  return (0, _String.toText)((0, _String.printf)("Specify target framework profile of this assembly. Valid values are mscorlib, netcore or netstandard. Default - mscorlib"));
}

function SR$$$optsEmitDebugInfoInQuotations() {
  return (0, _String.toText)((0, _String.printf)("Emit debug information in quotations"));
}

function SR$$$optsPreferredUiLang() {
  return (0, _String.toText)((0, _String.printf)("Specify the preferred output language culture name (e.g. es-ES, ja-JP)"));
}

function SR$$$optsNoCopyFsharpCore() {
  return (0, _String.toText)((0, _String.printf)("Don't copy FSharp.Core.dll along the produced binaries"));
}

function SR$$$optsInvalidSubSystemVersion$$Z721C83C5(a0$$323) {
  return [1051, (0, _String.toText)((0, _String.printf)("Invalid version '%s' for '--subsystemversion'. The version must be 4.00 or greater."))(a0$$323)];
}

function SR$$$optsInvalidTargetProfile$$Z721C83C5(a0$$324) {
  return [1052, (0, _String.toText)((0, _String.printf)("Invalid value '%s' for '--targetprofile', valid values are 'mscorlib', 'netcore' or 'netstandard'."))(a0$$324)];
}

function SR$$$typeInfoFullName() {
  return (0, _String.toText)((0, _String.printf)("Full name"));
}

function SR$$$typeInfoOtherOverloads$$Z524259A4(a0$$325) {
  return (0, _String.toText)((0, _String.printf)("and %d other overloads"))(a0$$325);
}

function SR$$$typeInfoUnionCase() {
  return (0, _String.toText)((0, _String.printf)("union case"));
}

function SR$$$typeInfoActivePatternResult() {
  return (0, _String.toText)((0, _String.printf)("active pattern result"));
}

function SR$$$typeInfoActiveRecognizer() {
  return (0, _String.toText)((0, _String.printf)("active recognizer"));
}

function SR$$$typeInfoField() {
  return (0, _String.toText)((0, _String.printf)("field"));
}

function SR$$$typeInfoEvent() {
  return (0, _String.toText)((0, _String.printf)("event"));
}

function SR$$$typeInfoProperty() {
  return (0, _String.toText)((0, _String.printf)("property"));
}

function SR$$$typeInfoExtension() {
  return (0, _String.toText)((0, _String.printf)("extension"));
}

function SR$$$typeInfoCustomOperation() {
  return (0, _String.toText)((0, _String.printf)("custom operation"));
}

function SR$$$typeInfoArgument() {
  return (0, _String.toText)((0, _String.printf)("argument"));
}

function SR$$$typeInfoPatternVariable() {
  return (0, _String.toText)((0, _String.printf)("patvar"));
}

function SR$$$typeInfoNamespace() {
  return (0, _String.toText)((0, _String.printf)("namespace"));
}

function SR$$$typeInfoModule() {
  return (0, _String.toText)((0, _String.printf)("module"));
}

function SR$$$typeInfoNamespaceOrModule() {
  return (0, _String.toText)((0, _String.printf)("namespace/module"));
}

function SR$$$typeInfoFromFirst$$Z721C83C5(a0$$326) {
  return (0, _String.toText)((0, _String.printf)("from %s"))(a0$$326);
}

function SR$$$typeInfoFromNext$$Z721C83C5(a0$$327) {
  return (0, _String.toText)((0, _String.printf)("also from %s"))(a0$$327);
}

function SR$$$typeInfoGeneratedProperty() {
  return (0, _String.toText)((0, _String.printf)("generated property"));
}

function SR$$$typeInfoGeneratedType() {
  return (0, _String.toText)((0, _String.printf)("generated type"));
}

function SR$$$assemblyResolutionFoundByAssemblyFoldersKey() {
  return (0, _String.toText)((0, _String.printf)("Found by AssemblyFolders registry key"));
}

function SR$$$assemblyResolutionFoundByAssemblyFoldersExKey() {
  return (0, _String.toText)((0, _String.printf)("Found by AssemblyFoldersEx registry key"));
}

function SR$$$assemblyResolutionNetFramework() {
  return (0, _String.toText)((0, _String.printf)(".NET Framework"));
}

function SR$$$assemblyResolutionGAC() {
  return (0, _String.toText)((0, _String.printf)("Global Assembly Cache"));
}

function SR$$$recursiveClassHierarchy$$Z721C83C5(a0$$328) {
  return [1089, (0, _String.toText)((0, _String.printf)("Recursive class hierarchy in type '%s'"))(a0$$328)];
}

function SR$$$InvalidRecursiveReferenceToAbstractSlot() {
  return [1090, (0, _String.toText)((0, _String.printf)("Invalid recursive reference to an abstract slot"))];
}

function SR$$$eventHasNonStandardType$$30230F9B(a0$$329, a1$$155, a2$$64) {
  return [1091, (0, _String.toText)((0, _String.printf)("The event '%s' has a non-standard type. If this event is declared in another CLI language, you may need to access this event using the explicit %s and %s methods for the event. If this event is declared in F#, make the type of the event an instantiation of either 'IDelegateEvent<_>' or 'IEvent<_,_>'."))(a0$$329)(a1$$155)(a2$$64)];
}

function SR$$$typeIsNotAccessible$$Z721C83C5(a0$$330) {
  return [1092, (0, _String.toText)((0, _String.printf)("The type '%s' is not accessible from this code location"))(a0$$330)];
}

function SR$$$unionCasesAreNotAccessible$$Z721C83C5(a0$$331) {
  return [1093, (0, _String.toText)((0, _String.printf)("The union cases or fields of the type '%s' are not accessible from this code location"))(a0$$331)];
}

function SR$$$valueIsNotAccessible$$Z721C83C5(a0$$332) {
  return [1094, (0, _String.toText)((0, _String.printf)("The value '%s' is not accessible from this code location"))(a0$$332)];
}

function SR$$$unionCaseIsNotAccessible$$Z721C83C5(a0$$333) {
  return [1095, (0, _String.toText)((0, _String.printf)("The union case '%s' is not accessible from this code location"))(a0$$333)];
}

function SR$$$fieldIsNotAccessible$$Z721C83C5(a0$$334) {
  return [1096, (0, _String.toText)((0, _String.printf)("The record, struct or class field '%s' is not accessible from this code location"))(a0$$334)];
}

function SR$$$structOrClassFieldIsNotAccessible$$Z721C83C5(a0$$335) {
  return [1097, (0, _String.toText)((0, _String.printf)("The struct or class field '%s' is not accessible from this code location"))(a0$$335)];
}

function SR$$$experimentalConstruct() {
  return (0, _String.toText)((0, _String.printf)("This construct is experimental"));
}

function SR$$$noInvokeMethodsFound() {
  return [1099, (0, _String.toText)((0, _String.printf)("No Invoke methods found for delegate type"))];
}

function SR$$$moreThanOneInvokeMethodFound() {
  return (0, _String.toText)((0, _String.printf)("More than one Invoke method found for delegate type"));
}

function SR$$$delegatesNotAllowedToHaveCurriedSignatures() {
  return [1101, (0, _String.toText)((0, _String.printf)("Delegates are not allowed to have curried signatures"))];
}

function SR$$$tlrUnexpectedTExpr() {
  return [1102, (0, _String.toText)((0, _String.printf)("Unexpected Expr.TyChoose"))];
}

function SR$$$tlrLambdaLiftingOptimizationsNotApplied() {
  return [1103, (0, _String.toText)((0, _String.printf)("Note: Lambda-lifting optimizations have not been applied because of the use of this local constrained generic function as a first class value. Adding type constraints may resolve this condition."))];
}

function SR$$$lexhlpIdentifiersContainingAtSymbolReserved() {
  return [1104, (0, _String.toText)((0, _String.printf)("Identifiers containing '@' are reserved for use in F# code generation"))];
}

function SR$$$lexhlpIdentifierReserved$$Z721C83C5(a0$$336) {
  return (0, _String.toText)((0, _String.printf)("The identifier '%s' is reserved for future use by F#"))(a0$$336);
}

function SR$$$patcMissingVariable$$Z721C83C5(a0$$337) {
  return [1106, (0, _String.toText)((0, _String.printf)("Missing variable '%s'"))(a0$$337)];
}

function SR$$$patcPartialActivePatternsGenerateOneResult() {
  return [1107, (0, _String.toText)((0, _String.printf)("Partial active patterns may only generate one result"))];
}

function SR$$$impTypeRequiredUnavailable$$Z384F8060(a0$$338, a1$$156) {
  return [1108, (0, _String.toText)((0, _String.printf)("The type '%s' is required here and is unavailable. You must add a reference to assembly '%s'."))(a0$$338)(a1$$156)];
}

function SR$$$impReferencedTypeCouldNotBeFoundInAssembly$$Z384F8060(a0$$339, a1$$157) {
  return [1109, (0, _String.toText)((0, _String.printf)("A reference to the type '%s' in assembly '%s' was found, but the type could not be found in that assembly"))(a0$$339)(a1$$157)];
}

function SR$$$impNotEnoughTypeParamsInScopeWhileImporting() {
  return [1110, (0, _String.toText)((0, _String.printf)("Internal error or badly formed metadata: not enough type parameters were in scope while importing"))];
}

function SR$$$impReferenceToDllRequiredByAssembly$$30230F9B(a0$$340, a1$$158, a2$$65) {
  return [1111, (0, _String.toText)((0, _String.printf)("A reference to the DLL %s is required by assembly %s. The imported type %s is located in the first assembly and could not be resolved."))(a0$$340)(a1$$158)(a2$$65)];
}

function SR$$$impImportedAssemblyUsesNotPublicType$$Z721C83C5(a0$$341) {
  return [1112, (0, _String.toText)((0, _String.printf)("An imported assembly uses the type '%s' but that type is not public"))(a0$$341)];
}

function SR$$$optValueMarkedInlineButIncomplete$$Z721C83C5(a0$$342) {
  return [1113, (0, _String.toText)((0, _String.printf)("The value '%s' was marked inline but its implementation makes use of an internal or private function which is not sufficiently accessible"))(a0$$342)];
}

function SR$$$optValueMarkedInlineButWasNotBoundInTheOptEnv$$Z721C83C5(a0$$343) {
  return [1114, (0, _String.toText)((0, _String.printf)("The value '%s' was marked inline but was not bound in the optimization environment"))(a0$$343)];
}

function SR$$$optLocalValueNotFoundDuringOptimization$$Z721C83C5(a0$$344) {
  return [1115, (0, _String.toText)((0, _String.printf)("Local value %s not found during optimization"))(a0$$344)];
}

function SR$$$optValueMarkedInlineHasUnexpectedValue() {
  return [1116, (0, _String.toText)((0, _String.printf)("A value marked as 'inline' has an unexpected value"))];
}

function SR$$$optValueMarkedInlineCouldNotBeInlined() {
  return [1117, (0, _String.toText)((0, _String.printf)("A value marked as 'inline' could not be inlined"))];
}

function SR$$$optFailedToInlineValue$$Z721C83C5(a0$$345) {
  return [1118, (0, _String.toText)((0, _String.printf)("Failed to inline the value '%s' marked 'inline', perhaps because a recursive value was marked 'inline'"))(a0$$345)];
}

function SR$$$optRecursiveValValue$$Z721C83C5(a0$$346) {
  return [1119, (0, _String.toText)((0, _String.printf)("Recursive ValValue %s"))(a0$$346)];
}

function SR$$$lexfltIncorrentIndentationOfIn() {
  return (0, _String.toText)((0, _String.printf)("The indentation of this 'in' token is incorrect with respect to the corresponding 'let'"));
}

function SR$$$lexfltTokenIsOffsideOfContextStartedEarlier$$Z721C83C5(a0$$347) {
  return (0, _String.toText)((0, _String.printf)("Possible incorrect indentation: this token is offside of context started at position %s. Try indenting this token further or using standard formatting conventions."))(a0$$347);
}

function SR$$$lexfltSeparatorTokensOfPatternMatchMisaligned() {
  return (0, _String.toText)((0, _String.printf)("The '|' tokens separating rules of this pattern match are misaligned by one column. Consider realigning your code or using further indentation."));
}

function SR$$$nrInvalidModuleExprType() {
  return [1123, (0, _String.toText)((0, _String.printf)("Invalid module/expression/type"))];
}

function SR$$$nrTypeInstantiationNeededToDisambiguateTypesWithSameName$$Z384F8060(a0$$348, a1$$159) {
  return [1124, (0, _String.toText)((0, _String.printf)("Multiple types exist called '%s', taking different numbers of generic parameters. Provide a type instantiation to disambiguate the type resolution, e.g. '%s'."))(a0$$348)(a1$$159)];
}

function SR$$$nrTypeInstantiationIsMissingAndCouldNotBeInferred$$Z384F8060(a0$$349, a1$$160) {
  return [1125, (0, _String.toText)((0, _String.printf)("The instantiation of the generic type '%s' is missing and can't be inferred from the arguments or return type of this member. Consider providing a type instantiation when accessing this type, e.g. '%s'."))(a0$$349)(a1$$160)];
}

function SR$$$nrGlobalUsedOnlyAsFirstName() {
  return [1126, (0, _String.toText)((0, _String.printf)("'global' may only be used as the first name in a qualified path"))];
}

function SR$$$nrIsNotConstructorOrLiteral() {
  return [1127, (0, _String.toText)((0, _String.printf)("This is not a constructor or literal, or a constructor is being used incorrectly"))];
}

function SR$$$nrUnexpectedEmptyLongId() {
  return [1128, (0, _String.toText)((0, _String.printf)("Unexpected empty long identifier"))];
}

function SR$$$nrRecordDoesNotContainSuchLabel$$Z384F8060(a0$$350, a1$$161) {
  return [1129, (0, _String.toText)((0, _String.printf)("The record type '%s' does not contain a label '%s'."))(a0$$350)(a1$$161)];
}

function SR$$$nrInvalidFieldLabel() {
  return [1130, (0, _String.toText)((0, _String.printf)("Invalid field label"))];
}

function SR$$$nrInvalidExpression$$Z721C83C5(a0$$351) {
  return [1132, (0, _String.toText)((0, _String.printf)("Invalid expression '%s'"))(a0$$351)];
}

function SR$$$nrNoConstructorsAvailableForType$$Z721C83C5(a0$$352) {
  return [1133, (0, _String.toText)((0, _String.printf)("No constructors are available for the type '%s'"))(a0$$352)];
}

function SR$$$nrUnionTypeNeedsQualifiedAccess$$Z384F8060(a0$$353, a1$$162) {
  return [1134, (0, _String.toText)((0, _String.printf)("The union type for union case '%s' was defined with the RequireQualifiedAccessAttribute. Include the name of the union type ('%s') in the name you are using."))(a0$$353)(a1$$162)];
}

function SR$$$nrRecordTypeNeedsQualifiedAccess$$Z384F8060(a0$$354, a1$$163) {
  return [1135, (0, _String.toText)((0, _String.printf)("The record type for the record field '%s' was defined with the RequireQualifiedAccessAttribute. Include the name of the record type ('%s') in the name you are using."))(a0$$354)(a1$$163)];
}

function SR$$$ilwriteErrorCreatingPdb$$Z721C83C5(a0$$355) {
  return [1136, (0, _String.toText)((0, _String.printf)("Unexpected error creating debug information file '%s'"))(a0$$355)];
}

function SR$$$lexOutsideIntegerRange() {
  return [1138, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for this integer type"))];
}

function SR$$$lexCharNotAllowedInOperatorNames$$Z721C83C5(a0$$356) {
  return (0, _String.toText)((0, _String.printf)("'%s' is not permitted as a character in operator names and is reserved for future use"))(a0$$356);
}

function SR$$$lexUnexpectedChar$$Z721C83C5(a0$$357) {
  return (0, _String.toText)((0, _String.printf)("Unexpected character '%s'"))(a0$$357);
}

function SR$$$lexByteArrayCannotEncode() {
  return [1140, (0, _String.toText)((0, _String.printf)("This byte array literal contains characters that do not encode as a single byte"))];
}

function SR$$$lexIdentEndInMarkReserved$$Z721C83C5(a0$$358) {
  return [1141, (0, _String.toText)((0, _String.printf)("Identifiers followed by '%s' are reserved for future use"))(a0$$358)];
}

function SR$$$lexOutsideEightBitSigned() {
  return [1142, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for 8-bit signed integers"))];
}

function SR$$$lexOutsideEightBitSignedHex() {
  return [1143, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for hexadecimal 8-bit signed integers"))];
}

function SR$$$lexOutsideEightBitUnsigned() {
  return [1144, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for 8-bit unsigned integers"))];
}

function SR$$$lexOutsideSixteenBitSigned() {
  return [1145, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for 16-bit signed integers"))];
}

function SR$$$lexOutsideSixteenBitUnsigned() {
  return [1146, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for 16-bit unsigned integers"))];
}

function SR$$$lexOutsideThirtyTwoBitSigned() {
  return [1147, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for 32-bit signed integers"))];
}

function SR$$$lexOutsideThirtyTwoBitUnsigned() {
  return [1148, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for 32-bit unsigned integers"))];
}

function SR$$$lexOutsideSixtyFourBitSigned() {
  return [1149, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for 64-bit signed integers"))];
}

function SR$$$lexOutsideSixtyFourBitUnsigned() {
  return [1150, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for 64-bit unsigned integers"))];
}

function SR$$$lexOutsideNativeSigned() {
  return [1151, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for signed native integers"))];
}

function SR$$$lexOutsideNativeUnsigned() {
  return [1152, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for unsigned native integers"))];
}

function SR$$$lexInvalidFloat() {
  return [1153, (0, _String.toText)((0, _String.printf)("Invalid floating point number"))];
}

function SR$$$lexOusideDecimal() {
  return [1154, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for decimal literals"))];
}

function SR$$$lexOusideThirtyTwoBitFloat() {
  return [1155, (0, _String.toText)((0, _String.printf)("This number is outside the allowable range for 32-bit floats"))];
}

function SR$$$lexInvalidNumericLiteral() {
  return [1156, (0, _String.toText)((0, _String.printf)("This is not a valid numeric literal. Valid numeric literals include 1, 0x1, 0b0001 (int), 1u (uint32), 1L (int64), 1UL (uint64), 1s (int16), 1y (sbyte), 1uy (byte), 1.0 (float), 1.0f (float32), 1.0m (decimal), 1I (BigInteger)."))];
}

function SR$$$lexInvalidByteLiteral() {
  return [1157, (0, _String.toText)((0, _String.printf)("This is not a valid byte literal"))];
}

function SR$$$lexInvalidCharLiteral() {
  return [1158, (0, _String.toText)((0, _String.printf)("This is not a valid character literal"))];
}

function SR$$$lexThisUnicodeOnlyInStringLiterals() {
  return [1159, (0, _String.toText)((0, _String.printf)("This Unicode encoding is only valid in string literals"))];
}

function SR$$$lexTokenReserved() {
  return [1160, (0, _String.toText)((0, _String.printf)("This token is reserved for future use"))];
}

function SR$$$lexTabsNotAllowed() {
  return [1161, (0, _String.toText)((0, _String.printf)("TABs are not allowed in F# code unless the #indent \"off\" option is used"))];
}

function SR$$$lexInvalidLineNumber$$Z721C83C5(a0$$359) {
  return [1162, (0, _String.toText)((0, _String.printf)("Invalid line number: '%s'"))(a0$$359)];
}

function SR$$$lexHashIfMustBeFirst() {
  return [1163, (0, _String.toText)((0, _String.printf)("#if directive must appear as the first non-whitespace character on a line"))];
}

function SR$$$lexHashElseNoMatchingIf() {
  return (0, _String.toText)((0, _String.printf)("#else has no matching #if"));
}

function SR$$$lexHashEndifRequiredForElse() {
  return (0, _String.toText)((0, _String.printf)("#endif required for #else"));
}

function SR$$$lexHashElseMustBeFirst() {
  return [1166, (0, _String.toText)((0, _String.printf)("#else directive must appear as the first non-whitespace character on a line"))];
}

function SR$$$lexHashEndingNoMatchingIf() {
  return (0, _String.toText)((0, _String.printf)("#endif has no matching #if"));
}

function SR$$$lexHashEndifMustBeFirst() {
  return [1168, (0, _String.toText)((0, _String.printf)("#endif directive must appear as the first non-whitespace character on a line"))];
}

function SR$$$lexHashIfMustHaveIdent() {
  return [1169, (0, _String.toText)((0, _String.printf)("#if directive should be immediately followed by an identifier"))];
}

function SR$$$lexWrongNestedHashEndif() {
  return [1170, (0, _String.toText)((0, _String.printf)("Syntax error. Wrong nested #endif, unexpected tokens before it."))];
}

function SR$$$lexHashBangMustBeFirstInFile() {
  return (0, _String.toText)((0, _String.printf)("#! may only appear as the first line at the start of a file."));
}

function SR$$$pplexExpectedSingleLineComment() {
  return [1171, (0, _String.toText)((0, _String.printf)("Expected single line comment or end of line"))];
}

function SR$$$memberOperatorDefinitionWithNoArguments$$Z721C83C5(a0$$360) {
  return [1172, (0, _String.toText)((0, _String.printf)("Infix operator member '%s' has no arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ..."))(a0$$360)];
}

function SR$$$memberOperatorDefinitionWithNonPairArgument$$Z18115A39(a0$$361, a1$$164) {
  return [1173, (0, _String.toText)((0, _String.printf)("Infix operator member '%s' has %d initial argument(s). Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ..."))(a0$$361)(a1$$164)];
}

function SR$$$memberOperatorDefinitionWithCurriedArguments$$Z721C83C5(a0$$362) {
  return [1174, (0, _String.toText)((0, _String.printf)("Infix operator member '%s' has extra curried arguments. Expected a tuple of 2 arguments, e.g. static member (+) (x,y) = ..."))(a0$$362)];
}

function SR$$$tcFSharpCoreRequiresExplicit() {
  return [1175, (0, _String.toText)((0, _String.printf)("All record, union and struct types in FSharp.Core.dll must be explicitly labelled with 'StructuralComparison' or 'NoComparison'"))];
}

function SR$$$tcStructuralComparisonNotSatisfied1$$Z384F8060(a0$$363, a1$$165) {
  return [1176, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' has the 'StructuralComparison' attribute but the type parameter '%s' does not satisfy the 'comparison' constraint. Consider adding the 'comparison' constraint to the type parameter"))(a0$$363)(a1$$165)];
}

function SR$$$tcStructuralComparisonNotSatisfied2$$Z384F8060(a0$$364, a1$$166) {
  return [1177, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' has the 'StructuralComparison' attribute but the component type '%s' does not satisfy the 'comparison' constraint"))(a0$$364)(a1$$166)];
}

function SR$$$tcNoComparisonNeeded1$$30230F9B(a0$$365, a1$$167, a2$$66) {
  return [1178, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' is not structurally comparable because the type parameter %s does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '%s' to clarify that the type is not comparable"))(a0$$365)(a1$$167)(a2$$66)];
}

function SR$$$tcNoComparisonNeeded2$$30230F9B(a0$$366, a1$$168, a2$$67) {
  return [1178, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' is not structurally comparable because the type '%s' does not satisfy the 'comparison' constraint. Consider adding the 'NoComparison' attribute to the type '%s' to clarify that the type is not comparable"))(a0$$366)(a1$$168)(a2$$67)];
}

function SR$$$tcNoEqualityNeeded1$$30230F9B(a0$$367, a1$$169, a2$$68) {
  return [1178, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' does not support structural equality because the type parameter %s does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '%s' to clarify that the type does not support structural equality"))(a0$$367)(a1$$169)(a2$$68)];
}

function SR$$$tcNoEqualityNeeded2$$30230F9B(a0$$368, a1$$170, a2$$69) {
  return [1178, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' does not support structural equality because the type '%s' does not satisfy the 'equality' constraint. Consider adding the 'NoEquality' attribute to the type '%s' to clarify that the type does not support structural equality"))(a0$$368)(a1$$170)(a2$$69)];
}

function SR$$$tcStructuralEqualityNotSatisfied1$$Z384F8060(a0$$369, a1$$171) {
  return [1179, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' has the 'StructuralEquality' attribute but the type parameter '%s' does not satisfy the 'equality' constraint. Consider adding the 'equality' constraint to the type parameter"))(a0$$369)(a1$$171)];
}

function SR$$$tcStructuralEqualityNotSatisfied2$$Z384F8060(a0$$370, a1$$172) {
  return [1180, (0, _String.toText)((0, _String.printf)("The struct, record or union type '%s' has the 'StructuralEquality' attribute but the component type '%s' does not satisfy the 'equality' constraint"))(a0$$370)(a1$$172)];
}

function SR$$$tcStructsMustDeclareTypesOfImplicitCtorArgsExplicitly() {
  return [1181, (0, _String.toText)((0, _String.printf)("Each argument of the primary constructor for a struct must be given a type, for example 'type S(x1:int, x2: int) = ...'. These arguments determine the fields of the struct."))];
}

function SR$$$chkUnusedValue$$Z721C83C5(a0$$371) {
  return [1182, (0, _String.toText)((0, _String.printf)("The value '%s' is unused"))(a0$$371)];
}

function SR$$$chkUnusedThisVariable$$Z721C83C5(a0$$372) {
  return [1183, (0, _String.toText)((0, _String.printf)("The recursive object reference '%s' is unused. The presence of a recursive object reference adds runtime initialization checks to members in this and derived types. Consider removing this recursive object reference."))(a0$$372)];
}

function SR$$$parsGetterAtMostOneArgument() {
  return [1184, (0, _String.toText)((0, _String.printf)("A getter property may have at most one argument group"))];
}

function SR$$$parsSetterAtMostTwoArguments() {
  return [1185, (0, _String.toText)((0, _String.printf)("A setter property may have at most two argument groups"))];
}

function SR$$$parsInvalidProperty() {
  return [1186, (0, _String.toText)((0, _String.printf)("Invalid property getter or setter"))];
}

function SR$$$parsIndexerPropertyRequiresAtLeastOneArgument() {
  return [1187, (0, _String.toText)((0, _String.printf)("An indexer property must be given at least one argument"))];
}

function SR$$$tastInvalidAddressOfMutableAcrossAssemblyBoundary() {
  return [1188, (0, _String.toText)((0, _String.printf)("This operation accesses a mutable top-level value defined in another assembly in an unsupported way. The value cannot be accessed through its address. Consider copying the expression to a mutable local, e.g. 'let mutable x = ...', and if necessary assigning the value back after the completion of the operation"))];
}

function SR$$$parsNonAdjacentTypars() {
  return [1189, (0, _String.toText)((0, _String.printf)("Type parameters must be placed directly adjacent to the type name, e.g. \"type C<'T>\", not     type \"C   <'T>\""))];
}

function SR$$$parsNonAdjacentTyargs() {
  return [1190, (0, _String.toText)((0, _String.printf)("Type arguments must be placed directly adjacent to the type name, e.g. \"C<'T>\", not \"C  <'T>\""))];
}

function SR$$$parsNonAtomicType() {
  return (0, _String.toText)((0, _String.printf)("The use of the type syntax 'int C' and 'C  <int>' is not permitted here. Consider adjusting this type to be written in the form 'C<int>'"));
}

function SR$$$tastUndefinedItemRefModuleNamespace$$30230F9B(a0$$373, a1$$173, a2$$70) {
  return [1193, (0, _String.toText)((0, _String.printf)("The module/namespace '%s' from compilation unit '%s' did not contain the module/namespace '%s'"))(a0$$373)(a1$$173)(a2$$70)];
}

function SR$$$tastUndefinedItemRefVal$$30230F9B(a0$$374, a1$$174, a2$$71) {
  return [1194, (0, _String.toText)((0, _String.printf)("The module/namespace '%s' from compilation unit '%s' did not contain the val '%s'"))(a0$$374)(a1$$174)(a2$$71)];
}

function SR$$$tastUndefinedItemRefModuleNamespaceType$$30230F9B(a0$$375, a1$$175, a2$$72) {
  return [1195, (0, _String.toText)((0, _String.printf)("The module/namespace '%s' from compilation unit '%s' did not contain the namespace, module or type '%s'"))(a0$$375)(a1$$175)(a2$$72)];
}

function SR$$$tcInvalidUseNullAsTrueValue() {
  return [1196, (0, _String.toText)((0, _String.printf)("The 'UseNullAsTrueValue' attribute flag may only be used with union types that have one nullary case and at least one non-nullary case"))];
}

function SR$$$tcParameterInferredByref$$Z721C83C5(a0$$376) {
  return [1197, (0, _String.toText)((0, _String.printf)("The parameter '%s' was inferred to have byref type. Parameters of byref type must be given an explicit type annotation, e.g. 'x1: byref<int>'. When used, a byref parameter is implicitly dereferenced."))(a0$$376)];
}

function SR$$$tcNonUniformMemberUse$$Z721C83C5(a0$$377) {
  return [1198, (0, _String.toText)((0, _String.printf)("The generic member '%s' has been used at a non-uniform instantiation prior to this program point. Consider reordering the members so this member occurs first. Alternatively, specify the full type of the member explicitly, including argument types, return type and any additional generic parameters and constraints."))(a0$$377)];
}

function SR$$$tcAttribArgsDiffer$$Z721C83C5(a0$$378) {
  return [1200, (0, _String.toText)((0, _String.printf)("The attribute '%s' appears in both the implementation and the signature, but the attribute arguments differ. Only the attribute from the signature will be included in the compiled code."))(a0$$378)];
}

function SR$$$tcCannotCallAbstractBaseMember$$Z721C83C5(a0$$379) {
  return [1201, (0, _String.toText)((0, _String.printf)("Cannot call an abstract base member: '%s'"))(a0$$379)];
}

function SR$$$typrelCannotResolveAmbiguityInUnmanaged() {
  return [1202, (0, _String.toText)((0, _String.printf)("Could not resolve the ambiguity in the use of a generic construct with an 'unmanaged' constraint at or near this position"))];
}

function SR$$$mlCompatMessage$$Z721C83C5(a0$$380) {
  return (0, _String.toText)((0, _String.printf)("This construct is for ML compatibility. %s. You can disable this warning by using '--mlcompatibility' or '--nowarn:62'."))(a0$$380);
}

function SR$$$ilFieldDoesNotHaveValidOffsetForStructureLayout$$Z384F8060(a0$$381, a1$$176) {
  return [1206, (0, _String.toText)((0, _String.printf)("The type '%s' has been marked as having an Explicit layout, but the field '%s' has not been marked with the 'FieldOffset' attribute"))(a0$$381)(a1$$176)];
}

function SR$$$tcInterfacesShouldUseInheritNotInterface() {
  return [1207, (0, _String.toText)((0, _String.printf)("Interfaces inherited by other interfaces should be declared using 'inherit ...' instead of 'interface ...'"))];
}

function SR$$$parsInvalidPrefixOperator() {
  return [1208, (0, _String.toText)((0, _String.printf)("Invalid prefix operator"))];
}

function SR$$$parsInvalidPrefixOperatorDefinition() {
  return [1208, (0, _String.toText)((0, _String.printf)("Invalid operator definition. Prefix operator definitions must use a valid prefix operator name."))];
}

function SR$$$buildCompilingExtensionIsForML() {
  return (0, _String.toText)((0, _String.printf)("The file extensions '.ml' and '.mli' are for ML compatibility"));
}

function SR$$$lexIndentOffForML() {
  return (0, _String.toText)((0, _String.printf)("Consider using a file with extension '.ml' or '.mli' instead"));
}

function SR$$$activePatternIdentIsNotFunctionTyped$$Z721C83C5(a0$$382) {
  return [1209, (0, _String.toText)((0, _String.printf)("Active pattern '%s' is not a function"))(a0$$382)];
}

function SR$$$activePatternChoiceHasFreeTypars$$Z721C83C5(a0$$383) {
  return [1210, (0, _String.toText)((0, _String.printf)("Active pattern '%s' has a result type containing type variables that are not determined by the input. The common cause is a when a result case is not mentioned, e.g. 'let (|A|B|) (x:int) = A x'. This can be fixed with a type constraint, e.g. 'let (|A|B|) (x:int) : Choice<int,unit> = A x'"))(a0$$383)];
}

function SR$$$ilFieldHasOffsetForSequentialLayout() {
  return [1211, (0, _String.toText)((0, _String.printf)("The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)"))];
}

function SR$$$tcOptionalArgsMustComeAfterNonOptionalArgs() {
  return [1212, (0, _String.toText)((0, _String.printf)("Optional arguments must come at the end of the argument list, after any non-optional arguments"))];
}

function SR$$$tcConditionalAttributeUsage() {
  return [1213, (0, _String.toText)((0, _String.printf)("Attribute 'System.Diagnostics.ConditionalAttribute' is only valid on methods or attribute classes"))];
}

function SR$$$tcMemberOperatorDefinitionInExtrinsic() {
  return [1215, (0, _String.toText)((0, _String.printf)("Extension members cannot provide operator overloads.  Consider defining the operator as part of the type definition instead."))];
}

function SR$$$ilwriteMDBFileNameCannotBeChangedWarning() {
  return [1216, (0, _String.toText)((0, _String.printf)("The name of the MDB file must be <assembly-file-name>.mdb. The --pdb option will be ignored."))];
}

function SR$$$ilwriteMDBMemberMissing$$Z721C83C5(a0$$384) {
  return [1217, (0, _String.toText)((0, _String.printf)("MDB generation failed. Could not find compatible member %s"))(a0$$384)];
}

function SR$$$ilwriteErrorCreatingMdb() {
  return [1218, (0, _String.toText)((0, _String.printf)("Cannot generate MDB debug information. Failed to load the 'MonoSymbolWriter' type from the 'Mono.CompilerServices.SymbolWriter.dll' assembly."))];
}

function SR$$$tcUnionCaseNameConflictsWithGeneratedType$$Z384F8060(a0$$385, a1$$177) {
  return [1219, (0, _String.toText)((0, _String.printf)("The union case named '%s' conflicts with the generated type '%s'"))(a0$$385)(a1$$177)];
}

function SR$$$chkNoReflectedDefinitionOnStructMember() {
  return [1220, (0, _String.toText)((0, _String.printf)("ReflectedDefinitionAttribute may not be applied to an instance member on a struct type, because the instance member takes an implicit 'this' byref parameter"))];
}

function SR$$$tcDllImportNotAllowed() {
  return [1221, (0, _String.toText)((0, _String.printf)("DLLImport bindings must be static members in a class or function definitions in a module"))];
}

function SR$$$buildExplicitCoreLibRequiresNoFramework$$Z721C83C5(a0$$386) {
  return [1222, (0, _String.toText)((0, _String.printf)("When mscorlib.dll or FSharp.Core.dll is explicitly referenced the %s option must also be passed"))(a0$$386)];
}

function SR$$$buildExpectedSigdataFile$$Z721C83C5(a0$$387) {
  return [1223, (0, _String.toText)((0, _String.printf)("FSharp.Core.sigdata not found alongside FSharp.Core. File expected in %s. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required."))(a0$$387)];
}

function SR$$$buildExpectedFileAlongSideFSharpCore$$Z384F8060(a0$$388, a1$$178) {
  return [1225, (0, _String.toText)((0, _String.printf)("File '%s' not found alongside FSharp.Core. File expected in %s. Consider upgrading to a more recent version of FSharp.Core, where this file is no longer be required."))(a0$$388)(a1$$178)];
}

function SR$$$buildUnexpectedFileNameCharacter$$Z384F8060(a0$$389, a1$$179) {
  return [1227, (0, _String.toText)((0, _String.printf)("Filename '%s' contains invalid character '%s'"))(a0$$389)(a1$$179)];
}

function SR$$$tcInvalidUseBangBinding() {
  return [1228, (0, _String.toText)((0, _String.printf)("'use!' bindings must be of the form 'use! <var> = <expr>'"))];
}

function SR$$$crefNoInnerGenericsInQuotations() {
  return [1230, (0, _String.toText)((0, _String.printf)("Inner generic functions are not permitted in quoted expressions. Consider adding some type constraints until this function is no longer generic."))];
}

function SR$$$tcEnumTypeCannotBeEnumerated$$Z721C83C5(a0$$390) {
  return [1231, (0, _String.toText)((0, _String.printf)("The type '%s' is not a valid enumerator type , i.e. does not have a 'MoveNext()' method returning a bool, and a 'Current' property"))(a0$$390)];
}

function SR$$$parsEofInTripleQuoteString() {
  return [1232, (0, _String.toText)((0, _String.printf)("End of file in triple-quote string begun at or before here"))];
}

function SR$$$parsEofInTripleQuoteStringInComment() {
  return [1233, (0, _String.toText)((0, _String.printf)("End of file in triple-quote string embedded in comment begun at or before here"))];
}

function SR$$$tcTypeTestLosesMeasures$$Z721C83C5(a0$$391) {
  return [1240, (0, _String.toText)((0, _String.printf)("This type test or downcast will ignore the unit-of-measure '%s'"))(a0$$391)];
}

function SR$$$parsMissingTypeArgs() {
  return [1241, (0, _String.toText)((0, _String.printf)("Expected type argument or static argument"))];
}

function SR$$$parsMissingGreaterThan() {
  return [1242, (0, _String.toText)((0, _String.printf)("Unmatched '<'. Expected closing '>'"))];
}

function SR$$$parsUnexpectedQuotationOperatorInTypeAliasDidYouMeanVerbatimString() {
  return [1243, (0, _String.toText)((0, _String.printf)("Unexpected quotation operator '<@' in type definition. If you intend to pass a verbatim string as a static argument to a type provider, put a space between the '<' and '@' characters."))];
}

function SR$$$parsErrorParsingAsOperatorName() {
  return [1244, (0, _String.toText)((0, _String.printf)("Attempted to parse this as an operator name, but failed"))];
}

function SR$$$lexInvalidUnicodeLiteral$$Z721C83C5(a0$$392) {
  return [1245, (0, _String.toText)((0, _String.printf)("\\U%s is not a valid Unicode character escape sequence"))(a0$$392)];
}

function SR$$$tcCallerInfoWrongType$$30230F9B(a0$$393, a1$$180, a2$$73) {
  return [1246, (0, _String.toText)((0, _String.printf)("'%s' must be applied to an argument of type '%s', but has been applied to an argument of type '%s'"))(a0$$393)(a1$$180)(a2$$73)];
}

function SR$$$tcCallerInfoNotOptional$$Z721C83C5(a0$$394) {
  return [1247, (0, _String.toText)((0, _String.printf)("'%s' can only be applied to optional arguments"))(a0$$394)];
}

function SR$$$toolLocationHelperUnsupportedFrameworkVersion$$Z721C83C5(a0$$395) {
  return [1300, (0, _String.toText)((0, _String.printf)("The specified .NET Framework version '%s' is not supported. Please specify a value from the enumeration Microsoft.Build.Utilities.TargetDotNetFrameworkVersion."))(a0$$395)];
}

function SR$$$ilSignInvalidMagicValue() {
  return [1301, (0, _String.toText)((0, _String.printf)("Invalid Magic value in CLR Header"))];
}

function SR$$$ilSignBadImageFormat() {
  return [1302, (0, _String.toText)((0, _String.printf)("Bad image format"))];
}

function SR$$$ilSignPrivateKeyExpected() {
  return [1303, (0, _String.toText)((0, _String.printf)("Private key expected"))];
}

function SR$$$ilSignRsaKeyExpected() {
  return [1304, (0, _String.toText)((0, _String.printf)("RSA key expected"))];
}

function SR$$$ilSignInvalidBitLen() {
  return [1305, (0, _String.toText)((0, _String.printf)("Invalid bit Length"))];
}

function SR$$$ilSignInvalidRSAParams() {
  return [1306, (0, _String.toText)((0, _String.printf)("Invalid RSAParameters structure - '{0}' expected"))];
}

function SR$$$ilSignInvalidAlgId() {
  return [1307, (0, _String.toText)((0, _String.printf)("Invalid algId - 'Exponent' expected"))];
}

function SR$$$ilSignInvalidSignatureSize() {
  return [1308, (0, _String.toText)((0, _String.printf)("Invalid signature size"))];
}

function SR$$$ilSignNoSignatureDirectory() {
  return [1309, (0, _String.toText)((0, _String.printf)("No signature directory"))];
}

function SR$$$ilSignInvalidPKBlob() {
  return [1310, (0, _String.toText)((0, _String.printf)("Invalid Public Key blob"))];
}

function SR$$$fscTooManyErrors() {
  return (0, _String.toText)((0, _String.printf)("Exiting - too many errors"));
}

function SR$$$docfileNoXmlSuffix() {
  return [2001, (0, _String.toText)((0, _String.printf)("The documentation file has no .xml suffix"))];
}

function SR$$$fscNoImplementationFiles() {
  return [2002, (0, _String.toText)((0, _String.printf)("No implementation files specified"))];
}

function SR$$$fscBadAssemblyVersion$$Z384F8060(a0$$396, a1$$181) {
  return [2003, (0, _String.toText)((0, _String.printf)("The attribute %s specified version '%s', but this value is invalid and has been ignored"))(a0$$396)(a1$$181)];
}

function SR$$$fscTwoResourceManifests() {
  return [2004, (0, _String.toText)((0, _String.printf)("Conflicting options specified: 'win32manifest' and 'win32res'. Only one of these can be used."))];
}

function SR$$$fscQuotationLiteralsStaticLinking$$Z721C83C5(a0$$397) {
  return [2005, (0, _String.toText)((0, _String.printf)("The code in assembly '%s' makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0."))(a0$$397)];
}

function SR$$$fscQuotationLiteralsStaticLinking0() {
  return [2006, (0, _String.toText)((0, _String.printf)("Code in this assembly makes uses of quotation literals. Static linking may not include components that make use of quotation literals unless all assemblies are compiled with at least F# 4.0."))];
}

function SR$$$fscStaticLinkingNoEXE() {
  return [2007, (0, _String.toText)((0, _String.printf)("Static linking may not include a .EXE"))];
}

function SR$$$fscStaticLinkingNoMixedDLL() {
  return [2008, (0, _String.toText)((0, _String.printf)("Static linking may not include a mixed managed/unmanaged DLL"))];
}

function SR$$$fscIgnoringMixedWhenLinking$$Z721C83C5(a0$$398) {
  return [2009, (0, _String.toText)((0, _String.printf)("Ignoring mixed managed/unmanaged assembly '%s' during static linking"))(a0$$398)];
}

function SR$$$fscAssumeStaticLinkContainsNoDependencies$$Z721C83C5(a0$$399) {
  return [2011, (0, _String.toText)((0, _String.printf)("Assembly '%s' was referenced transitively and the assembly could not be resolved automatically. Static linking will assume this DLL has no dependencies on the F# library or other statically linked DLLs. Consider adding an explicit reference to this DLL."))(a0$$399)];
}

function SR$$$fscAssemblyNotFoundInDependencySet$$Z721C83C5(a0$$400) {
  return [2012, (0, _String.toText)((0, _String.printf)("Assembly '%s' not found in dependency set of target binary. Statically linked roots should be specified using an assembly name, without a DLL or EXE extension. If this assembly was referenced explicitly then it is possible the assembly was not actually required by the generated binary, in which case it should not be statically linked."))(a0$$400)];
}

function SR$$$fscKeyFileCouldNotBeOpened$$Z721C83C5(a0$$401) {
  return [2013, (0, _String.toText)((0, _String.printf)("The key file '%s' could not be opened"))(a0$$401)];
}

function SR$$$fscProblemWritingBinary$$Z384F8060(a0$$402, a1$$182) {
  return [2014, (0, _String.toText)((0, _String.printf)("A problem occurred writing the binary '%s': %s"))(a0$$402)(a1$$182)];
}

function SR$$$fscAssemblyVersionAttributeIgnored() {
  return [2015, (0, _String.toText)((0, _String.printf)("The 'AssemblyVersionAttribute' has been ignored because a version was given using a command line option"))];
}

function SR$$$fscAssemblyCultureAttributeError() {
  return [2016, (0, _String.toText)((0, _String.printf)("Error emitting 'System.Reflection.AssemblyCultureAttribute' attribute -- 'Executables cannot be satellite assemblies, Culture should always be empty'"))];
}

function SR$$$fscDelaySignWarning() {
  return [2017, (0, _String.toText)((0, _String.printf)("Option '--delaysign' overrides attribute 'System.Reflection.AssemblyDelaySignAttribute' given in a source file or added module"))];
}

function SR$$$fscKeyFileWarning() {
  return [2018, (0, _String.toText)((0, _String.printf)("Option '--keyfile' overrides attribute 'System.Reflection.AssemblyKeyFileAttribute' given in a source file or added module"))];
}

function SR$$$fscKeyNameWarning() {
  return [2019, (0, _String.toText)((0, _String.printf)("Option '--keycontainer' overrides attribute 'System.Reflection.AssemblyNameAttribute' given in a source file or added module"))];
}

function SR$$$fscReferenceOnCommandLine$$Z721C83C5(a0$$403) {
  return [2020, (0, _String.toText)((0, _String.printf)("The assembly '%s' is listed on the command line. Assemblies should be referenced using a command line flag such as '-r'."))(a0$$403)];
}

function SR$$$fscRemotingError() {
  return [2021, (0, _String.toText)((0, _String.printf)("The resident compilation service was not used because a problem occured in communicating with the server."))];
}

function SR$$$pathIsInvalid$$Z721C83C5(a0$$404) {
  return [2022, (0, _String.toText)((0, _String.printf)("Problem with filename '%s': Illegal characters in path."))(a0$$404)];
}

function SR$$$fscResxSourceFileDeprecated$$Z721C83C5(a0$$405) {
  return [2023, (0, _String.toText)((0, _String.printf)("Passing a .resx file (%s) as a source file to the compiler is deprecated. Use resgen.exe to transform the .resx file into a .resources file to pass as a --resource option. If you are using MSBuild, this can be done via an <EmbeddedResource> item in the .fsproj project file."))(a0$$405)];
}

function SR$$$fscStaticLinkingNoProfileMismatches() {
  return [2024, (0, _String.toText)((0, _String.printf)("Static linking may not be used on an assembly referencing mscorlib (e.g. a .NET Framework assembly) when generating an assembly that references System.Runtime (e.g. a .NET Core or Portable assembly)."))];
}

function SR$$$fscAssemblyWildcardAndDeterminism$$Z384F8060(a0$$406, a1$$183) {
  return [2025, (0, _String.toText)((0, _String.printf)("An %s specified version '%s', but this value is a wildcard, and you have requested a deterministic build, these are in conflict."))(a0$$406)(a1$$183)];
}

function SR$$$fscDeterministicDebugRequiresPortablePdb() {
  return [2026, (0, _String.toText)((0, _String.printf)("Determinstic builds only support portable PDBs (--debug:portable or --debug:embedded)"))];
}

function SR$$$etIllegalCharactersInNamespaceName$$Z384F8060(a0$$407, a1$$184) {
  return [3000, (0, _String.toText)((0, _String.printf)("Character '%s' is not allowed in provided namespace name '%s'"))(a0$$407)(a1$$184)];
}

function SR$$$etNullOrEmptyMemberName$$Z721C83C5(a0$$408) {
  return [3001, (0, _String.toText)((0, _String.printf)("The provided type '%s' returned a member with a null or empty member name"))(a0$$408)];
}

function SR$$$etNullMember$$Z721C83C5(a0$$409) {
  return [3002, (0, _String.toText)((0, _String.printf)("The provided type '%s' returned a null member"))(a0$$409)];
}

function SR$$$etNullMemberDeclaringType$$Z384F8060(a0$$410, a1$$185) {
  return [3003, (0, _String.toText)((0, _String.printf)("The provided type '%s' member info '%s' has null declaring type"))(a0$$410)(a1$$185)];
}

function SR$$$etNullMemberDeclaringTypeDifferentFromProvidedType$$30230F9B(a0$$411, a1$$186, a2$$74) {
  return [3004, (0, _String.toText)((0, _String.printf)("The provided type '%s' has member '%s' which has declaring type '%s'. Expected declaring type to be the same as provided type."))(a0$$411)(a1$$186)(a2$$74)];
}

function SR$$$etHostingAssemblyFoundWithoutHosts$$Z384F8060(a0$$412, a1$$187) {
  return [3005, (0, _String.toText)((0, _String.printf)("Referenced assembly '%s' has assembly level attribute '%s' but no public type provider classes were found"))(a0$$412)(a1$$187)];
}

function SR$$$etEmptyNamespaceOfTypeNotAllowed$$Z384F8060(a0$$413, a1$$188) {
  return [3006, (0, _String.toText)((0, _String.printf)("Type '%s' from type provider '%s' has an empty namespace. Use 'null' for the global namespace."))(a0$$413)(a1$$188)];
}

function SR$$$etEmptyNamespaceNotAllowed$$Z721C83C5(a0$$414) {
  return [3007, (0, _String.toText)((0, _String.printf)("Empty namespace found from the type provider '%s'. Use 'null' for the global namespace."))(a0$$414)];
}

function SR$$$etMustNotBeGeneric$$Z721C83C5(a0$$415) {
  return [3011, (0, _String.toText)((0, _String.printf)("Provided type '%s' has 'IsGenericType' as true, but generic types are not supported."))(a0$$415)];
}

function SR$$$etMustNotBeAnArray$$Z721C83C5(a0$$416) {
  return [3013, (0, _String.toText)((0, _String.printf)("Provided type '%s' has 'IsArray' as true, but array types are not supported."))(a0$$416)];
}

function SR$$$etMethodHasRequirements$$Z384F8060(a0$$417, a1$$189) {
  return [3014, (0, _String.toText)((0, _String.printf)("Invalid member '%s' on provided type '%s'. Provided type members must be public, and not be generic, virtual, or abstract."))(a0$$417)(a1$$189)];
}

function SR$$$etUnsupportedMemberKind$$Z384F8060(a0$$418, a1$$190) {
  return [3015, (0, _String.toText)((0, _String.printf)("Invalid member '%s' on provided type '%s'. Only properties, methods and constructors are allowed"))(a0$$418)(a1$$190)];
}

function SR$$$etPropertyCanReadButHasNoGetter$$Z384F8060(a0$$419, a1$$191) {
  return [3016, (0, _String.toText)((0, _String.printf)("Property '%s' on provided type '%s' has CanRead=true but there was no value from GetGetMethod()"))(a0$$419)(a1$$191)];
}

function SR$$$etPropertyHasGetterButNoCanRead$$Z384F8060(a0$$420, a1$$192) {
  return [3017, (0, _String.toText)((0, _String.printf)("Property '%s' on provided type '%s' has CanRead=false but GetGetMethod() returned a method"))(a0$$420)(a1$$192)];
}

function SR$$$etPropertyCanWriteButHasNoSetter$$Z384F8060(a0$$421, a1$$193) {
  return [3018, (0, _String.toText)((0, _String.printf)("Property '%s' on provided type '%s' has CanWrite=true but there was no value from GetSetMethod()"))(a0$$421)(a1$$193)];
}

function SR$$$etPropertyHasSetterButNoCanWrite$$Z384F8060(a0$$422, a1$$194) {
  return [3019, (0, _String.toText)((0, _String.printf)("Property '%s' on provided type '%s' has CanWrite=false but GetSetMethod() returned a method"))(a0$$422)(a1$$194)];
}

function SR$$$etOneOrMoreErrorsSeenDuringExtensionTypeSetting() {
  return [3020, (0, _String.toText)((0, _String.printf)("One or more errors seen during provided type setup"))];
}

function SR$$$etUnexpectedExceptionFromProvidedTypeMember$$30230F9B(a0$$423, a1$$195, a2$$75) {
  return [3021, (0, _String.toText)((0, _String.printf)("Unexpected exception from provided type '%s' member '%s': %s"))(a0$$423)(a1$$195)(a2$$75)];
}

function SR$$$etUnsupportedConstantType$$Z721C83C5(a0$$424) {
  return [3022, (0, _String.toText)((0, _String.printf)("Unsupported constant type '%s'. Quotations provided by type providers can only contain simple constants. The implementation of the type provider may need to be adjusted by moving a value declared outside a provided quotation literal to be a 'let' binding inside the quotation literal."))(a0$$424)];
}

function SR$$$etUnsupportedProvidedExpression$$Z721C83C5(a0$$425) {
  return [3025, (0, _String.toText)((0, _String.printf)("Unsupported expression '%s' from type provider. If you are the author of this type provider, consider adjusting it to provide a different provided expression."))(a0$$425)];
}

function SR$$$etProvidedTypeHasUnexpectedName$$Z384F8060(a0$$426, a1$$196) {
  return [3028, (0, _String.toText)((0, _String.printf)("Expected provided type named '%s' but provided type has 'Name' with value '%s'"))(a0$$426)(a1$$196)];
}

function SR$$$etEventNoAdd$$Z384F8060(a0$$427, a1$$197) {
  return [3029, (0, _String.toText)((0, _String.printf)("Event '%s' on provided type '%s' has no value from GetAddMethod()"))(a0$$427)(a1$$197)];
}

function SR$$$etEventNoRemove$$Z384F8060(a0$$428, a1$$198) {
  return [3030, (0, _String.toText)((0, _String.printf)("Event '%s' on provided type '%s' has no value from GetRemoveMethod()"))(a0$$428)(a1$$198)];
}

function SR$$$etProviderHasWrongDesignerAssembly$$30230F9B(a0$$429, a1$$199, a2$$76) {
  return [3031, (0, _String.toText)((0, _String.printf)("Assembly attribute '%s' refers to a designer assembly '%s' which cannot be loaded or doesn't exist. %s"))(a0$$429)(a1$$199)(a2$$76)];
}

function SR$$$etProviderDoesNotHaveValidConstructor() {
  return [3032, (0, _String.toText)((0, _String.printf)("The type provider does not have a valid constructor. A constructor taking either no arguments or one argument of type 'TypeProviderConfig' was expected."))];
}

function SR$$$etProviderError$$Z384F8060(a0$$430, a1$$200) {
  return [3033, (0, _String.toText)((0, _String.printf)("The type provider '%s' reported an error: %s"))(a0$$430)(a1$$200)];
}

function SR$$$etIncorrectParameterExpression$$Z384F8060(a0$$431, a1$$201) {
  return [3034, (0, _String.toText)((0, _String.printf)("The type provider '%s' used an invalid parameter in the ParameterExpression: %s"))(a0$$431)(a1$$201)];
}

function SR$$$etIncorrectProvidedMethod$$Z522416B9(a0$$432, a1$$202, a2$$77, a3$$18) {
  return [3035, (0, _String.toText)((0, _String.printf)("The type provider '%s' provided a method with a name '%s' and metadata token '%d', which is not reported among its methods of its declaring type '%s'"))(a0$$432)(a1$$202)(a2$$77)(a3$$18)];
}

function SR$$$etIncorrectProvidedConstructor$$Z384F8060(a0$$433, a1$$203) {
  return [3036, (0, _String.toText)((0, _String.printf)("The type provider '%s' provided a constructor which is not reported among the constructors of its declaring type '%s'"))(a0$$433)(a1$$203)];
}

function SR$$$etDirectReferenceToGeneratedTypeNotAllowed$$Z721C83C5(a0$$434) {
  return [3039, (0, _String.toText)((0, _String.printf)("A direct reference to the generated type '%s' is not permitted. Instead, use a type definition, e.g. 'type TypeAlias = <path>'. This indicates that a type provider adds generated types to your assembly."))(a0$$434)];
}

function SR$$$etProvidedTypeHasUnexpectedPath$$Z384F8060(a0$$435, a1$$204) {
  return [3041, (0, _String.toText)((0, _String.printf)("Expected provided type with path '%s' but provided type has path '%s'"))(a0$$435)(a1$$204)];
}

function SR$$$etUnexpectedNullFromProvidedTypeMember$$Z384F8060(a0$$436, a1$$205) {
  return [3042, (0, _String.toText)((0, _String.printf)("Unexpected 'null' return value from provided type '%s' member '%s'"))(a0$$436)(a1$$205)];
}

function SR$$$etUnexpectedExceptionFromProvidedMemberMember$$Z46998140(a0$$437, a1$$206, a2$$78, a3$$19) {
  return [3043, (0, _String.toText)((0, _String.printf)("Unexpected exception from member '%s' of provided type '%s' member '%s': %s"))(a0$$437)(a1$$206)(a2$$78)(a3$$19)];
}

function SR$$$etNestedProvidedTypesDoNotTakeStaticArgumentsOrGenericParameters() {
  return [3044, (0, _String.toText)((0, _String.printf)("Nested provided types do not take static arguments or generic parameters"))];
}

function SR$$$etInvalidStaticArgument$$Z721C83C5(a0$$438) {
  return [3045, (0, _String.toText)((0, _String.printf)("Invalid static argument to provided type. Expected an argument of kind '%s'."))(a0$$438)];
}

function SR$$$etErrorApplyingStaticArgumentsToType() {
  return [3046, (0, _String.toText)((0, _String.printf)("An error occured applying the static arguments to a provided type"))];
}

function SR$$$etUnknownStaticArgumentKind$$Z384F8060(a0$$439, a1$$207) {
  return [3047, (0, _String.toText)((0, _String.printf)("Unknown static argument kind '%s' when resolving a reference to a provided type or method '%s'"))(a0$$439)(a1$$207)];
}

function SR$$$invalidNamespaceForProvidedType() {
  return (0, _String.toText)((0, _String.printf)("invalid namespace for provided type"));
}

function SR$$$invalidFullNameForProvidedType() {
  return (0, _String.toText)((0, _String.printf)("invalid full name for provided type"));
}

function SR$$$etProviderReturnedNull$$Z721C83C5(a0$$440) {
  return [3051, (0, _String.toText)((0, _String.printf)("The type provider returned 'null', which is not a valid return value from '%s'"))(a0$$440)];
}

function SR$$$etTypeProviderConstructorException$$Z721C83C5(a0$$441) {
  return [3053, (0, _String.toText)((0, _String.printf)("The type provider constructor has thrown an exception: %s"))(a0$$441)];
}

function SR$$$etNullProvidedExpression$$Z721C83C5(a0$$442) {
  return [3056, (0, _String.toText)((0, _String.printf)("Type provider '%s' returned null from GetInvokerExpression."))(a0$$442)];
}

function SR$$$etProvidedAppliedTypeHadWrongName$$30230F9B(a0$$443, a1$$208, a2$$79) {
  return [3057, (0, _String.toText)((0, _String.printf)("The type provider '%s' returned an invalid type from 'ApplyStaticArguments'. A type with name '%s' was expected, but a type with name '%s' was returned."))(a0$$443)(a1$$208)(a2$$79)];
}

function SR$$$etProvidedAppliedMethodHadWrongName$$30230F9B(a0$$444, a1$$209, a2$$80) {
  return [3058, (0, _String.toText)((0, _String.printf)("The type provider '%s' returned an invalid method from 'ApplyStaticArgumentsForMethod'. A method with name '%s' was expected, but a method with name '%s' was returned."))(a0$$444)(a1$$209)(a2$$80)];
}

function SR$$$tcTypeTestLossy$$Z384F8060(a0$$445, a1$$210) {
  return [3060, (0, _String.toText)((0, _String.printf)("This type test or downcast will erase the provided type '%s' to the type '%s'"))(a0$$445)(a1$$210)];
}

function SR$$$tcTypeCastErased$$Z384F8060(a0$$446, a1$$211) {
  return [3061, (0, _String.toText)((0, _String.printf)("This downcast will erase the provided type '%s' to the type '%s'."))(a0$$446)(a1$$211)];
}

function SR$$$tcTypeTestErased$$Z384F8060(a0$$447, a1$$212) {
  return [3062, (0, _String.toText)((0, _String.printf)("This type test with a provided type '%s' is not allowed because this provided type will be erased to '%s' at runtime."))(a0$$447)(a1$$212)];
}

function SR$$$tcCannotInheritFromErasedType() {
  return [3063, (0, _String.toText)((0, _String.printf)("Cannot inherit from erased provided type"))];
}

function SR$$$etInvalidTypeProviderAssemblyName$$Z384F8060(a0$$448, a1$$213) {
  return [3065, (0, _String.toText)((0, _String.printf)("Assembly '%s' hase TypeProviderAssembly attribute with invalid value '%s'. The value should be a valid assembly name"))(a0$$448)(a1$$213)];
}

function SR$$$tcInvalidMemberNameCtor() {
  return [3066, (0, _String.toText)((0, _String.printf)("Invalid member name. Members may not have name '.ctor' or '.cctor'"))];
}

function SR$$$tcInferredGenericTypeGivesRiseToInconsistency$$Z384F8060(a0$$449, a1$$214) {
  return [3068, (0, _String.toText)((0, _String.printf)("The function or member '%s' is used in a way that requires further type annotations at its definition to ensure consistency of inferred types. The inferred signature is '%s'."))(a0$$449)(a1$$214)];
}

function SR$$$tcInvalidTypeArgumentCount$$Z37302880(a0$$450, a1$$215) {
  return [3069, (0, _String.toText)((0, _String.printf)("The number of type arguments did not match: '%d' given, '%d' expected. This may be related to a previously reported error."))(a0$$450)(a1$$215)];
}

function SR$$$tcCannotOverrideSealedMethod$$Z721C83C5(a0$$451) {
  return [3070, (0, _String.toText)((0, _String.printf)("Cannot override inherited member '%s' because it is sealed"))(a0$$451)];
}

function SR$$$etProviderErrorWithContext$$Z46998140(a0$$452, a1$$216, a2$$81, a3$$20) {
  return [3071, (0, _String.toText)((0, _String.printf)("The type provider '%s' reported an error in the context of provided type '%s', member '%s'. The error: %s"))(a0$$452)(a1$$216)(a2$$81)(a3$$20)];
}

function SR$$$etProvidedTypeWithNameException$$Z384F8060(a0$$453, a1$$217) {
  return [3072, (0, _String.toText)((0, _String.printf)("An exception occurred when accessing the '%s' of a provided type: %s"))(a0$$453)(a1$$217)];
}

function SR$$$etProvidedTypeWithNullOrEmptyName$$Z721C83C5(a0$$454) {
  return [3073, (0, _String.toText)((0, _String.printf)("The '%s' of a provided type was null or empty."))(a0$$454)];
}

function SR$$$etIllegalCharactersInTypeName$$Z384F8060(a0$$455, a1$$218) {
  return [3075, (0, _String.toText)((0, _String.printf)("Character '%s' is not allowed in provided type name '%s'"))(a0$$455)(a1$$218)];
}

function SR$$$tcJoinMustUseSimplePattern$$Z721C83C5(a0$$456) {
  return [3077, (0, _String.toText)((0, _String.printf)("In queries, '%s' must use a simple pattern"))(a0$$456)];
}

function SR$$$tcMissingCustomOperation$$Z721C83C5(a0$$457) {
  return [3078, (0, _String.toText)((0, _String.printf)("A custom query operation for '%s' is required but not specified"))(a0$$457)];
}

function SR$$$etBadUnnamedStaticArgs() {
  return [3080, (0, _String.toText)((0, _String.printf)("Named static arguments must come after all unnamed static arguments"))];
}

function SR$$$etStaticParameterRequiresAValue$$Z46998140(a0$$458, a1$$219, a2$$82, a3$$21) {
  return [3081, (0, _String.toText)((0, _String.printf)("The static parameter '%s' of the provided type or method '%s' requires a value. Static parameters to type providers may be optionally specified using named arguments, e.g. '%s<%s=...>'."))(a0$$458)(a1$$219)(a2$$82)(a3$$21)];
}

function SR$$$etNoStaticParameterWithName$$Z721C83C5(a0$$459) {
  return [3082, (0, _String.toText)((0, _String.printf)("No static parameter exists with name '%s'"))(a0$$459)];
}

function SR$$$etStaticParameterAlreadyHasValue$$Z721C83C5(a0$$460) {
  return [3083, (0, _String.toText)((0, _String.printf)("The static parameter '%s' has already been given a value"))(a0$$460)];
}

function SR$$$etMultipleStaticParameterWithName$$Z721C83C5(a0$$461) {
  return [3084, (0, _String.toText)((0, _String.printf)("Multiple static parameters exist with name '%s'"))(a0$$461)];
}

function SR$$$tcCustomOperationMayNotBeUsedInConjunctionWithNonSimpleLetBindings() {
  return [3085, (0, _String.toText)((0, _String.printf)("A custom operation may not be used in conjunction with a non-value or recursive 'let' binding in another part of this computation expression"))];
}

function SR$$$tcCustomOperationMayNotBeUsedHere() {
  return [3086, (0, _String.toText)((0, _String.printf)("A custom operation may not be used in conjunction with 'use', 'try/with', 'try/finally', 'if/then/else' or 'match' operators within this computation expression"))];
}

function SR$$$tcCustomOperationMayNotBeOverloaded$$Z721C83C5(a0$$462) {
  return [3087, (0, _String.toText)((0, _String.printf)("The custom operation '%s' refers to a method which is overloaded. The implementations of custom operations may not be overloaded."))(a0$$462)];
}

function SR$$$tcIfThenElseMayNotBeUsedWithinQueries() {
  return [3090, (0, _String.toText)((0, _String.printf)("An if/then/else expression may not be used within queries. Consider using either an if/then expression, or use a sequence expression instead."))];
}

function SR$$$ilxgenUnexpectedArgumentToMethodHandleOfDuringCodegen() {
  return [3091, (0, _String.toText)((0, _String.printf)("Invalid argument to 'methodhandleof' during codegen"))];
}

function SR$$$etProvidedTypeReferenceMissingArgument$$Z721C83C5(a0$$463) {
  return [3092, (0, _String.toText)((0, _String.printf)("A reference to a provided type was missing a value for the static parameter '%s'. You may need to recompile one or more referenced assemblies."))(a0$$463)];
}

function SR$$$etProvidedTypeReferenceInvalidText$$Z721C83C5(a0$$464) {
  return [3093, (0, _String.toText)((0, _String.printf)("A reference to a provided type had an invalid value '%s' for a static parameter. You may need to recompile one or more referenced assemblies."))(a0$$464)];
}

function SR$$$tcCustomOperationNotUsedCorrectly$$Z721C83C5(a0$$465) {
  return [3095, (0, _String.toText)((0, _String.printf)("'%s' is not used correctly. This is a custom operation in this query or computation expression."))(a0$$465)];
}

function SR$$$tcCustomOperationNotUsedCorrectly2$$Z384F8060(a0$$466, a1$$220) {
  return [3095, (0, _String.toText)((0, _String.printf)("'%s' is not used correctly. Usage: %s. This is a custom operation in this query or computation expression."))(a0$$466)(a1$$220)];
}

function SR$$$customOperationTextLikeJoin$$30230F9B(a0$$467, a1$$221, a2$$83) {
  return (0, _String.toText)((0, _String.printf)("%s var in collection %s (outerKey = innerKey). Note that parentheses are required after '%s'"))(a0$$467)(a1$$221)(a2$$83);
}

function SR$$$customOperationTextLikeGroupJoin$$30230F9B(a0$$468, a1$$222, a2$$84) {
  return (0, _String.toText)((0, _String.printf)("%s var in collection %s (outerKey = innerKey) into group. Note that parentheses are required after '%s'"))(a0$$468)(a1$$222)(a2$$84);
}

function SR$$$customOperationTextLikeZip$$Z721C83C5(a0$$469) {
  return (0, _String.toText)((0, _String.printf)("%s var in collection"))(a0$$469);
}

function SR$$$tcBinaryOperatorRequiresVariable$$Z384F8060(a0$$470, a1$$223) {
  return [3096, (0, _String.toText)((0, _String.printf)("'%s' must be followed by a variable name. Usage: %s."))(a0$$470)(a1$$223)];
}

function SR$$$tcOperatorIncorrectSyntax$$Z384F8060(a0$$471, a1$$224) {
  return [3097, (0, _String.toText)((0, _String.printf)("Incorrect syntax for '%s'. Usage: %s."))(a0$$471)(a1$$224)];
}

function SR$$$tcBinaryOperatorRequiresBody$$Z384F8060(a0$$472, a1$$225) {
  return [3098, (0, _String.toText)((0, _String.printf)("'%s' must come after a 'for' selection clause and be followed by the rest of the query. Syntax: ... %s ..."))(a0$$472)(a1$$225)];
}

function SR$$$tcCustomOperationHasIncorrectArgCount$$487EF8FB(a0$$473, a1$$226, a2$$85) {
  return [3099, (0, _String.toText)((0, _String.printf)("'%s' is used with an incorrect number of arguments. This is a custom operation in this query or computation expression. Expected %d argument(s), but given %d."))(a0$$473)(a1$$226)(a2$$85)];
}

function SR$$$parsExpectedExpressionAfterToken() {
  return [3100, (0, _String.toText)((0, _String.printf)("Expected an expression after this point"))];
}

function SR$$$parsExpectedTypeAfterToken() {
  return [3101, (0, _String.toText)((0, _String.printf)("Expected a type after this point"))];
}

function SR$$$parsUnmatchedLBrackLess() {
  return [3102, (0, _String.toText)((0, _String.printf)("Unmatched '[<'. Expected closing '>]'"))];
}

function SR$$$parsUnexpectedEndOfFileMatch() {
  return [3103, (0, _String.toText)((0, _String.printf)("Unexpected end of input in 'match' expression. Expected 'match <expr> with | <pat> -> <expr> | <pat> -> <expr> ...'."))];
}

function SR$$$parsUnexpectedEndOfFileTry() {
  return [3104, (0, _String.toText)((0, _String.printf)("Unexpected end of input in 'try' expression. Expected 'try <expr> with <rules>' or 'try <expr> finally <expr>'."))];
}

function SR$$$parsUnexpectedEndOfFileWhile() {
  return [3105, (0, _String.toText)((0, _String.printf)("Unexpected end of input in 'while' expression. Expected 'while <expr> do <expr>'."))];
}

function SR$$$parsUnexpectedEndOfFileFor() {
  return [3106, (0, _String.toText)((0, _String.printf)("Unexpected end of input in 'for' expression. Expected 'for <pat> in <expr> do <expr>'."))];
}

function SR$$$parsUnexpectedEndOfFileWith() {
  return [3107, (0, _String.toText)((0, _String.printf)("Unexpected end of input in 'match' or 'try' expression"))];
}

function SR$$$parsUnexpectedEndOfFileThen() {
  return [3108, (0, _String.toText)((0, _String.printf)("Unexpected end of input in 'then' branch of conditional expression. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'."))];
}

function SR$$$parsUnexpectedEndOfFileElse() {
  return [3109, (0, _String.toText)((0, _String.printf)("Unexpected end of input in 'else' branch of conditional expression. Expected 'if <expr> then <expr>' or 'if <expr> then <expr> else <expr>'."))];
}

function SR$$$parsUnexpectedEndOfFileFunBody() {
  return [3110, (0, _String.toText)((0, _String.printf)("Unexpected end of input in body of lambda expression. Expected 'fun <pat> ... <pat> -> <expr>'."))];
}

function SR$$$parsUnexpectedEndOfFileTypeArgs() {
  return [3111, (0, _String.toText)((0, _String.printf)("Unexpected end of input in type arguments"))];
}

function SR$$$parsUnexpectedEndOfFileTypeSignature() {
  return [3112, (0, _String.toText)((0, _String.printf)("Unexpected end of input in type signature"))];
}

function SR$$$parsUnexpectedEndOfFileTypeDefinition() {
  return [3113, (0, _String.toText)((0, _String.printf)("Unexpected end of input in type definition"))];
}

function SR$$$parsUnexpectedEndOfFileObjectMembers() {
  return [3114, (0, _String.toText)((0, _String.printf)("Unexpected end of input in object members"))];
}

function SR$$$parsUnexpectedEndOfFileDefinition() {
  return [3115, (0, _String.toText)((0, _String.printf)("Unexpected end of input in value, function or member definition"))];
}

function SR$$$parsUnexpectedEndOfFileExpression() {
  return [3116, (0, _String.toText)((0, _String.printf)("Unexpected end of input in expression"))];
}

function SR$$$parsExpectedNameAfterToken() {
  return [3117, (0, _String.toText)((0, _String.printf)("Unexpected end of type. Expected a name after this point."))];
}

function SR$$$parsUnmatchedLet() {
  return [3118, (0, _String.toText)((0, _String.printf)("Incomplete value or function definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let' keyword."))];
}

function SR$$$parsUnmatchedLetBang() {
  return [3119, (0, _String.toText)((0, _String.printf)("Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'let!' keyword."))];
}

function SR$$$parsUnmatchedUseBang() {
  return [3120, (0, _String.toText)((0, _String.printf)("Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use!' keyword."))];
}

function SR$$$parsUnmatchedUse() {
  return [3121, (0, _String.toText)((0, _String.printf)("Incomplete value definition. If this is in an expression, the body of the expression must be indented to the same column as the 'use' keyword."))];
}

function SR$$$parsWhileDoExpected() {
  return [3122, (0, _String.toText)((0, _String.printf)("Missing 'do' in 'while' expression. Expected 'while <expr> do <expr>'."))];
}

function SR$$$parsForDoExpected() {
  return [3123, (0, _String.toText)((0, _String.printf)("Missing 'do' in 'for' expression. Expected 'for <pat> in <expr> do <expr>'."))];
}

function SR$$$tcInvalidRelationInJoin$$Z721C83C5(a0$$474) {
  return [3125, (0, _String.toText)((0, _String.printf)("Invalid join relation in '%s'. Expected 'expr <op> expr', where <op> is =, =?, ?= or ?=?."))(a0$$474)];
}

function SR$$$typeInfoCallsWord() {
  return (0, _String.toText)((0, _String.printf)("Calls"));
}

function SR$$$impInvalidNumberOfGenericArguments$$487EF8FB(a0$$475, a1$$227, a2$$86) {
  return [3126, (0, _String.toText)((0, _String.printf)("Invalid number of generic arguments to type '%s' in provided type. Expected '%d' arguments, given '%d'."))(a0$$475)(a1$$227)(a2$$86)];
}

function SR$$$impInvalidMeasureArgument1$$Z384F8060(a0$$476, a1$$228) {
  return [3127, (0, _String.toText)((0, _String.printf)("Invalid value '%s' for unit-of-measure parameter '%s'"))(a0$$476)(a1$$228)];
}

function SR$$$impInvalidMeasureArgument2$$Z721C83C5(a0$$477) {
  return [3127, (0, _String.toText)((0, _String.printf)("Invalid value unit-of-measure parameter '%s'"))(a0$$477)];
}

function SR$$$etPropertyNeedsCanWriteOrCanRead$$Z384F8060(a0$$478, a1$$229) {
  return [3128, (0, _String.toText)((0, _String.printf)("Property '%s' on provided type '%s' is neither readable nor writable as it has CanRead=false and CanWrite=false"))(a0$$478)(a1$$229)];
}

function SR$$$tcIntoNeedsRestOfQuery() {
  return [3129, (0, _String.toText)((0, _String.printf)("A use of 'into' must be followed by the remainder of the computation"))];
}

function SR$$$tcOperatorDoesntAcceptInto$$Z721C83C5(a0$$479) {
  return [3130, (0, _String.toText)((0, _String.printf)("The operator '%s' does not accept the use of 'into'"))(a0$$479)];
}

function SR$$$tcCustomOperationInvalid$$Z721C83C5(a0$$480) {
  return [3131, (0, _String.toText)((0, _String.printf)("The definition of the custom operator '%s' does not use a valid combination of attribute flags"))(a0$$480)];
}

function SR$$$tcThisTypeMayNotHaveACLIMutableAttribute() {
  return [3132, (0, _String.toText)((0, _String.printf)("This type definition may not have the 'CLIMutable' attribute. Only record types may have this attribute."))];
}

function SR$$$tcAutoPropertyRequiresImplicitConstructionSequence() {
  return [3133, (0, _String.toText)((0, _String.printf)("'member val' definitions are only permitted in types with a primary constructor. Consider adding arguments to your type definition, e.g. 'type X(args) = ...'."))];
}

function SR$$$parsMutableOnAutoPropertyShouldBeGetSet() {
  return [3134, (0, _String.toText)((0, _String.printf)("Property definitions may not be declared mutable. To indicate that this property can be set, use 'member val PropertyName = expr with get,set'."))];
}

function SR$$$parsMutableOnAutoPropertyShouldBeGetSetNotJustSet() {
  return [3135, (0, _String.toText)((0, _String.printf)("To indicate that this property can be set, use 'member val PropertyName = expr with get,set'."))];
}

function SR$$$chkNoByrefsOfByrefs$$Z721C83C5(a0$$481) {
  return [3136, (0, _String.toText)((0, _String.printf)("Type '%s' is illegal because in byref<T>, T cannot contain byref types."))(a0$$481)];
}

function SR$$$tastopsMaxArrayThirtyTwo$$Z524259A4(a0$$482) {
  return [3138, (0, _String.toText)((0, _String.printf)("F# supports array ranks between 1 and 32. The value %d is not allowed."))(a0$$482)];
}

function SR$$$tcNoIntegerForLoopInQuery() {
  return [3139, (0, _String.toText)((0, _String.printf)("In queries, use the form 'for x in n .. m do ...' for ranging over integers"))];
}

function SR$$$tcNoWhileInQuery() {
  return [3140, (0, _String.toText)((0, _String.printf)("'while' expressions may not be used in queries"))];
}

function SR$$$tcNoTryFinallyInQuery() {
  return [3141, (0, _String.toText)((0, _String.printf)("'try/finally' expressions may not be used in queries"))];
}

function SR$$$tcUseMayNotBeUsedInQueries() {
  return [3142, (0, _String.toText)((0, _String.printf)("'use' expressions may not be used in queries"))];
}

function SR$$$tcBindMayNotBeUsedInQueries() {
  return [3143, (0, _String.toText)((0, _String.printf)("'let!', 'use!' and 'do!' expressions may not be used in queries"))];
}

function SR$$$tcReturnMayNotBeUsedInQueries() {
  return [3144, (0, _String.toText)((0, _String.printf)("'return' and 'return!' may not be used in queries"))];
}

function SR$$$tcUnrecognizedQueryOperator() {
  return [3145, (0, _String.toText)((0, _String.printf)("This is not a known query operator. Query operators are identifiers such as 'select', 'where', 'sortBy', 'thenBy', 'groupBy', 'groupValBy', 'join', 'groupJoin', 'sumBy' and 'averageBy', defined using corresponding methods on the 'QueryBuilder' type."))];
}

function SR$$$tcTryWithMayNotBeUsedInQueries() {
  return [3146, (0, _String.toText)((0, _String.printf)("'try/with' expressions may not be used in queries"))];
}

function SR$$$tcNonSimpleLetBindingInQuery() {
  return [3147, (0, _String.toText)((0, _String.printf)("This 'let' definition may not be used in a query. Only simple value definitions may be used in queries."))];
}

function SR$$$etTooManyStaticParameters$$4F7761DC(a0$$483, a1$$230, a2$$87) {
  return [3148, (0, _String.toText)((0, _String.printf)("Too many static parameters. Expected at most %d parameters, but got %d unnamed and %d named parameters."))(a0$$483)(a1$$230)(a2$$87)];
}

function SR$$$infosInvalidProvidedLiteralValue$$Z721C83C5(a0$$484) {
  return [3149, (0, _String.toText)((0, _String.printf)("Invalid provided literal value '%s'"))(a0$$484)];
}

function SR$$$invalidPlatformTarget() {
  return [3150, (0, _String.toText)((0, _String.printf)("The 'anycpu32bitpreferred' platform can only be used with EXE targets. You must use 'anycpu' instead."))];
}

function SR$$$tcThisValueMayNotBeInlined() {
  return [3151, (0, _String.toText)((0, _String.printf)("This member, function or value declaration may not be declared 'inline'"))];
}

function SR$$$etErasedTypeUsedInGeneration$$Z384F8060(a0$$485, a1$$231) {
  return [3152, (0, _String.toText)((0, _String.printf)("The provider '%s' returned a non-generated type '%s' in the context of a set of generated types. Consider adjusting the type provider to only return generated types."))(a0$$485)(a1$$231)];
}

function SR$$$tcUnrecognizedQueryBinaryOperator() {
  return [3153, (0, _String.toText)((0, _String.printf)("Arguments to query operators may require parentheses, e.g. 'where (x > y)' or 'groupBy (x.Length / 10)'"))];
}

function SR$$$crefNoSetOfHole() {
  return [3155, (0, _String.toText)((0, _String.printf)("A quotation may not involve an assignment to or taking the address of a captured local variable"))];
}

function SR$$$nicePrintOtherOverloads1() {
  return (0, _String.toText)((0, _String.printf)("+ 1 overload"));
}

function SR$$$nicePrintOtherOverloadsN$$Z524259A4(a0$$486) {
  return (0, _String.toText)((0, _String.printf)("+ %d overloads"))(a0$$486);
}

function SR$$$erasedTo() {
  return (0, _String.toText)((0, _String.printf)("Erased to"));
}

function SR$$$parsUnfinishedExpression$$Z721C83C5(a0$$487) {
  return [3156, (0, _String.toText)((0, _String.printf)("Unexpected token '%s' or incomplete expression"))(a0$$487)];
}

function SR$$$parsAttributeOnIncompleteCode() {
  return [3158, (0, _String.toText)((0, _String.printf)("Cannot find code target for this attribute, possibly because the code after the attribute is incomplete."))];
}

function SR$$$parsTypeNameCannotBeEmpty() {
  return [3159, (0, _String.toText)((0, _String.printf)("Type name cannot be empty."))];
}

function SR$$$buildProblemReadingAssembly$$Z384F8060(a0$$488, a1$$232) {
  return [3160, (0, _String.toText)((0, _String.printf)("Problem reading assembly '%s': %s"))(a0$$488)(a1$$232)];
}

function SR$$$tcTPFieldMustBeLiteral() {
  return [3161, (0, _String.toText)((0, _String.printf)("Invalid provided field. Provided fields of erased provided types must be literals."))];
}

function SR$$$loadingDescription() {
  return (0, _String.toText)((0, _String.printf)("(loading description...)"));
}

function SR$$$descriptionUnavailable() {
  return (0, _String.toText)((0, _String.printf)("(description unavailable...)"));
}

function SR$$$chkTyparMultipleClassConstraints() {
  return [3162, (0, _String.toText)((0, _String.printf)("A type variable has been constrained by multiple different class types. A type variable may only have one class constraint."))];
}

function SR$$$tcMatchMayNotBeUsedWithQuery() {
  return [3163, (0, _String.toText)((0, _String.printf)("'match' expressions may not be used in queries"))];
}

function SR$$$memberOperatorDefinitionWithNonTripleArgument$$Z18115A39(a0$$489, a1$$233) {
  return [3164, (0, _String.toText)((0, _String.printf)("Infix operator member '%s' has %d initial argument(s). Expected a tuple of 3 arguments"))(a0$$489)(a1$$233)];
}

function SR$$$cannotResolveNullableOperators$$Z721C83C5(a0$$490) {
  return [3165, (0, _String.toText)((0, _String.printf)("The operator '%s' cannot be resolved. Consider opening the module 'Microsoft.FSharp.Linq.NullableOperators'."))(a0$$490)];
}

function SR$$$tcOperatorRequiresIn$$Z384F8060(a0$$491, a1$$234) {
  return [3167, (0, _String.toText)((0, _String.printf)("'%s' must be followed by 'in'. Usage: %s."))(a0$$491)(a1$$234)];
}

function SR$$$parsIllegalMemberVarInObjectImplementation() {
  return [3168, (0, _String.toText)((0, _String.printf)("Neither 'member val' nor 'override val' definitions are permitted in object expressions."))];
}

function SR$$$tcEmptyCopyAndUpdateRecordInvalid() {
  return [3169, (0, _String.toText)((0, _String.printf)("Copy-and-update record expressions must include at least one field."))];
}

function SR$$$parsUnderscoreInvalidFieldName() {
  return [3170, (0, _String.toText)((0, _String.printf)("'_' cannot be used as field name"))];
}

function SR$$$tcGeneratedTypesShouldBeInternalOrPrivate() {
  return [3171, (0, _String.toText)((0, _String.printf)("The provided types generated by this use of a type provider may not be used from other F# assemblies and should be marked internal or private. Consider using 'type internal TypeName = ...' or 'type private TypeName = ...'."))];
}

function SR$$$chkGetterAndSetterHaveSamePropertyType$$30230F9B(a0$$492, a1$$235, a2$$88) {
  return [3172, (0, _String.toText)((0, _String.printf)("A property's getter and setter must have the same type. Property '%s' has getter of type '%s' but setter of type '%s'."))(a0$$492)(a1$$235)(a2$$88)];
}

function SR$$$tcRuntimeSuppliedMethodCannotBeUsedInUserCode$$Z721C83C5(a0$$493) {
  return [3173, (0, _String.toText)((0, _String.printf)("Array method '%s' is supplied by the runtime and cannot be directly used in code. For operations with array elements consider using family of GetArray/SetArray functions from LanguagePrimitives.IntrinsicFunctions module."))(a0$$493)];
}

function SR$$$tcUnionCaseConstructorDoesNotHaveFieldWithGivenName$$Z384F8060(a0$$494, a1$$236) {
  return [3174, (0, _String.toText)((0, _String.printf)("Union case/exception '%s' does not have field named '%s'."))(a0$$494)(a1$$236)];
}

function SR$$$tcUnionCaseFieldCannotBeUsedMoreThanOnce$$Z721C83C5(a0$$495) {
  return [3175, (0, _String.toText)((0, _String.printf)("Union case/exception field '%s' cannot be used more than once."))(a0$$495)];
}

function SR$$$tcFieldNameIsUsedModeThanOnce$$Z721C83C5(a0$$496) {
  return [3176, (0, _String.toText)((0, _String.printf)("Named field '%s' is used more than once."))(a0$$496)];
}

function SR$$$tcFieldNameConflictsWithGeneratedNameForAnonymousField$$Z721C83C5(a0$$497) {
  return [3176, (0, _String.toText)((0, _String.printf)("Named field '%s' conflicts with autogenerated name for anonymous field."))(a0$$497)];
}

function SR$$$tastConstantExpressionOverflow() {
  return [3177, (0, _String.toText)((0, _String.printf)("This literal expression or attribute argument results in an arithmetic overflow."))];
}

function SR$$$tcIllegalStructTypeForConstantExpression() {
  return [3178, (0, _String.toText)((0, _String.printf)("This is not valid literal expression. The [<Literal>] attribute will be ignored."))];
}

function SR$$$fscSystemRuntimeInteropServicesIsRequired() {
  return [3179, (0, _String.toText)((0, _String.printf)("System.Runtime.InteropServices assembly is required to use UnknownWrapper\\DispatchWrapper classes."))];
}

function SR$$$abImplicitHeapAllocation$$Z721C83C5(a0$$498) {
  return [3180, (0, _String.toText)((0, _String.printf)("The mutable local '%s' is implicitly allocated as a reference cell because it has been captured by a closure. This warning is for informational purposes only to indicate where implicit allocations are performed."))(a0$$498)];
}

function SR$$$estApplyStaticArgumentsForMethodNotImplemented() {
  return (0, _String.toText)((0, _String.printf)("A type provider implemented GetStaticParametersForMethod, but ApplyStaticArgumentsForMethod was not implemented or invalid"));
}

function SR$$$etErrorApplyingStaticArgumentsToMethod() {
  return [3181, (0, _String.toText)((0, _String.printf)("An error occured applying the static arguments to a provided method"))];
}

function SR$$$pplexUnexpectedChar$$Z721C83C5(a0$$499) {
  return [3182, (0, _String.toText)((0, _String.printf)("Unexpected character '%s' in preprocessor expression"))(a0$$499)];
}

function SR$$$ppparsUnexpectedToken$$Z721C83C5(a0$$500) {
  return [3183, (0, _String.toText)((0, _String.printf)("Unexpected token '%s' in preprocessor expression"))(a0$$500)];
}

function SR$$$ppparsIncompleteExpression() {
  return [3184, (0, _String.toText)((0, _String.printf)("Incomplete preprocessor expression"))];
}

function SR$$$ppparsMissingToken$$Z721C83C5(a0$$501) {
  return [3185, (0, _String.toText)((0, _String.printf)("Missing token '%s' in preprocessor expression"))(a0$$501)];
}

function SR$$$pickleMissingDefinition$$7751B6FC(a0$$502, a1$$237, a2$$89) {
  return [3186, (0, _String.toText)((0, _String.printf)("An error occurred while reading the F# metadata node at position %d in table '%s' of assembly '%s'. The node had no matching declaration. Please report this warning. You may need to recompile the F# assembly you are using."))(a0$$502)(a1$$237)(a2$$89)];
}

function SR$$$checkNotSufficientlyGenericBecauseOfScope$$Z721C83C5(a0$$503) {
  return [3187, (0, _String.toText)((0, _String.printf)("Type inference caused the type variable %s to escape its scope. Consider adding an explicit type parameter declaration or adjusting your code to be less generic."))(a0$$503)];
}

function SR$$$checkNotSufficientlyGenericBecauseOfScopeAnon() {
  return [3188, (0, _String.toText)((0, _String.printf)("Type inference caused an inference type variable to escape its scope. Consider adding type annotations to make your code less generic."))];
}

function SR$$$checkRaiseFamilyFunctionArgumentCount$$487EF8FB(a0$$504, a1$$238, a2$$90) {
  return [3189, (0, _String.toText)((0, _String.printf)("Redundant arguments are being ignored in function '%s'. Expected %d but got %d arguments."))(a0$$504)(a1$$238)(a2$$90)];
}

function SR$$$checkLowercaseLiteralBindingInPattern$$Z721C83C5(a0$$505) {
  return [3190, (0, _String.toText)((0, _String.printf)("Lowercase literal '%s' is being shadowed by a new pattern with the same name. Only uppercase and module-prefixed literals can be used as named patterns."))(a0$$505)];
}

function SR$$$tcLiteralDoesNotTakeArguments() {
  return [3191, (0, _String.toText)((0, _String.printf)("This literal pattern does not take arguments"))];
}

function SR$$$tcConstructorsIllegalInAugmentation() {
  return [3192, (0, _String.toText)((0, _String.printf)("Constructors are not permitted as extension members - they must be defined as part of the original definition of the type"))];
}

function SR$$$optsInvalidResponseFile$$Z384F8060(a0$$506, a1$$239) {
  return [3193, (0, _String.toText)((0, _String.printf)("Invalid response file '%s' ( '%s' )"))(a0$$506)(a1$$239)];
}

function SR$$$optsResponseFileNotFound$$Z384F8060(a0$$507, a1$$240) {
  return [3194, (0, _String.toText)((0, _String.printf)("Response file '%s' not found in '%s'"))(a0$$507)(a1$$240)];
}

function SR$$$optsResponseFileNameInvalid$$Z721C83C5(a0$$508) {
  return [3195, (0, _String.toText)((0, _String.printf)("Response file name '%s' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long"))(a0$$508)];
}

function SR$$$fsharpCoreNotFoundToBeCopied() {
  return [3196, (0, _String.toText)((0, _String.printf)("Cannot find FSharp.Core.dll in compiler's directory"))];
}

function SR$$$tcTupleStructMismatch() {
  return (0, _String.toText)((0, _String.printf)("One tuple type is a struct tuple, the other is a reference tuple"));
}

function SR$$$etMissingStaticArgumentsToMethod() {
  return [3197, (0, _String.toText)((0, _String.printf)("This provided method requires static parameters"))];
}

function SR$$$considerUpcast$$Z384F8060(a0$$509, a1$$241) {
  return [3198, (0, _String.toText)((0, _String.printf)("The conversion from %s to %s is a compile-time safe upcast, not a downcast. Consider using 'upcast' instead of 'downcast'."))(a0$$509)(a1$$241)];
}

function SR$$$considerUpcastOperator$$Z384F8060(a0$$510, a1$$242) {
  return [3198, (0, _String.toText)((0, _String.printf)("The conversion from %s to %s is a compile-time safe upcast, not a downcast. Consider using the :> (upcast) operator instead of the :?> (downcast) operator."))(a0$$510)(a1$$242)];
}

function SR$$$tcRecImplied() {
  return [3199, (0, _String.toText)((0, _String.printf)("The 'rec' on this module is implied by an outer 'rec' declaration and is being ignored"))];
}

function SR$$$tcOpenFirstInMutRec() {
  return [3200, (0, _String.toText)((0, _String.printf)("In a recursive declaration group, 'open' declarations must come first in each module"))];
}

function SR$$$tcModuleAbbrevFirstInMutRec() {
  return [3201, (0, _String.toText)((0, _String.printf)("In a recursive declaration group, module abbreviations must come after all 'open' declarations and before other declarations"))];
}

function SR$$$tcUnsupportedMutRecDecl() {
  return [3202, (0, _String.toText)((0, _String.printf)("This declaration is not supported in recursive declaration groups"))];
}

function SR$$$parsInvalidUseOfRec() {
  return [3203, (0, _String.toText)((0, _String.printf)("Invalid use of 'rec' keyword"))];
}

function SR$$$tcStructUnionMultiCaseDistinctFields() {
  return [3204, (0, _String.toText)((0, _String.printf)("If a union type has more than one case and is a struct, then all fields within the union type must be given unique names."))];
}

function SR$$$CallerMemberNameIsOverriden$$Z721C83C5(a0$$511) {
  return [3206, (0, _String.toText)((0, _String.printf)("The CallerMemberNameAttribute applied to parameter '%s' will have no effect. It is overridden by the CallerFilePathAttribute."))(a0$$511)];
}

function SR$$$tcFixedNotAllowed() {
  return [3207, (0, _String.toText)((0, _String.printf)("Invalid use of 'fixed'. 'fixed' may only be used in a declaration of the form 'use x = fixed expr' where the expression is an array, the address of a field, the address of an array element or a string'"))];
}

function SR$$$tcCouldNotFindOffsetToStringData() {
  return [3208, (0, _String.toText)((0, _String.printf)("Could not find method System.Runtime.CompilerServices.OffsetToStringData in references when building 'fixed' expression."))];
}

function SR$$$chkNoByrefAddressOfLocal$$Z721C83C5(a0$$512) {
  return [3209, (0, _String.toText)((0, _String.printf)("The address of the variable '%s' or a related expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope."))(a0$$512)];
}

function SR$$$tcNamedActivePattern$$Z721C83C5(a0$$513) {
  return [3210, (0, _String.toText)((0, _String.printf)("%s is an active pattern and cannot be treated as a discriminated union case with named fields."))(a0$$513)];
}

function SR$$$DefaultParameterValueNotAppropriateForArgument() {
  return [3211, (0, _String.toText)((0, _String.printf)("The default value does not have the same type as the argument. The DefaultParameterValue attribute and any Optional attribute will be ignored. Note: 'null' needs to be annotated with the correct type, e.g. 'DefaultParameterValue(null:obj)'."))];
}

function SR$$$tcGlobalsSystemTypeNotFound$$Z721C83C5(a0$$514) {
  return (0, _String.toText)((0, _String.printf)("The system type '%s' was required but no referenced system DLL contained this type"))(a0$$514);
}

function SR$$$typrelMemberHasMultiplePossibleDispatchSlots$$Z384F8060(a0$$515, a1$$243) {
  return [3213, (0, _String.toText)((0, _String.printf)("The member '%s' matches multiple overloads of the same method.\nPlease restrict it to one of the following:%s."))(a0$$515)(a1$$243)];
}

function SR$$$methodIsNotStatic$$Z721C83C5(a0$$516) {
  return [3214, (0, _String.toText)((0, _String.printf)("Method or object constructor '%s' is not static"))(a0$$516)];
}

function SR$$$parsUnexpectedSymbolEqualsInsteadOfIn() {
  return [3215, (0, _String.toText)((0, _String.printf)("Unexpected symbol '=' in expression. Did you intend to use 'for x in y .. z do' instead?"))];
}

function SR$$$keywordDescriptionAbstract() {
  return (0, _String.toText)((0, _String.printf)("Indicates a method that either has no implementation in the type in which it is declared or that is virtual and has a default implementation."));
}

function SR$$$keyworkDescriptionAnd() {
  return (0, _String.toText)((0, _String.printf)("Used in mutually recursive bindings, in property declarations, and with multiple constraints on generic parameters."));
}

function SR$$$keywordDescriptionAs() {
  return (0, _String.toText)((0, _String.printf)("Used to give the current class object an object name. Also used to give a name to a whole pattern within a pattern match."));
}

function SR$$$keywordDescriptionAssert() {
  return (0, _String.toText)((0, _String.printf)("Used to verify code during debugging."));
}

function SR$$$keywordDescriptionBase() {
  return (0, _String.toText)((0, _String.printf)("Used as the name of the base class object."));
}

function SR$$$keywordDescriptionBegin() {
  return (0, _String.toText)((0, _String.printf)("In verbose syntax, indicates the start of a code block."));
}

function SR$$$keywordDescriptionClass() {
  return (0, _String.toText)((0, _String.printf)("In verbose syntax, indicates the start of a class definition."));
}

function SR$$$keywordDescriptionDefault() {
  return (0, _String.toText)((0, _String.printf)("Indicates an implementation of an abstract method; used together with an abstract method declaration to create a virtual method."));
}

function SR$$$keywordDescriptionDelegate() {
  return (0, _String.toText)((0, _String.printf)("Used to declare a delegate."));
}

function SR$$$keywordDescriptionDo() {
  return (0, _String.toText)((0, _String.printf)("Used in looping constructs or to execute imperative code."));
}

function SR$$$keywordDescriptionDone() {
  return (0, _String.toText)((0, _String.printf)("In verbose syntax, indicates the end of a block of code in a looping expression."));
}

function SR$$$keywordDescriptionDowncast() {
  return (0, _String.toText)((0, _String.printf)("Used to convert to a type that is lower in the inheritance chain."));
}

function SR$$$keywordDescriptionDownto() {
  return (0, _String.toText)((0, _String.printf)("In a for expression, used when counting in reverse."));
}

function SR$$$keywordDescriptionElif() {
  return (0, _String.toText)((0, _String.printf)("Used in conditional branching. A short form of else if."));
}

function SR$$$keywordDescriptionElse() {
  return (0, _String.toText)((0, _String.printf)("Used in conditional branching."));
}

function SR$$$keywordDescriptionEnd() {
  return (0, _String.toText)((0, _String.printf)("In type definitions and type extensions, indicates the end of a section of member definitions. In verbose syntax, used to specify the end of a code block that starts with the begin keyword."));
}

function SR$$$keywordDescriptionException() {
  return (0, _String.toText)((0, _String.printf)("Used to declare an exception type."));
}

function SR$$$keywordDescriptionExtern() {
  return (0, _String.toText)((0, _String.printf)("Indicates that a declared program element is defined in another binary or assembly."));
}

function SR$$$keywordDescriptionTrueFalse() {
  return (0, _String.toText)((0, _String.printf)("Used as a Boolean literal."));
}

function SR$$$keywordDescriptionFinally() {
  return (0, _String.toText)((0, _String.printf)("Used together with try to introduce a block of code that executes regardless of whether an exception occurs."));
}

function SR$$$keywordDescriptionFor() {
  return (0, _String.toText)((0, _String.printf)("Used in looping constructs."));
}

function SR$$$keywordDescriptionFun() {
  return (0, _String.toText)((0, _String.printf)("Used in lambda expressions, also known as anonymous functions."));
}

function SR$$$keywordDescriptionFunction() {
  return (0, _String.toText)((0, _String.printf)("Used as a shorter alternative to the fun keyword and a match expression in a lambda expression that has pattern matching on a single argument."));
}

function SR$$$keywordDescriptionGlobal() {
  return (0, _String.toText)((0, _String.printf)("Used to reference the top-level .NET namespace."));
}

function SR$$$keywordDescriptionIf() {
  return (0, _String.toText)((0, _String.printf)("Used in conditional branching constructs."));
}

function SR$$$keywordDescriptionIn() {
  return (0, _String.toText)((0, _String.printf)("Used for sequence expressions and, in verbose syntax, to separate expressions from bindings."));
}

function SR$$$keywordDescriptionInherit() {
  return (0, _String.toText)((0, _String.printf)("Used to specify a base class or base interface."));
}

function SR$$$keywordDescriptionInline() {
  return (0, _String.toText)((0, _String.printf)("Used to indicate a function that should be integrated directly into the caller's code."));
}

function SR$$$keywordDescriptionInterface() {
  return (0, _String.toText)((0, _String.printf)("Used to declare and implement interfaces."));
}

function SR$$$keywordDescriptionInternal() {
  return (0, _String.toText)((0, _String.printf)("Used to specify that a member is visible inside an assembly but not outside it."));
}

function SR$$$keywordDescriptionLazy() {
  return (0, _String.toText)((0, _String.printf)("Used to specify a computation that is to be performed only when a result is needed."));
}

function SR$$$keywordDescriptionLet() {
  return (0, _String.toText)((0, _String.printf)("Used to associate, or bind, a name to a value or function."));
}

function SR$$$keywordDescriptionLetBang() {
  return (0, _String.toText)((0, _String.printf)("Used in asynchronous workflows to bind a name to the result of an asynchronous computation, or, in other computation expressions, used to bind a name to a result, which is of the computation type."));
}

function SR$$$keywordDescriptionMatch() {
  return (0, _String.toText)((0, _String.printf)("Used to branch by comparing a value to a pattern."));
}

function SR$$$keywordDescriptionMatchBang() {
  return (0, _String.toText)((0, _String.printf)("Used in computation expressions to pattern match directly over the result of another computation expression."));
}

function SR$$$keywordDescriptionMember() {
  return (0, _String.toText)((0, _String.printf)("Used to declare a property or method in an object type."));
}

function SR$$$keywordDescriptionModule() {
  return (0, _String.toText)((0, _String.printf)("Used to associate a name with a group of related types, values, and functions, to logically separate it from other code."));
}

function SR$$$keywordDescriptionMutable() {
  return (0, _String.toText)((0, _String.printf)("Used to declare a variable, that is, a value that can be changed."));
}

function SR$$$keywordDescriptionNamespace() {
  return (0, _String.toText)((0, _String.printf)("Used to associate a name with a group of related types and modules, to logically separate it from other code."));
}

function SR$$$keywordDescriptionNew() {
  return (0, _String.toText)((0, _String.printf)("Used to declare, define, or invoke a constructor that creates or that can create an object. Also used in generic parameter constraints to indicate that a type must have a certain constructor."));
}

function SR$$$keywordDescriptionNot() {
  return (0, _String.toText)((0, _String.printf)("Not actually a keyword. However, not struct in combination is used as a generic parameter constraint."));
}

function SR$$$keywordDescriptionNull() {
  return (0, _String.toText)((0, _String.printf)("Indicates the absence of an object. Also used in generic parameter constraints."));
}

function SR$$$keywordDescriptionOf() {
  return (0, _String.toText)((0, _String.printf)("Used in discriminated unions to indicate the type of categories of values, and in delegate and exception declarations."));
}

function SR$$$keywordDescriptionOpen() {
  return (0, _String.toText)((0, _String.printf)("Used to make the contents of a namespace or module available without qualification."));
}

function SR$$$keywordDescriptionOr() {
  return (0, _String.toText)((0, _String.printf)("Used with Boolean conditions as a Boolean or operator. Equivalent to ||. Also used in member constraints."));
}

function SR$$$keywordDescriptionOverride() {
  return (0, _String.toText)((0, _String.printf)("Used to implement a version of an abstract or virtual method that differs from the base version."));
}

function SR$$$keywordDescriptionPrivate() {
  return (0, _String.toText)((0, _String.printf)("Restricts access to a member to code in the same type or module."));
}

function SR$$$keywordDescriptionPublic() {
  return (0, _String.toText)((0, _String.printf)("Allows access to a member from outside the type."));
}

function SR$$$keywordDescriptionRec() {
  return (0, _String.toText)((0, _String.printf)("Used to indicate that a function is recursive."));
}

function SR$$$keywordDescriptionReturn() {
  return (0, _String.toText)((0, _String.printf)("Used to indicate a value to provide as the result of a computation expression."));
}

function SR$$$keywordDescriptionReturnBang() {
  return (0, _String.toText)((0, _String.printf)("Used to indicate a computation expression that, when evaluated, provides the result of the containing computation expression."));
}

function SR$$$keywordDescriptionSelect() {
  return (0, _String.toText)((0, _String.printf)("Used in query expressions to specify what fields or columns to extract. Note that this is a contextual keyword, which means that it is not actually a reserved word and it only acts like a keyword in appropriate context."));
}

function SR$$$keywordDescriptionStatic() {
  return (0, _String.toText)((0, _String.printf)("Used to indicate a method or property that can be called without an instance of a type, or a value member that is shared among all instances of a type."));
}

function SR$$$keywordDescriptionStruct() {
  return (0, _String.toText)((0, _String.printf)("Used to declare a structure type. Also used in generic parameter constraints. Used for OCaml compatibility in module definitions."));
}

function SR$$$keywordDescriptionThen() {
  return (0, _String.toText)((0, _String.printf)("Used in conditional expressions. Also used to perform side effects after object construction."));
}

function SR$$$keywordDescriptionTo() {
  return (0, _String.toText)((0, _String.printf)("Used in for loops to indicate a range."));
}

function SR$$$keywordDescriptionTry() {
  return (0, _String.toText)((0, _String.printf)("Used to introduce a block of code that might generate an exception. Used together with with or finally."));
}

function SR$$$keywordDescriptionType() {
  return (0, _String.toText)((0, _String.printf)("Used to declare a class, record, structure, discriminated union, enumeration type, unit of measure, or type abbreviation."));
}

function SR$$$keywordDescriptionUpcast() {
  return (0, _String.toText)((0, _String.printf)("Used to convert to a type that is higher in the inheritance chain."));
}

function SR$$$keywordDescriptionUse() {
  return (0, _String.toText)((0, _String.printf)("Used instead of let for values that require Dispose to be called to free resources."));
}

function SR$$$keywordDescriptionUseBang() {
  return (0, _String.toText)((0, _String.printf)("Used instead of let! in asynchronous workflows and other computation expressions for values that require Dispose to be called to free resources."));
}

function SR$$$keywordDescriptionVal() {
  return (0, _String.toText)((0, _String.printf)("Used in a signature to indicate a value, or in a type to declare a member, in limited situations."));
}

function SR$$$keywordDescriptionVoid() {
  return (0, _String.toText)((0, _String.printf)("Indicates the .NET void type. Used when interoperating with other .NET languages."));
}

function SR$$$keywordDescriptionWhen() {
  return (0, _String.toText)((0, _String.printf)("Used for Boolean conditions (when guards) on pattern matches and to introduce a constraint clause for a generic type parameter."));
}

function SR$$$keywordDescriptionWhile() {
  return (0, _String.toText)((0, _String.printf)("Introduces a looping construct."));
}

function SR$$$keywordDescriptionWith() {
  return (0, _String.toText)((0, _String.printf)("Used together with the match keyword in pattern matching expressions. Also used in object expressions, record copying expressions, and type extensions to introduce member definitions, and to introduce exception handlers."));
}

function SR$$$keywordDescriptionYield() {
  return (0, _String.toText)((0, _String.printf)("Used in a sequence expression to produce a value for a sequence."));
}

function SR$$$keywordDescriptionYieldBang() {
  return (0, _String.toText)((0, _String.printf)("Used in a computation expression to append the result of a given computation expression to a collection of results for the containing computation expression."));
}

function SR$$$keywordDescriptionRightArrow() {
  return (0, _String.toText)((0, _String.printf)("In function types, delimits arguments and return values. Yields an expression (in sequence expressions); equivalent to the yield keyword. Used in match expressions"));
}

function SR$$$keywordDescriptionLeftArrow() {
  return (0, _String.toText)((0, _String.printf)("Assigns a value to a variable."));
}

function SR$$$keywordDescriptionCast() {
  return (0, _String.toText)((0, _String.printf)("Converts a type to type that is higher in the hierarchy."));
}

function SR$$$keywordDescriptionDynamicCast() {
  return (0, _String.toText)((0, _String.printf)("Converts a type to a type that is lower in the hierarchy."));
}

function SR$$$keywordDescriptionTypedQuotation() {
  return (0, _String.toText)((0, _String.printf)("Delimits a typed code quotation."));
}

function SR$$$keywordDescriptionUntypedQuotation() {
  return (0, _String.toText)((0, _String.printf)("Delimits a untyped code quotation."));
}

function SR$$$itemNotFoundDuringDynamicCodeGen$$30230F9B(a0$$517, a1$$244, a2$$91) {
  return [3216, (0, _String.toText)((0, _String.printf)("%s '%s' not found in assembly '%s'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version."))(a0$$517)(a1$$244)(a2$$91)];
}

function SR$$$itemNotFoundInTypeDuringDynamicCodeGen$$Z46998140(a0$$518, a1$$245, a2$$92, a3$$22) {
  return [3216, (0, _String.toText)((0, _String.printf)("%s '%s' not found in type '%s' from assembly '%s'. A possible cause may be a version incompatibility. You may need to explicitly reference the correct version of this assembly to allow all referenced components to use the correct version."))(a0$$518)(a1$$245)(a2$$92)(a3$$22)];
}

function SR$$$descriptionWordIs() {
  return (0, _String.toText)((0, _String.printf)("is"));
}

function SR$$$notAFunction() {
  return (0, _String.toText)((0, _String.printf)("This value is not a function and cannot be applied."));
}

function SR$$$notAFunctionButMaybeIndexerWithName$$Z721C83C5(a0$$519) {
  return (0, _String.toText)((0, _String.printf)("This value is not a function and cannot be applied. Did you intend to access the indexer via %s.[index] instead?"))(a0$$519);
}

function SR$$$notAFunctionButMaybeIndexer() {
  return (0, _String.toText)((0, _String.printf)("This expression is not a function and cannot be applied. Did you intend to access the indexer via expr.[index] instead?"));
}

function SR$$$notAFunctionButMaybeIndexerErrorCode() {
  return [3217, (0, _String.toText)((0, _String.printf)(""))];
}

function SR$$$notAFunctionButMaybeDeclaration() {
  return (0, _String.toText)((0, _String.printf)("This value is not a function and cannot be applied. Did you forget to terminate a declaration?"));
}

function SR$$$ArgumentsInSigAndImplMismatch$$Z384F8060(a0$$520, a1$$246) {
  return [3218, (0, _String.toText)((0, _String.printf)("The argument names in the signature '%s' and implementation '%s' do not match. The argument name from the signature file will be used. This may cause problems when debugging or profiling."))(a0$$520)(a1$$246)];
}

function SR$$$pickleUnexpectedNonZero$$Z721C83C5(a0$$521) {
  return [3219, (0, _String.toText)((0, _String.printf)("An error occurred while reading the F# metadata of assembly '%s'. A reserved construct was utilized. You may need to upgrade your F# compiler or use an earlier version of the assembly that doesn't make use of a specific construct."))(a0$$521)];
}

function SR$$$tcTupleMemberNotNormallyUsed() {
  return [3220, (0, _String.toText)((0, _String.printf)("This method or property is not normally used from F# code, use an explicit tuple pattern for deconstruction instead."))];
}

function SR$$$implicitlyDiscardedInSequenceExpression$$Z721C83C5(a0$$522) {
  return [3221, (0, _String.toText)((0, _String.printf)("This expression returns a value of type '%s' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield'."))(a0$$522)];
}

function SR$$$implicitlyDiscardedSequenceInSequenceExpression$$Z721C83C5(a0$$523) {
  return [3222, (0, _String.toText)((0, _String.printf)("This expression returns a value of type '%s' but is implicitly discarded. Consider using 'let' to bind the result to a name, e.g. 'let result = expression'. If you intended to use the expression as a value in the sequence then use an explicit 'yield!'."))(a0$$523)];
}

function SR$$$ilreadFileChanged$$Z721C83C5(a0$$524) {
  return [3223, (0, _String.toText)((0, _String.printf)("The file '%s' changed on disk unexpectedly, please reload."))(a0$$524)];
}

function SR$$$writeToReadOnlyByref() {
  return [3224, (0, _String.toText)((0, _String.printf)("The byref pointer is readonly, so this write is not permitted."))];
}

function SR$$$readOnlyAttributeOnStructWithMutableField() {
  return [3225, (0, _String.toText)((0, _String.printf)("A ReadOnly attribute has been applied to a struct type with a mutable field."))];
}

function SR$$$tcByrefReturnImplicitlyDereferenced() {
  return [3226, (0, _String.toText)((0, _String.printf)("A byref pointer returned by a function or method is implicitly dereferenced as of F# 4.5. To acquire the return value as a pointer, use the address-of operator, e.g. '&f(x)' or '&obj.Method(arg1, arg2)'."))];
}

function SR$$$tcByRefLikeNotStruct() {
  return [3227, (0, _String.toText)((0, _String.printf)("A type annotated with IsByRefLike must also be a struct. Consider adding the [<Struct>] attribute to the type."))];
}

function SR$$$chkNoByrefAddressOfValueFromExpression() {
  return [3228, (0, _String.toText)((0, _String.printf)("The address of a value returned from the expression cannot be used at this point. This is to ensure the address of the local value does not escape its scope."))];
}

function SR$$$chkNoReturnOfLimitedSpan() {
  return [3229, (0, _String.toText)((0, _String.printf)("The Span or IsByRefLike expression cannot be returned from this function or method, because it is composed using elements that may escape their scope."))];
}

function SR$$$chkNoWriteToLimitedSpan$$Z721C83C5(a0$$525) {
  return [3230, (0, _String.toText)((0, _String.printf)("This value can't be assigned because the target '%s' may refer to non-stack-local memory, while the expression being assigned is assessed to potentially refer to stack-local memory. This is to help prevent pointers to stack-bound memory escaping their scope."))(a0$$525)];
}

function SR$$$tastValueMustBeLocal() {
  return [3231, (0, _String.toText)((0, _String.printf)("A value defined in a module must be mutable in order to take its address, e.g. 'let mutable x = ...'"))];
}

function SR$$$tcIsReadOnlyNotStruct() {
  return [3232, (0, _String.toText)((0, _String.printf)("A type annotated with IsReadOnly must also be a struct. Consider adding the [<Struct>] attribute to the type."))];
}

function SR$$$chkStructsMayNotReturnAddressesOfContents() {
  return [3234, (0, _String.toText)((0, _String.printf)("Struct members cannot return the address of fields of the struct by reference"))];
}

function SR$$$chkNoByrefLikeFunctionCall() {
  return [3235, (0, _String.toText)((0, _String.printf)("The function or method call cannot be used at this point, because one argument that is a byref of a non-stack-local Span or IsByRefLike type is used with another argument that is a stack-local Span or IsByRefLike type. This is to ensure the address of the local value does not escape its scope."))];
}

function SR$$$chkNoSpanLikeVariable$$Z721C83C5(a0$$526) {
  return [3236, (0, _String.toText)((0, _String.printf)("The Span or IsByRefLike variable '%s' cannot be used at this point. This is to ensure the address of the local value does not escape its scope."))(a0$$526)];
}

function SR$$$chkNoSpanLikeValueFromExpression() {
  return [3237, (0, _String.toText)((0, _String.printf)("A Span or IsByRefLike value returned from the expression cannot be used at ths point. This is to ensure the address of the local value does not escape its scope."))];
}

function SR$$$tastCantTakeAddressOfExpression() {
  return [3238, (0, _String.toText)((0, _String.printf)("Cannot take the address of the value returned from the expression. Assign the returned value to a let-bound value before taking the address."))];
}